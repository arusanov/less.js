{"version":3,"file":"less.js","sources":["../lib/less/logger.js","../lib/less/environment/environment.js","../lib/less/source-map-output.js","../lib/less/source-map-builder.js","../lib/less/utils.js","../lib/less/less-error.js","../lib/less/contexts.js","../lib/less/tree/node.js","../lib/less/tree/alpha.js","../lib/less/data/colors.js","../lib/less/tree/color.js","../lib/less/tree/paren.js","../lib/less/tree/combinator.js","../lib/less/tree/element.js","../lib/less/tree/selector.js","../lib/less/tree/value.js","../lib/less/tree/keyword.js","../lib/less/tree/rule.js","../lib/less/functions/function-registry.js","../lib/less/functions/default.js","../lib/less/tree/debug-info.js","../lib/less/tree/ruleset.js","../lib/less/tree/directive.js","../lib/less/tree/detached-ruleset.js","../lib/less/data/unit-conversions.js","../lib/less/tree/unit.js","../lib/less/tree/dimension.js","../lib/less/tree/operation.js","../lib/less/tree/variable.js","../lib/less/tree/attribute.js","../lib/less/tree/js-eval-node.js","../lib/less/tree/quoted.js","../lib/less/tree/comment.js","../lib/less/tree/expression.js","../lib/less/functions/function-caller.js","../lib/less/tree/call.js","../lib/less/tree/url.js","../lib/less/tree/anonymous.js","../lib/less/tree/media.js","../lib/less/tree/import.js","../lib/less/tree/mixin-definition.js","../lib/less/tree/mixin-call.js","../lib/less/tree/javascript.js","../lib/less/tree/assignment.js","../lib/less/tree/condition.js","../lib/less/tree/unicode-descriptor.js","../lib/less/tree/negative.js","../lib/less/tree/extend.js","../lib/less/tree/ruleset-call.js","../lib/less/tree/index.js","../lib/less/visitors/visitor.js","../lib/less/visitors/import-sequencer.js","../lib/less/visitors/import-visitor.js","../lib/less/visitors/set-tree-visibility-visitor.js","../lib/less/visitors/extend-visitor.js","../lib/less/visitors/join-selector-visitor.js","../lib/less/visitors/to-css-visitor.js","../lib/less/visitors/index.js","../lib/less/transform-tree.js","../lib/less/parse-tree.js","../lib/less/parser/chunker.js","../lib/less/parser/parser-input.js","../lib/less/parser/parser.js","../lib/less/plugins/function-importer.js","../lib/less/import-manager.js","../lib/less/data/index.js","../lib/less/environment/abstract-file-manager.js","../lib/less/functions/color.js","../lib/less/functions/color-blending.js","../lib/less/functions/data-uri.js","../lib/less/functions/math-helper.js","../lib/less/functions/math.js","../lib/less/functions/number.js","../lib/less/functions/string.js","../lib/less/functions/svg.js","../lib/less/functions/types.js","../lib/less/functions/index.js","../lib/less/render.js","../lib/less/plugin-manager.js","../lib/less/parse.js","../lib/less/index.js","../lib/less-browser/index.js"],"sourcesContent":["module.exports = {\n  error(msg) {\n    this._fireEvent('error', msg)\n  },\n  warn(msg) {\n    this._fireEvent('warn', msg)\n  },\n  info(msg) {\n    this._fireEvent('info', msg)\n  },\n  debug(msg) {\n    this._fireEvent('debug', msg)\n  },\n  addListener(listener) {\n    this._listeners.push(listener)\n  },\n  removeListener(listener) {\n    for (let i = 0; i < this._listeners.length; i++) {\n      if (this._listeners[i] === listener) {\n        this._listeners.splice(i, 1)\n        return\n      }\n    }\n  },\n  _fireEvent(type, msg) {\n    for (let i = 0; i < this._listeners.length; i++) {\n      const logFunction = this._listeners[i][type]\n      if (logFunction) {\n        logFunction(msg)\n      }\n    }\n  },\n  _listeners: [],\n}\n","const logger = require('../logger')\n\nclass Environment {\n  constructor(externalEnvironment, fileManagers) {\n    this.fileManagers = fileManagers || []\n    externalEnvironment = externalEnvironment || {}\n\n    const optionalFunctions = [\n      'encodeBase64',\n      'mimeLookup',\n      'charsetLookup',\n      'getSourceMapGenerator',\n    ]\n    const requiredFunctions = []\n    const functions = requiredFunctions.concat(optionalFunctions)\n\n    for (let i = 0; i < functions.length; i++) {\n      const propName = functions[i]\n      const environmentFunc = externalEnvironment[propName]\n      if (environmentFunc) {\n        this[propName] = environmentFunc.bind(externalEnvironment)\n      } else if (i < requiredFunctions.length) {\n        this.warn(`missing required function in environment - ${propName}`)\n      }\n    }\n  }\n\n  getFileManager(filename, currentDirectory, options, environment, isSync) {\n    if (!filename) {\n      logger.warn(\n        'getFileManager called with no filename.. Please report this issue. continuing.'\n      )\n    }\n    if (!currentDirectory) {\n      logger.warn(\n        'getFileManager called with null directory.. Please report this issue. continuing.'\n      )\n    }\n\n    let fileManagers = this.fileManagers\n    if (options.pluginManager) {\n      fileManagers = []\n        .concat(fileManagers)\n        .concat(options.pluginManager.getFileManagers())\n    }\n    for (let i = fileManagers.length - 1; i >= 0; i--) {\n      const fileManager = fileManagers[i]\n      if (\n        fileManager[isSync ? 'supportsSync' : 'supports'](\n          filename,\n          currentDirectory,\n          options,\n          environment\n        )\n      ) {\n        return fileManager\n      }\n    }\n    return null\n  }\n\n  addFileManager(fileManager) {\n    this.fileManagers.push(fileManager)\n  }\n\n  clearFileManagers() {\n    this.fileManagers = []\n  }\n}\n\nmodule.exports = Environment\n","module.exports = environment => {\n  class SourceMapOutput {\n    constructor(options) {\n      this._css = []\n      this._rootNode = options.rootNode\n      this._contentsMap = options.contentsMap\n      this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap\n      if (options.sourceMapFilename) {\n        this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/')\n      }\n      this._outputFilename = options.outputFilename\n      this.sourceMapURL = options.sourceMapURL\n      if (options.sourceMapBasepath) {\n        this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/')\n      }\n      if (options.sourceMapRootpath) {\n        this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/')\n        if (\n          this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !==\n          '/'\n        ) {\n          this._sourceMapRootpath += '/'\n        }\n      } else {\n        this._sourceMapRootpath = ''\n      }\n      this._outputSourceFiles = options.outputSourceFiles\n      this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator()\n\n      this._lineNumber = 0\n      this._column = 0\n    }\n\n    normalizeFilename(filename) {\n      filename = filename.replace(/\\\\/g, '/')\n\n      if (\n        this._sourceMapBasepath &&\n        filename.indexOf(this._sourceMapBasepath) === 0\n      ) {\n        filename = filename.substring(this._sourceMapBasepath.length)\n        if (filename.charAt(0) === '\\\\' || filename.charAt(0) === '/') {\n          filename = filename.substring(1)\n        }\n      }\n      return (this._sourceMapRootpath || '') + filename\n    }\n\n    add(chunk, fileInfo, index, mapLines) {\n      //ignore adding empty strings\n      if (!chunk) {\n        return\n      }\n\n      let lines\n      let sourceLines\n      let columns\n      let sourceColumns\n      let i\n\n      if (fileInfo) {\n        let inputSource = this._contentsMap[fileInfo.filename]\n\n        // remove vars/banner added to the top of the file\n        if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n          // adjust the index\n          index -= this._contentsIgnoredCharsMap[fileInfo.filename]\n          if (index < 0) {\n            index = 0\n          }\n          // adjust the source\n          inputSource = inputSource.slice(\n            this._contentsIgnoredCharsMap[fileInfo.filename]\n          )\n        }\n        inputSource = inputSource.substring(0, index)\n        sourceLines = inputSource.split('\\n')\n        sourceColumns = sourceLines[sourceLines.length - 1]\n      }\n\n      lines = chunk.split('\\n')\n      columns = lines[lines.length - 1]\n\n      if (fileInfo) {\n        if (!mapLines) {\n          this._sourceMapGenerator.addMapping({\n            generated: { line: this._lineNumber + 1, column: this._column },\n            original: {\n              line: sourceLines.length,\n              column: sourceColumns.length,\n            },\n            source: this.normalizeFilename(fileInfo.filename),\n          })\n        } else {\n          for (i = 0; i < lines.length; i++) {\n            this._sourceMapGenerator.addMapping({\n              generated: {\n                line: this._lineNumber + i + 1,\n                column: i === 0 ? this._column : 0,\n              },\n              original: {\n                line: sourceLines.length + i,\n                column: i === 0 ? sourceColumns.length : 0,\n              },\n              source: this.normalizeFilename(fileInfo.filename),\n            })\n          }\n        }\n      }\n\n      if (lines.length === 1) {\n        this._column += columns.length\n      } else {\n        this._lineNumber += lines.length - 1\n        this._column = columns.length\n      }\n\n      this._css.push(chunk)\n    }\n\n    isEmpty() {\n      return this._css.length === 0\n    }\n\n    toCSS(context) {\n      this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({\n        file: this._outputFilename,\n        sourceRoot: null,\n      })\n\n      if (this._outputSourceFiles) {\n        for (const filename in this._contentsMap) {\n          if (this._contentsMap.hasOwnProperty(filename)) {\n            let source = this._contentsMap[filename]\n            if (this._contentsIgnoredCharsMap[filename]) {\n              source = source.slice(this._contentsIgnoredCharsMap[filename])\n            }\n            this._sourceMapGenerator.setSourceContent(\n              this.normalizeFilename(filename),\n              source\n            )\n          }\n        }\n      }\n\n      this._rootNode.genCSS(context, this)\n\n      if (this._css.length > 0) {\n        let sourceMapURL\n        const sourceMapContent = JSON.stringify(\n          this._sourceMapGenerator.toJSON()\n        )\n\n        if (this.sourceMapURL) {\n          sourceMapURL = this.sourceMapURL\n        } else if (this._sourceMapFilename) {\n          sourceMapURL = this._sourceMapFilename\n        }\n        this.sourceMapURL = sourceMapURL\n\n        this.sourceMap = sourceMapContent\n      }\n\n      return this._css.join('')\n    }\n  }\n\n  return SourceMapOutput\n}\n","module.exports = (SourceMapOutput, environment) => {\n  class SourceMapBuilder {\n    constructor(options) {\n      this.options = options\n    }\n\n    toCSS(rootNode, options, imports) {\n      const sourceMapOutput = new SourceMapOutput({\n        contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n        rootNode,\n        contentsMap: imports.contents,\n        sourceMapFilename: this.options.sourceMapFilename,\n        sourceMapURL: this.options.sourceMapURL,\n        outputFilename: this.options.sourceMapOutputFilename,\n        sourceMapBasepath: this.options.sourceMapBasepath,\n        sourceMapRootpath: this.options.sourceMapRootpath,\n        outputSourceFiles: this.options.outputSourceFiles,\n        sourceMapGenerator: this.options.sourceMapGenerator,\n        sourceMapFileInline: this.options.sourceMapFileInline,\n      })\n\n      const css = sourceMapOutput.toCSS(options)\n      this.sourceMap = sourceMapOutput.sourceMap\n      this.sourceMapURL = sourceMapOutput.sourceMapURL\n      if (this.options.sourceMapInputFilename) {\n        this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(\n          this.options.sourceMapInputFilename\n        )\n      }\n      return css + this.getCSSAppendage()\n    }\n\n    getCSSAppendage() {\n      let sourceMapURL = this.sourceMapURL\n      if (this.options.sourceMapFileInline) {\n        if (this.sourceMap === undefined) {\n          return ''\n        }\n        sourceMapURL = `data:application/json;base64,${environment.encodeBase64(\n          this.sourceMap\n        )}`\n      }\n\n      if (sourceMapURL) {\n        return `/*# sourceMappingURL=${sourceMapURL} */`\n      }\n      return ''\n    }\n\n    getExternalSourceMap() {\n      return this.sourceMap\n    }\n\n    setExternalSourceMap(sourceMap) {\n      this.sourceMap = sourceMap\n    }\n\n    isInline() {\n      return this.options.sourceMapFileInline\n    }\n\n    getSourceMapURL() {\n      return this.sourceMapURL\n    }\n\n    getOutputFilename() {\n      return this.options.sourceMapOutputFilename\n    }\n\n    getInputFilename() {\n      return this.sourceMapInputFilename\n    }\n  }\n\n  return SourceMapBuilder\n}\n","module.exports = {\n  getLocation(index, inputStream) {\n    let n = index + 1\n    let line = null\n    let column = -1\n\n    while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n      column++\n    }\n\n    if (typeof index === 'number') {\n      line = (inputStream.slice(0, index).match(/\\n/g) || '').length\n    }\n\n    return {\n      line,\n      column,\n    }\n  },\n}\n","const utils = require('./utils')\n\nconst LessError = (module.exports = function LessError(\n  e,\n  importManager,\n  currentFilename\n) {\n  Error.call(this)\n\n  const filename = e.filename || currentFilename\n\n  if (importManager && filename) {\n    const input = importManager.contents[filename]\n    const loc = utils.getLocation(e.index, input)\n    const line = loc.line\n    const col = loc.column\n    const callLine = e.call && utils.getLocation(e.call, input).line\n    const lines = input.split('\\n')\n\n    this.type = e.type || 'Syntax'\n    this.filename = filename\n    this.index = e.index\n    this.line = typeof line === 'number' ? line + 1 : null\n    this.callLine = callLine + 1\n    this.callExtract = lines[callLine]\n    this.column = col\n    this.extract = [lines[line - 1], lines[line], lines[line + 1]]\n  }\n  this.message = e.message\n  this.stack = e.stack\n})\n\nif (typeof Object.create === 'undefined') {\n  const F = () => {}\n  F.prototype = Error.prototype\n  LessError.prototype = new F()\n} else {\n  LessError.prototype = Object.create(Error.prototype)\n}\n\nLessError.prototype.constructor = LessError\n","const contexts = {}\nmodule.exports = contexts\n\nconst copyFromOriginal = function copyFromOriginal(\n  original,\n  destination,\n  propertiesToCopy\n) {\n  if (!original) {\n    return\n  }\n\n  for (let i = 0; i < propertiesToCopy.length; i++) {\n    if (original.hasOwnProperty(propertiesToCopy[i])) {\n      destination[propertiesToCopy[i]] = original[propertiesToCopy[i]]\n    }\n  }\n}\n\n/*\n parse is used whilst parsing\n */\nconst parseCopyProperties = [\n  // options\n  'paths', // option - unmodified - paths to search for imports on\n  'relativeUrls', // option - whether to adjust URL's to be relative\n  'rootpath', // option - rootpath to append to URL's\n  'strictImports', // option -\n  'insecure', // option - whether to allow imports from insecure ssl hosts\n  'dumpLineNumbers', // option - whether to dump line numbers\n  'compress', // option - whether to compress\n  'syncImport', // option - whether to import synchronously\n  'chunkInput', // option - whether to chunk input. more performant but causes parse issues.\n  'mime', // browser only - mime type for sheet import\n  'useFileCache', // browser only - whether to use the per file session cache\n  // context\n  'processImports', // option & context - whether to process imports. if false then imports will not be imported.\n  // Used by the import manager to stop multiple import visitors being created.\n  'pluginManager', // Used as the plugin manager for the session\n]\n\ncontexts.Parse = function(options) {\n  copyFromOriginal(options, this, parseCopyProperties)\n\n  if (typeof this.paths === 'string') {\n    this.paths = [this.paths]\n  }\n}\n\nconst evalCopyProperties = [\n  'paths', // additional include paths\n  'compress', // whether to compress\n  'ieCompat', // whether to enforce IE compatibility (IE8 data-uri)\n  'disableMath', // whether math enabled\n  'strictMath', // whether math has to be within parenthesis\n  'strictUnits', // whether units need to evaluate correctly\n  'sourceMap', // whether to output a source map\n  'importMultiple', // whether we are currently importing multiple copies\n  'urlArgs', // whether to add args into url tokens\n  'javascriptEnabled', // option - whether JavaScript is enabled. if undefined, defaults to true\n  'pluginManager', // Used as the plugin manager for the session\n  'importantScope', // used to bubble up !important statements,\n  'simplify', //Simplify less\n  'simplifyFilter', //Simplify variable filter\n]\n\ncontexts.Eval = function(options, frames) {\n  copyFromOriginal(options, this, evalCopyProperties)\n\n  if (typeof this.paths === 'string') {\n    this.paths = [this.paths]\n  }\n\n  this.frames = frames || []\n  this.importantScope = this.importantScope || []\n}\n\ncontexts.Eval.prototype.inParenthesis = function() {\n  if (!this.parensStack) {\n    this.parensStack = []\n  }\n  this.parensStack.push(true)\n}\n\ncontexts.Eval.prototype.outOfParenthesis = function() {\n  this.parensStack.pop()\n}\ncontexts.Eval.prototype.isInParens = function() {\n  return !!(this.parensStack && this.parensStack.length > 0)\n}\n\ncontexts.Eval.prototype.inCall = function() {\n  if (!this.callStack) {\n    this.callStack = []\n  }\n  this.callStack.push(true)\n}\n\ncontexts.Eval.prototype.outOfCall = function() {\n  this.callStack.pop()\n}\n\ncontexts.Eval.prototype.isInCall = function() {\n  return !!(this.callStack && this.callStack.length > 0)\n}\n\ncontexts.Eval.prototype.isMathOn = function() {\n  return !this.disableMath && (this.strictMath ? this.isInParens() : true)\n}\n\ncontexts.Eval.prototype.isPathRelative = path =>\n  !/^(?:[a-z-]+:|\\/|#)/i.test(path)\n\ncontexts.Eval.prototype.normalizePath = path => {\n  const segments = path.split('/').reverse()\n  let segment\n\n  path = []\n  while (segments.length !== 0) {\n    segment = segments.pop()\n    switch (segment) {\n      case '.':\n        break\n      case '..':\n        if (path.length === 0 || path[path.length - 1] === '..') {\n          path.push(segment)\n        } else {\n          path.pop()\n        }\n        break\n      default:\n        path.push(segment)\n        break\n    }\n  }\n\n  return path.join('/')\n}\n\n//todo - do the same for the toCSS ?\n","class Node {\n  toCSS(context) {\n    const strs = []\n    this.genCSS(context, {\n      add(chunk, fileInfo, index) {\n        strs.push(chunk)\n      },\n      isEmpty() {\n        return strs.length === 0\n      },\n    })\n    return strs.join('')\n  }\n\n  genCSS(context, output) {\n    output.add(this.value)\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  eval() {\n    return this\n  }\n\n  _operate(context, op, a, b) {\n    switch (op) {\n      case '+':\n        return a + b\n      case '-':\n        return a - b\n      case '*':\n        return a * b\n      case '/':\n        return a / b\n    }\n  }\n\n  fround(context, value) {\n    const precision = context && context.numPrecision\n    //add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999....) are properly rounded...\n    return precision == null\n      ? value\n      : Number((value + 2e-16).toFixed(precision))\n  }\n\n  // Returns true if this node represents root of ast imported by reference\n  blocksVisibility() {\n    if (this.visibilityBlocks == null) {\n      this.visibilityBlocks = 0\n    }\n    return this.visibilityBlocks !== 0\n  }\n\n  addVisibilityBlock() {\n    if (this.visibilityBlocks == null) {\n      this.visibilityBlocks = 0\n    }\n    this.visibilityBlocks = this.visibilityBlocks + 1\n  }\n\n  removeVisibilityBlock() {\n    if (this.visibilityBlocks == null) {\n      this.visibilityBlocks = 0\n    }\n    this.visibilityBlocks = this.visibilityBlocks - 1\n  }\n\n  //Turns on node visibility - if called node will be shown in output regardless\n  //of whether it comes from import by reference or not\n  ensureVisibility() {\n    this.nodeVisible = true\n  }\n\n  //Turns off node visibility - if called node will NOT be shown in output regardless\n  //of whether it comes from import by reference or not\n  ensureInvisibility() {\n    this.nodeVisible = false\n  }\n\n  // return values:\n  // false - the node must not be visible\n  // true - the node must be visible\n  // undefined or null - the node has the same visibility as its parent\n  isVisible() {\n    return this.nodeVisible\n  }\n\n  visibilityInfo() {\n    return {\n      visibilityBlocks: this.visibilityBlocks,\n      nodeVisible: this.nodeVisible,\n    }\n  }\n\n  copyVisibilityInfo(info) {\n    if (!info) {\n      return\n    }\n    this.visibilityBlocks = info.visibilityBlocks\n    this.nodeVisible = info.nodeVisible\n  }\n}\n\nNode.compare = (a, b) => {\n  /* returns:\n     -1: a < b\n     0: a = b\n     1: a > b\n     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n\n  if (\n    a.compare &&\n    // for \"symmetric results\" force toCSS-based comparison\n    // of Quoted or Anonymous if either value is one of those\n    !(b.type === 'Quoted' || b.type === 'Anonymous')\n  ) {\n    return a.compare(b)\n  } else if (b.compare) {\n    return -b.compare(a)\n  } else if (a.type !== b.type) {\n    return undefined\n  }\n\n  a = a.value\n  b = b.value\n  if (!Array.isArray(a)) {\n    return a === b ? 0 : undefined\n  }\n  if (a.length !== b.length) {\n    return undefined\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Node.compare(a[i], b[i]) !== 0) {\n      return undefined\n    }\n  }\n  return 0\n}\n\nNode.numericCompare = (a, b) =>\n  a < b ? -1 : a === b ? 0 : a > b ? 1 : undefined\nmodule.exports = Node\n","const Node = require('./node')\n\nclass Alpha extends Node {\n  constructor(val) {\n    super()\n    this.value = val\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  eval(context) {\n    if (this.value.eval) {\n      return new Alpha(this.value.eval(context))\n    }\n    return this\n  }\n\n  genCSS(context, output) {\n    output.add('alpha(opacity=')\n\n    if (this.value.genCSS) {\n      this.value.genCSS(context, output)\n    } else {\n      output.add(this.value)\n    }\n\n    output.add(')')\n  }\n}\n\nAlpha.prototype.type = 'Alpha'\n\nmodule.exports = Alpha\n","module.exports = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#00ffff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000000',\n  blanchedalmond: '#ffebcd',\n  blue: '#0000ff',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgrey: '#a9a9a9',\n  darkgreen: '#006400',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkslategrey: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dimgrey: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#ff00ff',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  grey: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  indianred: '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgray: '#d3d3d3',\n  lightgrey: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightslategrey: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#00ff00',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370d8',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#d87093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#ff0000',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  slategrey: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#ffffff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ffff00',\n  yellowgreen: '#9acd32',\n}\n","const Node = require('./node')\nconst colors = require('../data/colors')\n\n//\n// RGB Colors - #ff0014, #eee\n//\nclass Color extends Node {\n  constructor(rgb, a, originalForm) {\n    super()\n    //\n    // The end goal here, is to parse the arguments\n    // into an integer triplet, such as `128, 255, 0`\n    //\n    // This facilitates operations and conversions.\n    //\n    if (Array.isArray(rgb)) {\n      this.rgb = rgb\n    } else if (rgb.length == 6) {\n      this.rgb = rgb.match(/.{2}/g).map(c => parseInt(c, 16))\n    } else {\n      this.rgb = rgb.split('').map(c => parseInt(c + c, 16))\n    }\n    this.alpha = typeof a === 'number' ? a : 1\n    if (typeof originalForm !== 'undefined') {\n      this.value = originalForm\n    }\n  }\n\n  luma() {\n    let r = this.rgb[0] / 255\n    let g = this.rgb[1] / 255\n    let b = this.rgb[2] / 255\n\n    r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4)\n    g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4)\n    b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4)\n\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b\n  }\n\n  genCSS(context, output) {\n    output.add(this.toCSS(context))\n  }\n\n  toCSS(context, doNotCompress) {\n    const compress = context && context.compress && !doNotCompress\n    let color\n    let alpha\n\n    // `value` is set if this color was originally\n    // converted from a named color string so we need\n    // to respect this and try to output named color too.\n    if (this.value) {\n      return this.value\n    }\n\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    alpha = this.fround(context, this.alpha)\n    if (alpha < 1) {\n      return `rgba(${this.rgb\n        .map(c => clamp(Math.round(c), 255))\n        .concat(clamp(alpha, 1))\n        .join(',' + (compress ? '' : ' '))})`\n    }\n\n    color = this.toRGB()\n\n    if (compress) {\n      const splitcolor = color.split('')\n\n      // Convert color to short format\n      if (\n        splitcolor[1] === splitcolor[2] &&\n        splitcolor[3] === splitcolor[4] &&\n        splitcolor[5] === splitcolor[6]\n      ) {\n        color = `#${splitcolor[1]}${splitcolor[3]}${splitcolor[5]}`\n      }\n    }\n\n    return color\n  }\n\n  //\n  // Operations have to be done per-channel, if not,\n  // channels will spill onto each other. Once we have\n  // our result, in the form of an integer triplet,\n  // we create a new Color node to hold the result.\n  //\n  operate(context, op, other) {\n    const rgb = []\n    const alpha = this.alpha * (1 - other.alpha) + other.alpha\n    for (let c = 0; c < 3; c++) {\n      rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c])\n    }\n    return new Color(rgb, alpha)\n  }\n\n  toRGB() {\n    return toHex(this.rgb)\n  }\n\n  toHSL() {\n    const r = this.rgb[0] / 255\n    const g = this.rgb[1] / 255\n    const b = this.rgb[2] / 255\n    const a = this.alpha\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    let h\n    let s\n    const l = (max + min) / 2\n    const d = max - min\n\n    if (max === min) {\n      h = s = 0\n    } else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min)\n\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0)\n          break\n        case g:\n          h = (b - r) / d + 2\n          break\n        case b:\n          h = (r - g) / d + 4\n          break\n      }\n      h /= 6\n    }\n    return { h: h * 360, s, l, a }\n  }\n\n  //Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n  toHSV() {\n    const r = this.rgb[0] / 255\n    const g = this.rgb[1] / 255\n    const b = this.rgb[2] / 255\n    const a = this.alpha\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    let h\n    let s\n    const v = max\n\n    const d = max - min\n    if (max === 0) {\n      s = 0\n    } else {\n      s = d / max\n    }\n\n    if (max === min) {\n      h = 0\n    } else {\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0)\n          break\n        case g:\n          h = (b - r) / d + 2\n          break\n        case b:\n          h = (r - g) / d + 4\n          break\n      }\n      h /= 6\n    }\n    return { h: h * 360, s, v, a }\n  }\n\n  toARGB() {\n    return toHex([this.alpha * 255].concat(this.rgb))\n  }\n\n  compare(x) {\n    return x.rgb &&\n      x.rgb[0] === this.rgb[0] &&\n      x.rgb[1] === this.rgb[1] &&\n      x.rgb[2] === this.rgb[2] &&\n      x.alpha === this.alpha\n      ? 0\n      : undefined\n  }\n}\n\nColor.prototype.type = 'Color'\n\nfunction clamp(v, max) {\n  return Math.min(Math.max(v, 0), max)\n}\n\nfunction toHex(v) {\n  return `#${v\n    .map(c => {\n      c = clamp(Math.round(c), 255)\n      return (c < 16 ? '0' : '') + c.toString(16)\n    })\n    .join('')}`\n}\n\nColor.fromKeyword = keyword => {\n  let c\n  const key = keyword.toLowerCase()\n  if (colors.hasOwnProperty(key)) {\n    c = new Color(colors[key].slice(1))\n  } else if (key === 'transparent') {\n    c = new Color([0, 0, 0], 0)\n  }\n\n  if (c) {\n    c.value = keyword\n    return c\n  }\n}\nmodule.exports = Color\n","const Node = require('./node')\n\nclass Paren extends Node {\n  constructor(node) {\n    super()\n    this.value = node\n  }\n\n  genCSS(context, output) {\n    output.add('(')\n    this.value.genCSS(context, output)\n    output.add(')')\n  }\n\n  eval(context) {\n    return new Paren(this.value.eval(context))\n  }\n}\n\nParen.prototype.type = 'Paren'\nmodule.exports = Paren\n","const Node = require('./node')\n\nclass Combinator extends Node {\n  constructor(value) {\n    super()\n    if (value === ' ') {\n      this.value = ' '\n      this.emptyOrWhitespace = true\n    } else {\n      this.value = value ? value.trim() : ''\n      this.emptyOrWhitespace = this.value === ''\n    }\n  }\n\n  genCSS(context, output) {\n    const spaceOrEmpty =\n      context.compress || _noSpaceCombinators[this.value] ? '' : ' '\n    output.add(spaceOrEmpty + this.value + spaceOrEmpty)\n  }\n}\n\nCombinator.prototype.type = 'Combinator'\nconst _noSpaceCombinators = {\n  '': true,\n  ' ': true,\n  '|': true,\n}\nmodule.exports = Combinator\n","const Node = require('./node')\nconst Paren = require('./paren')\nconst Combinator = require('./combinator')\n\nclass Element extends Node {\n  constructor(combinator, value, index, currentFileInfo, info) {\n    super()\n    this.combinator =\n      combinator instanceof Combinator ? combinator : new Combinator(combinator)\n\n    if (typeof value === 'string') {\n      this.value = value.trim()\n    } else if (value) {\n      this.value = value\n    } else {\n      this.value = ''\n    }\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.copyVisibilityInfo(info)\n  }\n\n  accept(visitor) {\n    const value = this.value\n    this.combinator = visitor.visit(this.combinator)\n    if (typeof value === 'object') {\n      this.value = visitor.visit(value)\n    }\n  }\n\n  eval(context) {\n    return new Element(\n      this.combinator,\n      this.value.eval ? this.value.eval(context) : this.value,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  clone() {\n    return new Element(\n      this.combinator,\n      this.value,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  genCSS(context, output) {\n    output.add(this.toCSS(context), this.currentFileInfo, this.index)\n  }\n\n  toCSS(context = {}) {\n    let value = this.value\n    const firstSelector = context.firstSelector\n    if (value instanceof Paren) {\n      // selector in parens should not be affected by outer selector\n      // flags (breaks only interpolated selectors - see #1973)\n      context.firstSelector = true\n    }\n    value = value.toCSS ? value.toCSS(context) : value\n    context.firstSelector = firstSelector\n    if (value === '' && this.combinator.value.charAt(0) === '&') {\n      return ''\n    } else {\n      return this.combinator.toCSS(context) + value\n    }\n  }\n}\n\nElement.prototype.type = 'Element'\nmodule.exports = Element\n","const Node = require('./node')\nconst Element = require('./element')\n\nclass Selector extends Node {\n  constructor(\n    elements,\n    extendList,\n    condition,\n    index,\n    currentFileInfo,\n    visibilityInfo\n  ) {\n    super()\n    this.elements = elements\n    this.extendList = extendList\n    this.condition = condition\n    this.currentFileInfo = currentFileInfo || {}\n    if (!condition) {\n      this.evaldCondition = true\n    }\n    this.copyVisibilityInfo(visibilityInfo)\n  }\n\n  accept(visitor) {\n    if (this.elements) {\n      this.elements = visitor.visitArray(this.elements)\n    }\n    if (this.extendList) {\n      this.extendList = visitor.visitArray(this.extendList)\n    }\n    if (this.condition) {\n      this.condition = visitor.visit(this.condition)\n    }\n  }\n\n  createDerived(elements, extendList, evaldCondition) {\n    const info = this.visibilityInfo()\n    evaldCondition =\n      evaldCondition != null ? evaldCondition : this.evaldCondition\n    const newSelector = new Selector(\n      elements,\n      extendList || this.extendList,\n      null,\n      this.index,\n      this.currentFileInfo,\n      info\n    )\n    newSelector.evaldCondition = evaldCondition\n    newSelector.mediaEmpty = this.mediaEmpty\n    return newSelector\n  }\n\n  createEmptySelectors() {\n    const el = new Element('', '&', this.index, this.currentFileInfo)\n    const sels = [\n      new Selector([el], null, null, this.index, this.currentFileInfo),\n    ]\n    sels[0].mediaEmpty = true\n    return sels\n  }\n\n  match(other) {\n    const elements = this.elements\n    const len = elements.length\n    let olen\n    let i\n\n    other.CacheElements()\n\n    olen = other._elements.length\n    if (olen === 0 || len < olen) {\n      return 0\n    } else {\n      for (i = 0; i < olen; i++) {\n        if (elements[i].value !== other._elements[i]) {\n          return 0\n        }\n      }\n    }\n\n    return olen // return number of matched elements\n  }\n\n  CacheElements() {\n    if (this._elements) {\n      return\n    }\n\n    let elements = this.elements\n      .map(v => v.combinator.value + (v.value.value || v.value))\n      .join('')\n      .match(/[,&#\\*\\.\\w-]([\\w-]|(\\\\.))*/g)\n\n    if (elements) {\n      if (elements[0] === '&') {\n        elements.shift()\n      }\n    } else {\n      elements = []\n    }\n\n    this._elements = elements\n  }\n\n  isJustParentSelector() {\n    return (\n      !this.mediaEmpty &&\n      this.elements.length === 1 &&\n      this.elements[0].value === '&' &&\n      (this.elements[0].combinator.value === ' ' ||\n        this.elements[0].combinator.value === '')\n    )\n  }\n\n  eval(context) {\n    const evaldCondition = this.condition && this.condition.eval(context)\n    let elements = this.elements\n    let extendList = this.extendList\n\n    elements = elements && elements.map(e => e.eval(context))\n    extendList = extendList && extendList.map(extend => extend.eval(context))\n\n    return this.createDerived(elements, extendList, evaldCondition)\n  }\n\n  genCSS(context, output) {\n    let i\n    let element\n    if (\n      (!context || !context.firstSelector) &&\n      this.elements[0].combinator.value === ''\n    ) {\n      output.add(' ', this.currentFileInfo, this.index)\n    }\n    if (!this._css) {\n      //TODO caching? speed comparison?\n      for (i = 0; i < this.elements.length; i++) {\n        element = this.elements[i]\n        element.genCSS(context, output)\n      }\n    }\n  }\n\n  getIsOutput() {\n    return this.evaldCondition\n  }\n}\n\nSelector.prototype.type = 'Selector'\nmodule.exports = Selector\n","const Node = require('./node')\n\nclass Value extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n    if (!value) {\n      throw new Error('Value requires an array argument')\n    }\n  }\n\n  accept(visitor) {\n    if (this.value) {\n      this.value = visitor.visitArray(this.value)\n    }\n  }\n\n  eval(context) {\n    if (this.value.length === 1) {\n      return this.value[0].eval(context)\n    } else {\n      return new Value(this.value.map(v => v.eval(context)))\n    }\n  }\n\n  genCSS(context, output) {\n    let i\n    for (i = 0; i < this.value.length; i++) {\n      this.value[i].genCSS(context, output)\n      if (i + 1 < this.value.length) {\n        output.add(context && context.compress ? ',' : ', ')\n      }\n    }\n  }\n}\n\nValue.prototype.type = 'Value'\nmodule.exports = Value\n","const Node = require('./node')\n\nclass Keyword extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n  }\n\n  genCSS(context, output) {\n    if (this.value === '%') {\n      throw { type: 'Syntax', message: 'Invalid % without number' }\n    }\n    output.add(this.value)\n  }\n}\n\nKeyword.prototype.type = 'Keyword'\n\nKeyword.True = new Keyword('true')\nKeyword.False = new Keyword('false')\n\nmodule.exports = Keyword\n","const Node = require('./node')\nconst Value = require('./value')\nconst Keyword = require('./keyword')\n\nclass Rule extends Node {\n  constructor(\n    name,\n    value,\n    important,\n    merge,\n    index,\n    currentFileInfo,\n    inline,\n    variable\n  ) {\n    super()\n    this.name = name\n    this.value = value instanceof Node ? value : new Value([value]) //value instanceof tree.Value || value instanceof tree.Ruleset ??\n    this.important = important ? ` ${important.trim()}` : ''\n    this.merge = merge\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.inline = inline || false\n    this.variable =\n      variable !== undefined ? variable : name.charAt && name.charAt(0) === '@'\n    this.allowRoot = true\n  }\n\n  genCSS(context, output) {\n    output.add(\n      this.name + (context.compress ? ':' : ': '),\n      this.currentFileInfo,\n      this.index\n    )\n    try {\n      this.value.genCSS(context, output)\n    } catch (e) {\n      e.index = this.index\n      e.filename = this.currentFileInfo.filename\n      throw e\n    }\n    output.add(\n      this.important +\n        (this.inline || (context.lastRule && context.compress) ? '' : ';'),\n      this.currentFileInfo,\n      this.index\n    )\n  }\n\n  eval(context) {\n    let strictMathBypass = false\n    let name = this.name\n    let evaldValue\n    let variable = this.variable\n    if (typeof name !== 'string') {\n      // expand 'primitive' name directly to get\n      // things faster (~10% for benchmark.less):\n      name =\n        name.length === 1 && name[0] instanceof Keyword\n          ? name[0].value\n          : evalName(context, name)\n      variable = false // never treat expanded interpolation as new variable name\n    }\n    if (name === 'font' && !context.strictMath) {\n      strictMathBypass = true\n      context.strictMath = true\n    }\n    try {\n      context.importantScope.push({})\n      evaldValue = this.value.eval(context)\n\n      if (!this.variable && evaldValue.type === 'DetachedRuleset') {\n        throw {\n          message: 'Rulesets cannot be evaluated on a property.',\n          index: this.index,\n          filename: this.currentFileInfo.filename,\n        }\n      }\n      let important = this.important\n      const importantResult = context.importantScope.pop()\n      if (!important && importantResult.important) {\n        important = importantResult.important\n      }\n\n      return new Rule(\n        name,\n        evaldValue,\n        important,\n        this.merge,\n        this.index,\n        this.currentFileInfo,\n        this.inline,\n        variable\n      )\n    } catch (e) {\n      if (typeof e.index !== 'number') {\n        e.index = this.index\n        e.filename = this.currentFileInfo.filename\n      }\n      throw e\n    } finally {\n      if (strictMathBypass) {\n        context.strictMath = false\n      }\n    }\n  }\n\n  makeImportant() {\n    return new Rule(\n      this.name,\n      this.value,\n      '!important',\n      this.merge,\n      this.index,\n      this.currentFileInfo,\n      this.inline\n    )\n  }\n}\n\nfunction evalName(context, name) {\n  let value = ''\n  let i\n  const n = name.length\n  const output = {\n    add(s) {\n      value += s\n    },\n  }\n  for (i = 0; i < n; i++) {\n    name[i].eval(context).genCSS(context, output)\n  }\n  return value\n}\n\nRule.prototype.type = 'Rule'\n\nmodule.exports = Rule\n","function makeRegistry(base) {\n  return {\n    _data: {},\n    add(name, func) {\n      // precautionary case conversion, as later querying of\n      // the registry by function-caller uses lower case as well.\n      name = name.toLowerCase()\n\n      if (this._data.hasOwnProperty(name)) {\n        //TODO warn\n      }\n      this._data[name] = func\n    },\n    addMultiple(functions) {\n      Object.keys(functions).forEach(name => {\n        this.add(name, functions[name])\n      })\n    },\n    get(name) {\n      return this._data[name] || (base && base.get(name))\n    },\n    inherit() {\n      return makeRegistry(this)\n    },\n  }\n}\n\nmodule.exports = makeRegistry(null)\n","const Keyword = require('../tree/keyword')\nconst functionRegistry = require('./function-registry')\n\nconst defaultFunc = {\n  eval() {\n    const v = this.value_\n    const e = this.error_\n    if (e) {\n      throw e\n    }\n    if (v != null) {\n      return v ? Keyword.True : Keyword.False\n    }\n  },\n  value(v) {\n    this.value_ = v\n  },\n  error(e) {\n    this.error_ = e\n  },\n  reset() {\n    this.value_ = this.error_ = null\n  },\n}\n\nfunctionRegistry.add('default', defaultFunc.eval.bind(defaultFunc))\n\nmodule.exports = defaultFunc\n","const debugInfo = (context, ctx, lineSeparator) => {\n  let result = ''\n  if (context.dumpLineNumbers && !context.compress) {\n    switch (context.dumpLineNumbers) {\n      case 'comments':\n        result = debugInfo.asComment(ctx)\n        break\n      case 'mediaquery':\n        result = debugInfo.asMediaQuery(ctx)\n        break\n      case 'all':\n        result =\n          debugInfo.asComment(ctx) +\n          (lineSeparator || '') +\n          debugInfo.asMediaQuery(ctx)\n        break\n    }\n  }\n  return result\n}\n\ndebugInfo.asComment = ctx =>\n  `/* line ${ctx.debugInfo.lineNumber}, ${ctx.debugInfo.fileName} */\\n`\n\ndebugInfo.asMediaQuery = ctx => {\n  let filenameWithProtocol = ctx.debugInfo.fileName\n  if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n    filenameWithProtocol = `file://${filenameWithProtocol}`\n  }\n  return `@media -sass-debug-info{filename{font-family:${filenameWithProtocol.replace(\n    /([.:\\/\\\\])/g,\n    a => {\n      if (a == '\\\\') {\n        a = '/'\n      }\n      return '\\\\' + a\n    }\n  )}}line{font-family:\\\\00003${ctx.debugInfo.lineNumber}}}\\n`\n}\n\nmodule.exports = debugInfo\n","const Node = require('./node')\nconst Rule = require('./rule')\nconst Selector = require('./selector')\nconst Element = require('./element')\nconst Paren = require('./paren')\nconst contexts = require('../contexts')\nconst globalFunctionRegistry = require('../functions/function-registry')\nconst defaultFunc = require('../functions/default')\nconst getDebugInfo = require('./debug-info')\n\nclass Ruleset extends Node {\n  constructor(selectors, rules, strictImports, visibilityInfo) {\n    super()\n    this.selectors = selectors\n    this.rules = rules\n    this._lookups = {}\n    this.strictImports = strictImports\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.paths) {\n      this.paths = visitor.visitArray(this.paths, true)\n    } else if (this.selectors) {\n      this.selectors = visitor.visitArray(this.selectors)\n    }\n    if (this.rules && this.rules.length) {\n      this.rules = visitor.visitArray(this.rules)\n    }\n  }\n\n  eval(context) {\n    const thisSelectors = this.selectors\n    let selectors\n    let selCnt\n    let selector\n    let i\n    let hasOnePassingSelector = false\n\n    if (thisSelectors && (selCnt = thisSelectors.length)) {\n      selectors = []\n      defaultFunc.error({\n        type: 'Syntax',\n        message: 'it is currently only allowed in parametric mixin guards,',\n      })\n      for (i = 0; i < selCnt; i++) {\n        selector = thisSelectors[i].eval(context)\n        selectors.push(selector)\n        if (selector.evaldCondition) {\n          hasOnePassingSelector = true\n        }\n      }\n      defaultFunc.reset()\n    } else {\n      hasOnePassingSelector = true\n    }\n\n    let rules = this.rules ? this.rules.slice(0) : null\n    const ruleset = new Ruleset(\n      selectors,\n      rules,\n      this.strictImports,\n      this.visibilityInfo()\n    )\n    let rule\n    let subRule\n\n    ruleset.originalRuleset = this\n    ruleset.root = this.root\n    ruleset.firstRoot = this.firstRoot\n    ruleset.allowImports = this.allowImports\n\n    if (this.debugInfo) {\n      ruleset.debugInfo = this.debugInfo\n    }\n\n    if (!hasOnePassingSelector) {\n      rules.length = 0\n    }\n\n    // inherit a function registry from the frames stack when possible;\n    // otherwise from the global registry\n    ruleset.functionRegistry = (frames => {\n      let i = 0\n      const n = frames.length\n      let found\n      for (; i !== n; ++i) {\n        found = frames[i].functionRegistry\n        if (found) {\n          return found\n        }\n      }\n      return globalFunctionRegistry\n    })(context.frames).inherit()\n\n    // push the current ruleset to the frames stack\n    const ctxFrames = context.frames\n    ctxFrames.unshift(ruleset)\n\n    // currrent selectors\n    let ctxSelectors = context.selectors\n    if (!ctxSelectors) {\n      context.selectors = ctxSelectors = []\n    }\n    ctxSelectors.unshift(this.selectors)\n\n    // Evaluate imports\n    if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n      ruleset.evalImports(context)\n    }\n\n    // Store the frames around mixin definitions,\n    // so they can be evaluated like closures when the time comes.\n    const rsRules = ruleset.rules\n\n    let rsRuleCnt = rsRules ? rsRules.length : 0\n    for (i = 0; i < rsRuleCnt; i++) {\n      if (rsRules[i].evalFirst) {\n        rsRules[i] = rsRules[i].eval(context)\n      }\n    }\n\n    const mediaBlockCount =\n      (context.mediaBlocks && context.mediaBlocks.length) || 0\n\n    // Evaluate mixin calls.\n    for (i = 0; i < rsRuleCnt; i++) {\n      if (rsRules[i].type === 'MixinCall') {\n        /*jshint loopfunc:true */\n        rules = rsRules[i].eval(context).filter(r => {\n          if (r instanceof Rule && r.variable) {\n            // do not pollute the scope if the variable is\n            // already there. consider returning false here\n            // but we need a way to \"return\" variable from mixins\n            return !ruleset.variable(r.name)\n          }\n          return true\n        })\n        rsRules.splice(...[i, 1].concat(rules))\n        rsRuleCnt += rules.length - 1\n        i += rules.length - 1\n        ruleset.resetCache()\n      } else if (rsRules[i].type === 'RulesetCall') {\n        /*jshint loopfunc:true */\n        rules = rsRules[i].eval(context).rules.filter(r => {\n          if (r instanceof Rule && r.variable) {\n            // do not pollute the scope at all\n            return false\n          }\n          return true\n        })\n        rsRules.splice(...[i, 1].concat(rules))\n        rsRuleCnt += rules.length - 1\n        i += rules.length - 1\n        ruleset.resetCache()\n      }\n    }\n\n    // Evaluate everything else\n    for (i = 0; i < rsRules.length; i++) {\n      rule = rsRules[i]\n      if (!rule.evalFirst) {\n        rsRules[i] = rule = rule.eval ? rule.eval(context) : rule\n      }\n    }\n\n    // Evaluate everything else\n    for (i = 0; i < rsRules.length; i++) {\n      rule = rsRules[i]\n      // for rulesets, check if it is a css guard and can be removed\n      if (\n        rule instanceof Ruleset &&\n        rule.selectors &&\n        rule.selectors.length === 1\n      ) {\n        // check if it can be folded in (e.g. & where)\n        if (rule.selectors[0].isJustParentSelector()) {\n          rsRules.splice(i--, 1)\n\n          for (let j = 0; j < rule.rules.length; j++) {\n            subRule = rule.rules[j]\n            subRule.copyVisibilityInfo(rule.visibilityInfo())\n            if (!(subRule instanceof Rule) || !subRule.variable) {\n              rsRules.splice(++i, 0, subRule)\n            }\n          }\n        }\n      }\n    }\n\n    // Pop the stack\n    ctxFrames.shift()\n    ctxSelectors.shift()\n\n    if (context.mediaBlocks) {\n      for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n        context.mediaBlocks[i].bubbleSelectors(selectors)\n      }\n    }\n\n    return ruleset\n  }\n\n  evalImports(context) {\n    const rules = this.rules\n    let i\n    let importRules\n    if (!rules) {\n      return\n    }\n\n    for (i = 0; i < rules.length; i++) {\n      if (rules[i].type === 'Import') {\n        importRules = rules[i].eval(context)\n        if (importRules && (importRules.length || importRules.length === 0)) {\n          rules.splice(...[i, 1].concat(importRules))\n          i += importRules.length - 1\n        } else {\n          rules.splice(i, 1, importRules)\n        }\n        this.resetCache()\n      }\n    }\n  }\n\n  makeImportant() {\n    const result = new Ruleset(\n      this.selectors,\n      this.rules.map(r => {\n        if (r.makeImportant) {\n          return r.makeImportant()\n        } else {\n          return r\n        }\n      }),\n      this.strictImports,\n      this.visibilityInfo()\n    )\n\n    return result\n  }\n\n  matchArgs(args) {\n    return !args || args.length === 0\n  }\n\n  // lets you call a css selector with a guard\n  matchCondition(args, context) {\n    const lastSelector = this.selectors[this.selectors.length - 1]\n    if (!lastSelector.evaldCondition) {\n      return false\n    }\n    if (\n      lastSelector.condition &&\n      !lastSelector.condition.eval(new contexts.Eval(context, context.frames))\n    ) {\n      return false\n    }\n    return true\n  }\n\n  resetCache() {\n    this._rulesets = null\n    this._variables = null\n    this._lookups = {}\n  }\n\n  variables() {\n    if (!this._variables) {\n      this._variables = !this.rules\n        ? {}\n        : this.rules.reduce((hash, r) => {\n            if (r instanceof Rule && r.variable === true) {\n              hash[r.name] = r\n            }\n            // when evaluating variables in an import statement, imports have not been eval'd\n            // so we need to go inside import statements.\n            // guard against root being a string (in the case of inlined less)\n            if (r.type === 'Import' && r.root && r.root.variables) {\n              const vars = r.root.variables()\n              for (const name in vars) {\n                if (vars.hasOwnProperty(name)) {\n                  hash[name] = vars[name]\n                }\n              }\n            }\n            return hash\n          }, {})\n    }\n    return this._variables\n  }\n\n  variable(name) {\n    return this.variables()[name]\n  }\n\n  rulesets() {\n    if (!this.rules) {\n      return []\n    }\n\n    const filtRules = []\n    const rules = this.rules\n    const cnt = rules.length\n    let i\n    let rule\n\n    for (i = 0; i < cnt; i++) {\n      rule = rules[i]\n      if (rule.isRuleset) {\n        filtRules.push(rule)\n      }\n    }\n\n    return filtRules\n  }\n\n  prependRule(rule) {\n    const rules = this.rules\n    if (rules) {\n      rules.unshift(rule)\n    } else {\n      this.rules = [rule]\n    }\n  }\n\n  find(selector, self = this, filter) {\n    const rules = []\n    let match\n    let foundMixins\n    const key = selector.toCSS()\n\n    if (key in this._lookups) {\n      return this._lookups[key]\n    }\n\n    this.rulesets().forEach(rule => {\n      if (rule !== self) {\n        for (let j = 0; j < rule.selectors.length; j++) {\n          match = selector.match(rule.selectors[j])\n          if (match) {\n            if (selector.elements.length > match) {\n              if (!filter || filter(rule)) {\n                foundMixins = rule.find(\n                  new Selector(selector.elements.slice(match)),\n                  self,\n                  filter\n                )\n                for (let i = 0; i < foundMixins.length; ++i) {\n                  foundMixins[i].path.push(rule)\n                }\n                Array.prototype.push.apply(rules, foundMixins)\n              }\n            } else {\n              rules.push({ rule, path: [] })\n            }\n            break\n          }\n        }\n      }\n    })\n    this._lookups[key] = rules\n    return rules\n  }\n\n  genCSS(context, output) {\n    let i\n    let j\n    const charsetRuleNodes = []\n    let ruleNodes = []\n\n    let // Line number debugging\n    debugInfo\n\n    let rule\n    let path\n\n    context.tabLevel = context.tabLevel || 0\n\n    if (!this.root) {\n      context.tabLevel++\n    }\n\n    const tabRuleStr = context.compress\n      ? ''\n      : Array(context.tabLevel + 1).join('  ')\n    const tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ')\n    let sep\n\n    function isRulesetLikeNode(rule) {\n      // if it has nested rules, then it should be treated like a ruleset\n      // medias and comments do not have nested rules, but should be treated like rulesets anyway\n      // some directives and anonymous nodes are ruleset like, others are not\n      if (typeof rule.isRulesetLike === 'boolean') {\n        return rule.isRulesetLike\n      } else if (typeof rule.isRulesetLike === 'function') {\n        return rule.isRulesetLike()\n      }\n\n      //anything else is assumed to be a rule\n      return false\n    }\n\n    let charsetNodeIndex = 0\n    let importNodeIndex = 0\n    for (i = 0; i < this.rules.length; i++) {\n      rule = this.rules[i]\n      if (rule.type === 'Comment') {\n        if (importNodeIndex === i) {\n          importNodeIndex++\n        }\n        ruleNodes.push(rule)\n      } else if (rule.isCharset && rule.isCharset()) {\n        ruleNodes.splice(charsetNodeIndex, 0, rule)\n        charsetNodeIndex++\n        importNodeIndex++\n      } else if (rule.type === 'Import') {\n        ruleNodes.splice(importNodeIndex, 0, rule)\n        importNodeIndex++\n      } else {\n        ruleNodes.push(rule)\n      }\n    }\n    ruleNodes = charsetRuleNodes.concat(ruleNodes)\n\n    // If this is the root node, we don't render\n    // a selector, or {}.\n    if (!this.root) {\n      debugInfo = getDebugInfo(context, this, tabSetStr)\n\n      if (debugInfo) {\n        output.add(debugInfo)\n        output.add(tabSetStr)\n      }\n\n      const paths = this.paths\n      const pathCnt = paths.length\n      let pathSubCnt\n\n      sep = context.compress ? ',' : `,\\n${tabSetStr}`\n\n      for (i = 0; i < pathCnt; i++) {\n        path = paths[i]\n        if (!(pathSubCnt = path.length)) {\n          continue\n        }\n        if (i > 0) {\n          output.add(sep)\n        }\n\n        context.firstSelector = true\n        path[0].genCSS(context, output)\n\n        context.firstSelector = false\n        for (j = 1; j < pathSubCnt; j++) {\n          path[j].genCSS(context, output)\n        }\n      }\n\n      output.add((context.compress ? '{' : ' {\\n') + tabRuleStr)\n    }\n\n    // Compile rules and rulesets\n    for (i = 0; i < ruleNodes.length; i++) {\n      rule = ruleNodes[i]\n\n      if (i + 1 === ruleNodes.length) {\n        context.lastRule = true\n      }\n\n      const currentLastRule = context.lastRule\n      if (isRulesetLikeNode(rule)) {\n        context.lastRule = false\n      }\n\n      if (rule.genCSS) {\n        rule.genCSS(context, output)\n      } else if (rule.value) {\n        output.add(rule.value.toString())\n      }\n\n      context.lastRule = currentLastRule\n\n      if (!context.lastRule) {\n        output.add(context.compress ? '' : `\\n${tabRuleStr}`)\n      } else {\n        context.lastRule = false\n      }\n    }\n\n    if (!this.root) {\n      output.add(context.compress ? '}' : `\\n${tabSetStr}}`)\n      context.tabLevel--\n    }\n\n    if (!output.isEmpty() && !context.compress && this.firstRoot) {\n      output.add('\\n')\n    }\n  }\n\n  joinSelectors(paths, context, selectors) {\n    for (let s = 0; s < selectors.length; s++) {\n      this.joinSelector(paths, context, selectors[s])\n    }\n  }\n\n  joinSelector(paths, context, selector) {\n    function createParenthesis(elementsToPak, originalElement) {\n      let replacementParen\n      let j\n      if (elementsToPak.length === 0) {\n        replacementParen = new Paren(elementsToPak[0])\n      } else {\n        const insideParent = []\n        for (j = 0; j < elementsToPak.length; j++) {\n          insideParent.push(\n            new Element(\n              null,\n              elementsToPak[j],\n              originalElement.index,\n              originalElement.currentFileInfo\n            )\n          )\n        }\n        replacementParen = new Paren(new Selector(insideParent))\n      }\n      return replacementParen\n    }\n\n    function createSelector(containedElement, originalElement) {\n      let element\n      let selector\n      element = new Element(\n        null,\n        containedElement,\n        originalElement.index,\n        originalElement.currentFileInfo\n      )\n      selector = new Selector([element])\n      return selector\n    }\n\n    // joins selector path from `beginningPath` with selector path in `addPath`\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns concatenated path\n    function addReplacementIntoPath(\n      beginningPath,\n      addPath,\n      replacedElement,\n      originalSelector\n    ) {\n      let newSelectorPath\n      let lastSelector\n      let newJoinedSelector\n      // our new selector path\n      newSelectorPath = []\n\n      //construct the joined selector - if & is the first thing this will be empty,\n      // if not newJoinedSelector will be the last set of elements in the selector\n      if (beginningPath.length > 0) {\n        newSelectorPath = beginningPath.slice(0)\n        lastSelector = newSelectorPath.pop()\n        newJoinedSelector = originalSelector.createDerived(\n          lastSelector.elements.slice(0)\n        )\n      } else {\n        newJoinedSelector = originalSelector.createDerived([])\n      }\n\n      if (addPath.length > 0) {\n        // /deep/ is a combinator that is valid without anything in front of it\n        // so if the & does not have a combinator that is \"\" or \" \" then\n        // and there is a combinator on the parent, then grab that.\n        // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n        let combinator = replacedElement.combinator\n\n        const parentEl = addPath[0].elements[0]\n        if (\n          combinator.emptyOrWhitespace &&\n          !parentEl.combinator.emptyOrWhitespace\n        ) {\n          combinator = parentEl.combinator\n        }\n        // join the elements so far with the first part of the parent\n        newJoinedSelector.elements.push(\n          new Element(\n            combinator,\n            parentEl.value,\n            replacedElement.index,\n            replacedElement.currentFileInfo\n          )\n        )\n        newJoinedSelector.elements = newJoinedSelector.elements.concat(\n          addPath[0].elements.slice(1)\n        )\n      }\n\n      // now add the joined selector - but only if it is not empty\n      if (newJoinedSelector.elements.length !== 0) {\n        newSelectorPath.push(newJoinedSelector)\n      }\n\n      //put together the parent selectors after the join (e.g. the rest of the parent)\n      if (addPath.length > 1) {\n        let restOfPath = addPath.slice(1)\n        restOfPath = restOfPath.map(selector =>\n          selector.createDerived(selector.elements, [])\n        )\n        newSelectorPath = newSelectorPath.concat(restOfPath)\n      }\n      return newSelectorPath\n    }\n\n    // joins selector path from `beginningPath` with every selector path in `addPaths` array\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns array with all concatenated paths\n    function addAllReplacementsIntoPath(\n      beginningPath,\n      addPaths,\n      replacedElement,\n      originalSelector,\n      result\n    ) {\n      let j\n      for (j = 0; j < beginningPath.length; j++) {\n        const newSelectorPath = addReplacementIntoPath(\n          beginningPath[j],\n          addPaths,\n          replacedElement,\n          originalSelector\n        )\n        result.push(newSelectorPath)\n      }\n      return result\n    }\n\n    function mergeElementsOnToSelectors(elements, selectors) {\n      let i\n      let sel\n\n      if (elements.length === 0) {\n        return\n      }\n      if (selectors.length === 0) {\n        selectors.push([new Selector(elements)])\n        return\n      }\n\n      for (i = 0; i < selectors.length; i++) {\n        sel = selectors[i]\n\n        // if the previous thing in sel is a parent this needs to join on to it\n        if (sel.length > 0) {\n          sel[sel.length - 1] = sel[sel.length - 1].createDerived(\n            sel[sel.length - 1].elements.concat(elements)\n          )\n        } else {\n          sel.push(new Selector(elements))\n        }\n      }\n    }\n\n    // replace all parent selectors inside `inSelector` by content of `context` array\n    // resulting selectors are returned inside `paths` array\n    // returns true if `inSelector` contained at least one parent selector\n    function replaceParentSelector(paths, context, inSelector) {\n      // The paths are [[Selector]]\n      // The first list is a list of comma separated selectors\n      // The inner list is a list of inheritance separated selectors\n      // e.g.\n      // .a, .b {\n      //   .c {\n      //   }\n      // }\n      // == [[.a] [.c]] [[.b] [.c]]\n      //\n      let i\n\n      let j\n      let k\n      let currentElements\n      let newSelectors\n      let selectorsMultiplied\n      let sel\n      let el\n      let hadParentSelector = false\n      let length\n      let lastSelector\n      function findNestedSelector(element) {\n        let maybeSelector\n        if (element.value.type !== 'Paren') {\n          return null\n        }\n\n        maybeSelector = element.value.value\n        if (maybeSelector.type !== 'Selector') {\n          return null\n        }\n\n        return maybeSelector\n      }\n\n      // the elements from the current selector so far\n      currentElements = []\n      // the current list of new selectors to add to the path.\n      // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n      // by the parents\n      newSelectors = [[]]\n\n      for (i = 0; i < inSelector.elements.length; i++) {\n        el = inSelector.elements[i]\n        // non parent reference elements just get added\n        if (el.value !== '&') {\n          const nestedSelector = findNestedSelector(el)\n          if (nestedSelector != null) {\n            // merge the current list of non parent selector elements\n            // on to the current list of selectors to add\n            mergeElementsOnToSelectors(currentElements, newSelectors)\n\n            const nestedPaths = []\n            let replaced\n            const replacedNewSelectors = []\n            replaced = replaceParentSelector(\n              nestedPaths,\n              context,\n              nestedSelector\n            )\n            hadParentSelector = hadParentSelector || replaced\n            //the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n            for (k = 0; k < nestedPaths.length; k++) {\n              const replacementSelector = createSelector(\n                createParenthesis(nestedPaths[k], el),\n                el\n              )\n              addAllReplacementsIntoPath(\n                newSelectors,\n                [replacementSelector],\n                el,\n                inSelector,\n                replacedNewSelectors\n              )\n            }\n            newSelectors = replacedNewSelectors\n            currentElements = []\n          } else {\n            currentElements.push(el)\n          }\n        } else {\n          hadParentSelector = true\n          // the new list of selectors to add\n          selectorsMultiplied = []\n\n          // merge the current list of non parent selector elements\n          // on to the current list of selectors to add\n          mergeElementsOnToSelectors(currentElements, newSelectors)\n\n          // loop through our current selectors\n          for (j = 0; j < newSelectors.length; j++) {\n            sel = newSelectors[j]\n            // if we don't have any parent paths, the & might be in a mixin so that it can be used\n            // whether there are parents or not\n            if (context.length === 0) {\n              // the combinator used on el should now be applied to the next element instead so that\n              // it is not lost\n              if (sel.length > 0) {\n                sel[0].elements.push(\n                  new Element(el.combinator, '', el.index, el.currentFileInfo)\n                )\n              }\n              selectorsMultiplied.push(sel)\n            } else {\n              // and the parent selectors\n              for (k = 0; k < context.length; k++) {\n                // We need to put the current selectors\n                // then join the last selector's elements on to the parents selectors\n                const newSelectorPath = addReplacementIntoPath(\n                  sel,\n                  context[k],\n                  el,\n                  inSelector\n                )\n                // add that to our new set of selectors\n                selectorsMultiplied.push(newSelectorPath)\n              }\n            }\n          }\n\n          // our new selectors has been multiplied, so reset the state\n          newSelectors = selectorsMultiplied\n          currentElements = []\n        }\n      }\n\n      // if we have any elements left over (e.g. .a& .b == .b)\n      // add them on to all the current selectors\n      mergeElementsOnToSelectors(currentElements, newSelectors)\n\n      for (i = 0; i < newSelectors.length; i++) {\n        length = newSelectors[i].length\n        if (length > 0) {\n          paths.push(newSelectors[i])\n          lastSelector = newSelectors[i][length - 1]\n          newSelectors[i][length - 1] = lastSelector.createDerived(\n            lastSelector.elements,\n            inSelector.extendList\n          )\n          //newSelectors[i][length - 1].copyVisibilityInfo(inSelector.visibilityInfo());\n        }\n      }\n\n      return hadParentSelector\n    }\n\n    function deriveSelector(visibilityInfo, deriveFrom) {\n      const newSelector = deriveFrom.createDerived(\n        deriveFrom.elements,\n        deriveFrom.extendList,\n        deriveFrom.evaldCondition\n      )\n      newSelector.copyVisibilityInfo(visibilityInfo)\n      return newSelector\n    }\n\n    // joinSelector code follows\n    let i\n\n    let newPaths\n    let hadParentSelector\n\n    newPaths = []\n    hadParentSelector = replaceParentSelector(newPaths, context, selector)\n\n    if (!hadParentSelector) {\n      if (context.length > 0) {\n        newPaths = []\n        for (i = 0; i < context.length; i++) {\n          //var concatenated = [];\n          //context[i].forEach(function(entry) {\n          //    var newEntry = entry.createDerived(entry.elements, entry.extendList, entry.evaldCondition);\n          //    newEntry.copyVisibilityInfo(selector.visibilityInfo());\n          //    concatenated.push(newEntry);\n          //}, this);\n          const concatenated = context[i].map(\n            deriveSelector.bind(this, selector.visibilityInfo())\n          )\n\n          concatenated.push(selector)\n          newPaths.push(concatenated)\n        }\n      } else {\n        newPaths = [[selector]]\n      }\n    }\n\n    for (i = 0; i < newPaths.length; i++) {\n      paths.push(newPaths[i])\n    }\n  }\n}\n\nRuleset.prototype.type = 'Ruleset'\nRuleset.prototype.isRuleset = true\nRuleset.prototype.isRulesetLike = true\nmodule.exports = Ruleset\n","const Node = require('./node')\nconst Selector = require('./selector')\nconst Ruleset = require('./ruleset')\n\nclass Directive extends Node {\n  constructor(\n    name,\n    value,\n    rules,\n    index,\n    currentFileInfo,\n    debugInfo,\n    isRooted,\n    visibilityInfo\n  ) {\n    super()\n    let i\n\n    this.name = name\n    this.value = value\n    if (rules) {\n      if (Array.isArray(rules)) {\n        this.rules = rules\n      } else {\n        this.rules = [rules]\n        this.rules[0].selectors = new Selector(\n          [],\n          null,\n          null,\n          this.index,\n          currentFileInfo\n        ).createEmptySelectors()\n      }\n      for (i = 0; i < this.rules.length; i++) {\n        this.rules[i].allowImports = true\n      }\n    }\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.debugInfo = debugInfo\n    this.isRooted = isRooted || false\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    const value = this.value\n    const rules = this.rules\n    if (rules) {\n      this.rules = visitor.visitArray(rules)\n    }\n    if (value) {\n      this.value = visitor.visit(value)\n    }\n  }\n\n  isRulesetLike() {\n    return this.rules || !this.isCharset()\n  }\n\n  isCharset() {\n    return '@charset' === this.name\n  }\n\n  genCSS(context, output) {\n    const value = this.value\n    const rules = this.rules\n    output.add(this.name, this.currentFileInfo, this.index)\n    if (value) {\n      output.add(' ')\n      value.genCSS(context, output)\n    }\n    if (rules) {\n      this.outputRuleset(context, output, rules)\n    } else {\n      output.add(';')\n    }\n  }\n\n  eval(context) {\n    let mediaPathBackup\n    let mediaBlocksBackup\n    let value = this.value\n    let rules = this.rules\n\n    //media stored inside other directive should not bubble over it\n    //backpup media bubbling information\n    mediaPathBackup = context.mediaPath\n    mediaBlocksBackup = context.mediaBlocks\n    //deleted media bubbling information\n    context.mediaPath = []\n    context.mediaBlocks = []\n\n    if (value) {\n      value = value.eval(context)\n    }\n    if (rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      rules = [rules[0].eval(context)]\n      rules[0].root = true\n    }\n    //restore media bubbling information\n    context.mediaPath = mediaPathBackup\n    context.mediaBlocks = mediaBlocksBackup\n\n    return new Directive(\n      this.name,\n      value,\n      rules,\n      this.index,\n      this.currentFileInfo,\n      this.debugInfo,\n      this.isRooted,\n      this.visibilityInfo()\n    )\n  }\n\n  variable(name) {\n    if (this.rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      return Ruleset.prototype.variable.call(this.rules[0], name)\n    }\n  }\n\n  find(...args) {\n    if (this.rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      return Ruleset.prototype.find.apply(this.rules[0], args)\n    }\n  }\n\n  rulesets() {\n    if (this.rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      return Ruleset.prototype.rulesets.apply(this.rules[0])\n    }\n  }\n\n  outputRuleset(context, output, rules) {\n    const ruleCnt = rules.length\n    let i\n    context.tabLevel = (context.tabLevel | 0) + 1\n\n    // Compressed\n    if (context.compress) {\n      output.add('{')\n      for (i = 0; i < ruleCnt; i++) {\n        rules[i].genCSS(context, output)\n      }\n      output.add('}')\n      context.tabLevel--\n      return\n    }\n\n    // Non-compressed\n    const tabSetStr = `\\n${Array(context.tabLevel).join('  ')}`\n\n    const tabRuleStr = `${tabSetStr}  `\n    if (!ruleCnt) {\n      output.add(` {${tabSetStr}}`)\n    } else {\n      output.add(` {${tabRuleStr}`)\n      rules[0].genCSS(context, output)\n      for (i = 1; i < ruleCnt; i++) {\n        output.add(tabRuleStr)\n        rules[i].genCSS(context, output)\n      }\n      output.add(`${tabSetStr}}`)\n    }\n\n    context.tabLevel--\n  }\n}\n\nDirective.prototype.type = 'Directive'\nmodule.exports = Directive\n","const Node = require('./node')\nconst contexts = require('../contexts')\n\nclass DetachedRuleset extends Node {\n  constructor(ruleset, frames) {\n    super()\n    this.ruleset = ruleset\n    this.frames = frames\n  }\n\n  accept(visitor) {\n    this.ruleset = visitor.visit(this.ruleset)\n  }\n\n  eval(context) {\n    const frames = this.frames || context.frames.slice(0)\n    return new DetachedRuleset(this.ruleset, frames)\n  }\n\n  callEval(context) {\n    return this.ruleset.eval(\n      this.frames\n        ? new contexts.Eval(context, this.frames.concat(context.frames))\n        : context\n    )\n  }\n}\n\nDetachedRuleset.prototype.type = 'DetachedRuleset'\nDetachedRuleset.prototype.evalFirst = true\nmodule.exports = DetachedRuleset\n","module.exports = {\n  length: {\n    m: 1,\n    cm: 0.01,\n    mm: 0.001,\n    in: 0.0254,\n    px: 0.0254 / 96,\n    pt: 0.0254 / 72,\n    pc: 0.0254 / 72 * 12,\n  },\n  duration: {\n    s: 1,\n    ms: 0.001,\n  },\n  angle: {\n    rad: 1 / (2 * Math.PI),\n    deg: 1 / 360,\n    grad: 1 / 400,\n    turn: 1,\n  },\n}\n","const Node = require('./node')\nconst unitConversions = require('../data/unit-conversions')\n\nclass Unit extends Node {\n  constructor(numerator, denominator, backupUnit) {\n    super()\n    this.numerator = numerator ? numerator.slice(0).sort() : []\n    this.denominator = denominator ? denominator.slice(0).sort() : []\n    if (backupUnit) {\n      this.backupUnit = backupUnit\n    } else if (numerator && numerator.length) {\n      this.backupUnit = numerator[0]\n    }\n  }\n\n  clone() {\n    return new Unit(\n      this.numerator.slice(0),\n      this.denominator.slice(0),\n      this.backupUnit\n    )\n  }\n\n  genCSS(context, output) {\n    // Dimension checks the unit is singular and throws an error if in strict math mode.\n    const strictUnits = context && context.strictUnits\n    if (this.numerator.length === 1) {\n      output.add(this.numerator[0]) // the ideal situation\n    } else if (!strictUnits && this.backupUnit) {\n      output.add(this.backupUnit)\n    } else if (!strictUnits && this.denominator.length) {\n      output.add(this.denominator[0])\n    }\n  }\n\n  toString() {\n    let i\n    let returnStr = this.numerator.join('*')\n    for (i = 0; i < this.denominator.length; i++) {\n      returnStr += `/${this.denominator[i]}`\n    }\n    return returnStr\n  }\n\n  compare(other) {\n    return this.is(other.toString()) ? 0 : undefined\n  }\n\n  is(unitString) {\n    return this.toString().toUpperCase() === unitString.toUpperCase()\n  }\n\n  isLength() {\n    return Boolean(this.toCSS().match(/px|em|%|in|cm|mm|pc|pt|ex/))\n  }\n\n  isEmpty() {\n    return this.numerator.length === 0 && this.denominator.length === 0\n  }\n\n  isSingular() {\n    return this.numerator.length <= 1 && this.denominator.length === 0\n  }\n\n  map(callback) {\n    let i\n\n    for (i = 0; i < this.numerator.length; i++) {\n      this.numerator[i] = callback(this.numerator[i], false)\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n      this.denominator[i] = callback(this.denominator[i], true)\n    }\n  }\n\n  usedUnits() {\n    let group\n    const result = {}\n    let mapUnit\n    let groupName\n\n    mapUnit = atomicUnit => {\n      /*jshint loopfunc:true */\n      if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n        result[groupName] = atomicUnit\n      }\n\n      return atomicUnit\n    }\n\n    for (groupName in unitConversions) {\n      if (unitConversions.hasOwnProperty(groupName)) {\n        group = unitConversions[groupName]\n\n        this.map(mapUnit)\n      }\n    }\n\n    return result\n  }\n\n  cancel() {\n    const counter = {}\n    let atomicUnit\n    let i\n\n    for (i = 0; i < this.numerator.length; i++) {\n      atomicUnit = this.numerator[i]\n      counter[atomicUnit] = (counter[atomicUnit] || 0) + 1\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n      atomicUnit = this.denominator[i]\n      counter[atomicUnit] = (counter[atomicUnit] || 0) - 1\n    }\n\n    this.numerator = []\n    this.denominator = []\n\n    for (atomicUnit in counter) {\n      if (counter.hasOwnProperty(atomicUnit)) {\n        const count = counter[atomicUnit]\n\n        if (count > 0) {\n          for (i = 0; i < count; i++) {\n            this.numerator.push(atomicUnit)\n          }\n        } else if (count < 0) {\n          for (i = 0; i < -count; i++) {\n            this.denominator.push(atomicUnit)\n          }\n        }\n      }\n    }\n\n    this.numerator.sort()\n    this.denominator.sort()\n  }\n}\n\nUnit.prototype.type = 'Unit'\nmodule.exports = Unit\n","const Node = require('./node')\nconst unitConversions = require('../data/unit-conversions')\nconst Unit = require('./unit')\nconst Color = require('./color')\n\n//\n// A number with a unit\n//\nclass Dimension extends Node {\n  constructor(value, unit) {\n    super()\n    this.value = parseFloat(value)\n    this.unit =\n      unit && unit instanceof Unit ? unit : new Unit(unit ? [unit] : undefined)\n  }\n\n  accept(visitor) {\n    this.unit = visitor.visit(this.unit)\n  }\n\n  eval(context) {\n    return this\n  }\n\n  toColor() {\n    return new Color([this.value, this.value, this.value])\n  }\n\n  genCSS(context, output) {\n    if (context && context.strictUnits && !this.unit.isSingular()) {\n      throw new Error(\n        `Multiple units in dimension. Correct the units or use the unit function. Bad unit: ${this.unit.toString()}`\n      )\n    }\n\n    const value = this.fround(context, this.value)\n    let strValue = String(value)\n\n    if (value !== 0 && value < 0.000001 && value > -0.000001) {\n      // would be output 1e-6 etc.\n      strValue = value.toFixed(20).replace(/0+$/, '')\n    }\n\n    if (context && context.compress) {\n      // Zero values doesn't need a unit\n      if (value === 0 && this.unit.isLength()) {\n        output.add(strValue)\n        return\n      }\n\n      // Float values doesn't need a leading zero\n      if (value > 0 && value < 1) {\n        strValue = strValue.substr(1)\n      }\n    }\n\n    output.add(strValue)\n    this.unit.genCSS(context, output)\n  }\n\n  // In an operation between two Dimensions,\n  // we default to the first Dimension's unit,\n  // so `1px + 2` will yield `3px`.\n  operate(context, op, other) {\n    /*jshint noempty:false */\n    let value = this._operate(context, op, this.value, other.value)\n\n    let unit = this.unit.clone()\n\n    if (op === '+' || op === '-') {\n      if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n        unit = other.unit.clone()\n        if (this.unit.backupUnit) {\n          unit.backupUnit = this.unit.backupUnit\n        }\n      } else if (\n        other.unit.numerator.length === 0 &&\n        unit.denominator.length === 0\n      ) {\n        // do nothing\n      } else {\n        other = other.convertTo(this.unit.usedUnits())\n\n        if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n          throw new Error(\n            `Incompatible units. Change the units or use the unit function. Bad units: '${unit.toString()}' and '${other.unit.toString()}'.`\n          )\n        }\n\n        value = this._operate(context, op, this.value, other.value)\n      }\n    } else if (op === '*') {\n      unit.numerator = unit.numerator.concat(other.unit.numerator).sort()\n      unit.denominator = unit.denominator.concat(other.unit.denominator).sort()\n      unit.cancel()\n    } else if (op === '/') {\n      unit.numerator = unit.numerator.concat(other.unit.denominator).sort()\n      unit.denominator = unit.denominator.concat(other.unit.numerator).sort()\n      unit.cancel()\n    }\n    return new Dimension(value, unit)\n  }\n\n  compare(other) {\n    let a\n    let b\n\n    if (!(other instanceof Dimension)) {\n      return undefined\n    }\n\n    if (this.unit.isEmpty() || other.unit.isEmpty()) {\n      a = this\n      b = other\n    } else {\n      a = this.unify()\n      b = other.unify()\n      if (a.unit.compare(b.unit) !== 0) {\n        return undefined\n      }\n    }\n\n    return Node.numericCompare(a.value, b.value)\n  }\n\n  unify() {\n    return this.convertTo({ length: 'px', duration: 's', angle: 'rad' })\n  }\n\n  convertTo(conversions) {\n    let value = this.value\n    const unit = this.unit.clone()\n    let i\n    let groupName\n    let group\n    let targetUnit\n    let derivedConversions = {}\n    let applyUnit\n\n    if (typeof conversions === 'string') {\n      for (i in unitConversions) {\n        if (unitConversions[i].hasOwnProperty(conversions)) {\n          derivedConversions = {}\n          derivedConversions[i] = conversions\n        }\n      }\n      conversions = derivedConversions\n    }\n    applyUnit = (atomicUnit, denominator) => {\n      /* jshint loopfunc:true */\n      if (group.hasOwnProperty(atomicUnit)) {\n        if (denominator) {\n          value = value / (group[atomicUnit] / group[targetUnit])\n        } else {\n          value = value * (group[atomicUnit] / group[targetUnit])\n        }\n\n        return targetUnit\n      }\n\n      return atomicUnit\n    }\n\n    for (groupName in conversions) {\n      if (conversions.hasOwnProperty(groupName)) {\n        targetUnit = conversions[groupName]\n        group = unitConversions[groupName]\n\n        unit.map(applyUnit)\n      }\n    }\n\n    unit.cancel()\n\n    return new Dimension(value, unit)\n  }\n}\n\nDimension.prototype.type = 'Dimension'\nmodule.exports = Dimension\n","const Node = require('./node')\nconst Color = require('./color')\nconst Dimension = require('./dimension')\nconst Paren = require('./paren')\n\nclass Operation extends Node {\n  constructor(op, operands, isSpaced, isRootVariable = false) {\n    super()\n    this.op = op.trim()\n    this.operands = operands\n    this.isSpaced = isSpaced\n    this.isRootVariable = isRootVariable\n  }\n\n  accept(visitor) {\n    this.operands = visitor.visit(this.operands)\n  }\n\n  eval(context) {\n    let a = this.operands[0].eval(context)\n    let b = this.operands[1].eval(context)\n    const isRootVariable = !!(a.isRootVariable || b.isRootVariable)\n    if (context.isMathOn() && !isRootVariable) {\n      if (a instanceof Dimension && b instanceof Color) {\n        a = a.toColor()\n      }\n      if (b instanceof Dimension && a instanceof Color) {\n        b = b.toColor()\n      }\n      if (!a.operate) {\n        if (context.simplify) {\n          return new Operation(this.op, [a, b], this.isSpaced, isRootVariable)\n        } else {\n          throw {\n            type: 'Operation',\n            message: 'Operation on an invalid type',\n          }\n        }\n      }\n\n      return a.operate(context, this.op, b)\n    } else {\n      const cloneOp = new Operation(\n        this.op,\n        [a, b],\n        this.isSpaced,\n        isRootVariable\n      )\n      if (\n        !context.isInCall() &&\n        ((a.parensInOp && b.parensInOp) || context.isInParens())\n      ) {\n        return new Paren(cloneOp)\n      }\n      return cloneOp\n    }\n  }\n\n  genCSS(context, output) {\n    this.operands[0].genCSS(context, output)\n    if (this.isSpaced) {\n      output.add(' ')\n    }\n    output.add(this.op)\n    if (this.isSpaced) {\n      output.add(' ')\n    }\n    this.operands[1].genCSS(context, output)\n  }\n}\n\nOperation.prototype.type = 'Operation'\n\nmodule.exports = Operation\n","const Node = require('./node')\n\nclass Variable extends Node {\n  constructor(name, index, currentFileInfo) {\n    super()\n    this.name = name\n    this.index = index\n    this.currentFileInfo = currentFileInfo || {}\n  }\n\n  eval(context) {\n    let variable\n    let name = this.name\n\n    if (name.indexOf('@@') === 0) {\n      name = `@${\n        new Variable(name.slice(1), this.index, this.currentFileInfo).eval(\n          context\n        ).value\n      }`\n    }\n\n    if (this.evaluating) {\n      throw {\n        type: 'Name',\n        message: `Recursive variable definition for ${name}`,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n\n    this.evaluating = true\n    const current = this\n    variable = this.find(context.frames, frame => {\n      const v = frame.variable(name)\n      if (v) {\n        if (v.important) {\n          const importantScope =\n            context.importantScope[context.importantScope.length - 1]\n          importantScope.important = v.important\n        }\n        if (\n          frame.root &&\n          context.simplify &&\n          (!context.simplifyFilter || context.simplifyFilter.test(name))\n        ) {\n          // Wrap root\n          current.isRootVariable = true\n\n          //Add genCSS and toCSS\n          current.genCSS = function(context, output) {\n            if (context && context.frames) {\n              //In eval context\n              output.add(this.toCSS(context))\n            } else {\n              output.add(this.name)\n            }\n          }.bind(current)\n\n          current.toCSS = function() {\n            return `@{${this.name.slice(1)}}`\n          }.bind(current)\n\n          return current //don't eval root variables in simple mode\n        }\n        return v.value.eval(context)\n      }\n    })\n    if (variable) {\n      this.evaluating = false\n      return variable\n    } else {\n      throw {\n        type: 'Name',\n        message: `variable ${name} is undefined`,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n  }\n\n  find(obj, fun) {\n    for (let i = 0, r; i < obj.length; i++) {\n      r = fun.call(obj, obj[i])\n      if (r) {\n        return r\n      }\n    }\n    return null\n  }\n}\n\nVariable.prototype.type = 'Variable'\nmodule.exports = Variable\n","const Node = require('./node')\n\nclass Attribute extends Node {\n  constructor(key, op, value) {\n    super()\n    this.key = key\n    this.op = op\n    this.value = value\n  }\n\n  eval(context) {\n    return new Attribute(\n      this.key.eval ? this.key.eval(context) : this.key,\n      this.op,\n      this.value && this.value.eval ? this.value.eval(context) : this.value\n    )\n  }\n\n  genCSS(context, output) {\n    output.add(this.toCSS(context))\n  }\n\n  toCSS(context) {\n    let value = this.key.toCSS ? this.key.toCSS(context) : this.key\n\n    if (this.op) {\n      value += this.op\n      value += this.value.toCSS ? this.value.toCSS(context) : this.value\n    }\n\n    return `[${value}]`\n  }\n}\n\nAttribute.prototype.type = 'Attribute'\nmodule.exports = Attribute\n","const Node = require('./node')\nconst Variable = require('./variable')\n\nclass JsEvalNode extends Node {\n  evaluateJavaScript(expression, context) {\n    let result\n    const that = this\n    const evalContext = {}\n\n    if (context.javascriptEnabled !== undefined && !context.javascriptEnabled) {\n      throw {\n        message: 'You are using JavaScript, which has been disabled.',\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n\n    expression = expression.replace(/@\\{([\\w-]+)\\}/g, (_, name) =>\n      that.jsify(\n        new Variable(`@${name}`, that.index, that.currentFileInfo).eval(context)\n      )\n    )\n\n    try {\n      expression = new Function(`return (${expression})`)\n    } catch (e) {\n      throw {\n        message: `JavaScript evaluation error: ${\n          e.message\n        } from \\`${expression}\\``,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n\n    const variables = context.frames[0].variables()\n    for (const k in variables) {\n      if (variables.hasOwnProperty(k)) {\n        /*jshint loopfunc:true */\n        evalContext[k.slice(1)] = {\n          value: variables[k].value,\n          toJS() {\n            return this.value.eval(context).toCSS()\n          },\n        }\n      }\n    }\n\n    try {\n      result = expression.call(evalContext)\n    } catch (e) {\n      throw {\n        message: `JavaScript evaluation error: '${e.name}: ${e.message.replace(\n          /[\"]/g,\n          \"'\"\n        )}'`,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n    return result\n  }\n\n  jsify(obj) {\n    if (Array.isArray(obj.value) && obj.value.length > 1) {\n      return `[${obj.value.map(v => v.toCSS()).join(', ')}]`\n    } else {\n      return obj.toCSS()\n    }\n  }\n}\n\nmodule.exports = JsEvalNode\n","const Node = require('./node')\nconst JsEvalNode = require('./js-eval-node')\nconst Variable = require('./variable')\n\nclass Quoted extends JsEvalNode {\n  constructor(str, content, escaped, index, currentFileInfo) {\n    super()\n    this.escaped = escaped == null ? true : escaped\n    this.value = content || ''\n    this.quote = str.charAt(0)\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n  }\n\n  genCSS(context, output) {\n    if (!this.escaped) {\n      output.add(this.quote, this.currentFileInfo, this.index)\n    }\n    output.add(this.value)\n    if (!this.escaped) {\n      output.add(this.quote)\n    }\n  }\n\n  containsVariables() {\n    return this.value.match(/(`([^`]+)`)|@\\{([\\w-]+)\\}/)\n  }\n\n  eval(context) {\n    const that = this\n    let value = this.value\n    const javascriptReplacement = (_, exp) =>\n      String(that.evaluateJavaScript(exp, context))\n    const interpolationReplacement = (_, name) => {\n      const v = new Variable(`@${name}`, that.index, that.currentFileInfo).eval(\n        context,\n        true\n      )\n      return v instanceof Quoted ? v.value : v.toCSS()\n    }\n    function iterativeReplace(value, regexp, replacementFnc) {\n      let evaluatedValue = value\n      do {\n        value = evaluatedValue\n        evaluatedValue = value.replace(regexp, replacementFnc)\n      } while (value !== evaluatedValue)\n      return evaluatedValue\n    }\n    value = iterativeReplace(value, /`([^`]+)`/g, javascriptReplacement)\n    value = iterativeReplace(value, /@\\{([\\w-]+)\\}/g, interpolationReplacement)\n    return new Quoted(\n      this.quote + value + this.quote,\n      value,\n      this.escaped,\n      this.index,\n      this.currentFileInfo\n    )\n  }\n\n  compare(other) {\n    // when comparing quoted strings allow the quote to differ\n    if (other.type === 'Quoted' && !this.escaped && !other.escaped) {\n      return Node.numericCompare(this.value, other.value)\n    } else {\n      return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined\n    }\n  }\n}\n\nQuoted.prototype.type = 'Quoted'\nmodule.exports = Quoted\n","const Node = require('./node')\nconst getDebugInfo = require('./debug-info')\n\nclass Comment extends Node {\n  constructor(value, isLineComment, index, currentFileInfo) {\n    super()\n    this.value = value\n    this.isLineComment = isLineComment\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.allowRoot = true\n  }\n\n  genCSS(context, output) {\n    if (this.debugInfo) {\n      output.add(getDebugInfo(context, this), this.currentFileInfo, this.index)\n    }\n    output.add(this.value)\n  }\n\n  isSilent(context) {\n    const isCompressed = context.compress && this.value[2] !== '!'\n    return this.isLineComment || isCompressed\n  }\n}\n\nComment.prototype.type = 'Comment'\nmodule.exports = Comment\n","const Node = require('./node')\nconst Paren = require('./paren')\nconst Comment = require('./comment')\n\nclass Expression extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n    if (!value) {\n      throw new Error('Expression requires an array parameter')\n    }\n  }\n\n  accept(visitor) {\n    this.value = visitor.visitArray(this.value)\n  }\n\n  eval(context) {\n    let returnValue\n    const inParenthesis = this.parens && !this.parensInOp\n    let doubleParen = false\n    if (inParenthesis) {\n      context.inParenthesis()\n    }\n    if (this.value.length > 1) {\n      returnValue = new Expression(this.value.map(e => e.eval(context)))\n    } else if (this.value.length === 1) {\n      if (this.value[0].parens && !this.value[0].parensInOp) {\n        doubleParen = true\n      }\n      returnValue = this.value[0].eval(context)\n    } else {\n      returnValue = this\n    }\n    if (inParenthesis) {\n      context.outOfParenthesis()\n    }\n    if (this.parens && this.parensInOp && !context.isMathOn() && !doubleParen) {\n      returnValue = new Paren(returnValue)\n    }\n    return returnValue\n  }\n\n  genCSS(context, output) {\n    for (let i = 0; i < this.value.length; i++) {\n      this.value[i].genCSS(context, output)\n      if (i + 1 < this.value.length) {\n        output.add(' ')\n      }\n    }\n  }\n\n  throwAwayComments() {\n    this.value = this.value.filter(v => !(v instanceof Comment))\n  }\n}\n\nExpression.prototype.type = 'Expression'\nmodule.exports = Expression\n","const Expression = require('../tree/expression')\n\nclass functionCaller {\n  constructor(name, context, index, currentFileInfo) {\n    this.name = name.toLowerCase()\n    this.index = index\n    this.context = context\n    this.currentFileInfo = currentFileInfo\n\n    this.func = context.frames[0].functionRegistry.get(this.name)\n  }\n\n  isValid() {\n    return Boolean(this.func)\n  }\n\n  call(args) {\n    // This code is terrible and should be replaced as per this issue...\n    // https://github.com/less/less.js/issues/2477\n    if (Array.isArray(args)) {\n      args = args\n        .filter(item => {\n          if (item.type === 'Comment') {\n            return false\n          }\n          return true\n        })\n        .map(item => {\n          if (item.type === 'Expression') {\n            const subNodes = item.value.filter(item => {\n              if (item.type === 'Comment') {\n                return false\n              }\n              return true\n            })\n            if (subNodes.length === 1) {\n              return subNodes[0]\n            } else {\n              return new Expression(subNodes)\n            }\n          }\n          return item\n        })\n    }\n\n    return this.func(...args)\n  }\n}\n\nmodule.exports = functionCaller\n","const Node = require('./node')\nconst FunctionCaller = require('../functions/function-caller')\n\n//\n// A function call node.\n//\nclass Call extends Node {\n  constructor(name, args, index, currentFileInfo) {\n    super()\n    this.name = name\n    this.args = args\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n  }\n\n  accept(visitor) {\n    if (this.args) {\n      this.args = visitor.visitArray(this.args)\n    }\n  }\n\n  //\n  // When evaluating a function call,\n  // we either find the function in the functionRegistry,\n  // in which case we call it, passing the  evaluated arguments,\n  // if this returns null or we cannot find the function, we\n  // simply print it out as it appeared originally [2].\n  //\n  // The reason why we evaluate the arguments, is in the case where\n  // we try to pass a variable to a function, like: `saturate(@color)`.\n  // The function should receive the value, not the variable.\n  //\n  eval(context) {\n    context.inCall()\n    const args = this.args.map(a => a.eval(context))\n    context.outOfCall()\n    let result\n    const funcCaller = new FunctionCaller(\n      this.name,\n      context,\n      this.index,\n      this.currentFileInfo\n    )\n    //Check if any of root vars take place\n    for (const arg of args) {\n      if (arg.isRootVariable)\n        return new Call(this.name, args, this.index, this.currentFileInfo)\n    }\n\n    if (funcCaller.isValid()) {\n      try {\n        result = funcCaller.call(args)\n      } catch (e) {\n        throw {\n          type: e.type || 'Runtime',\n          message: `error evaluating function \\`${this.name}\\`${\n            e.message ? ': ' + e.message : ''\n          }`,\n          index: this.index,\n          filename: this.currentFileInfo.filename,\n        }\n      }\n\n      if (result != null) {\n        result.index = this.index\n        result.currentFileInfo = this.currentFileInfo\n        return result\n      }\n    }\n\n    return new Call(this.name, args, this.index, this.currentFileInfo)\n  }\n\n  genCSS(context, output) {\n    output.add(`${this.name}(`, this.currentFileInfo, this.index)\n\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i].genCSS(context, output)\n      if (i + 1 < this.args.length) {\n        output.add(', ')\n      }\n    }\n\n    output.add(')')\n  }\n}\n\nCall.prototype.type = 'Call'\nmodule.exports = Call\n","const Node = require('./node')\n\nclass URL extends Node {\n  constructor(val, index, currentFileInfo, isEvald) {\n    super()\n    this.value = val\n    this.currentFileInfo = currentFileInfo\n    this.index = index\n    this.isEvald = isEvald\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  genCSS(context, output) {\n    output.add('url(')\n    this.value.genCSS(context, output)\n    output.add(')')\n  }\n\n  eval(context) {\n    const val = this.value.eval(context)\n    let rootpath\n\n    if (!this.isEvald) {\n      // Add the base path if the URL is relative\n      rootpath = this.currentFileInfo && this.currentFileInfo.rootpath\n      if (\n        rootpath &&\n        typeof val.value === 'string' &&\n        context.isPathRelative(val.value)\n      ) {\n        if (!val.quote) {\n          rootpath = rootpath.replace(/[\\(\\)'\"\\s]/g, match => `\\\\${match}`)\n        }\n        val.value = rootpath + val.value\n      }\n\n      val.value = context.normalizePath(val.value)\n\n      // Add url args if enabled\n      if (context.urlArgs) {\n        if (!val.value.match(/^\\s*data:/)) {\n          const delimiter = val.value.indexOf('?') === -1 ? '?' : '&'\n          const urlArgs = delimiter + context.urlArgs\n          if (val.value.indexOf('#') !== -1) {\n            val.value = val.value.replace('#', `${urlArgs}#`)\n          } else {\n            val.value += urlArgs\n          }\n        }\n      }\n    }\n\n    return new URL(val, this.index, this.currentFileInfo, true)\n  }\n}\n\nURL.prototype.type = 'Url'\nmodule.exports = URL\n","const Node = require('./node')\n\nclass Anonymous extends Node {\n  constructor(\n    value,\n    index,\n    currentFileInfo,\n    mapLines,\n    rulesetLike,\n    visibilityInfo\n  ) {\n    super()\n    this.value = value\n    this.index = index\n    this.mapLines = mapLines\n    this.currentFileInfo = currentFileInfo\n    this.rulesetLike = typeof rulesetLike === 'undefined' ? false : rulesetLike\n    this.allowRoot = true\n    this.copyVisibilityInfo(visibilityInfo)\n  }\n\n  eval() {\n    return new Anonymous(\n      this.value,\n      this.index,\n      this.currentFileInfo,\n      this.mapLines,\n      this.rulesetLike,\n      this.visibilityInfo()\n    )\n  }\n\n  compare(other) {\n    return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined\n  }\n\n  isRulesetLike() {\n    return this.rulesetLike\n  }\n\n  genCSS(context, output) {\n    output.add(this.value, this.currentFileInfo, this.index, this.mapLines)\n  }\n}\n\nAnonymous.prototype.type = 'Anonymous'\nmodule.exports = Anonymous\n","const Ruleset = require('./ruleset')\nconst Value = require('./value')\nconst Selector = require('./selector')\nconst Anonymous = require('./anonymous')\nconst Expression = require('./expression')\nconst Directive = require('./directive')\n\nclass Media extends Directive {\n  constructor(value, features, index, currentFileInfo, visibilityInfo) {\n    super()\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n\n    const selectors = new Selector(\n      [],\n      null,\n      null,\n      this.index,\n      this.currentFileInfo\n    ).createEmptySelectors()\n\n    this.features = new Value(features)\n    this.rules = [new Ruleset(selectors, value)]\n    this.rules[0].allowImports = true\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.features) {\n      this.features = visitor.visit(this.features)\n    }\n    if (this.rules) {\n      this.rules = visitor.visitArray(this.rules)\n    }\n  }\n\n  genCSS(context, output) {\n    output.add('@media ', this.currentFileInfo, this.index)\n    this.features.genCSS(context, output)\n    this.outputRuleset(context, output, this.rules)\n  }\n\n  eval(context) {\n    if (!context.mediaBlocks) {\n      context.mediaBlocks = []\n      context.mediaPath = []\n    }\n\n    const media = new Media(\n      null,\n      [],\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n    if (this.debugInfo) {\n      this.rules[0].debugInfo = this.debugInfo\n      media.debugInfo = this.debugInfo\n    }\n    let strictMathBypass = false\n    if (!context.strictMath) {\n      strictMathBypass = true\n      context.strictMath = true\n    }\n    try {\n      media.features = this.features.eval(context)\n    } finally {\n      if (strictMathBypass) {\n        context.strictMath = false\n      }\n    }\n\n    context.mediaPath.push(media)\n    context.mediaBlocks.push(media)\n\n    this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit()\n    context.frames.unshift(this.rules[0])\n    media.rules = [this.rules[0].eval(context)]\n    context.frames.shift()\n\n    context.mediaPath.pop()\n\n    return context.mediaPath.length === 0\n      ? media.evalTop(context)\n      : media.evalNested(context)\n  }\n\n  evalTop(context) {\n    let result = this\n\n    // Render all dependent Media blocks.\n    if (context.mediaBlocks.length > 1) {\n      const selectors = new Selector(\n        [],\n        null,\n        null,\n        this.index,\n        this.currentFileInfo\n      ).createEmptySelectors()\n      result = new Ruleset(selectors, context.mediaBlocks)\n      result.multiMedia = true\n      result.copyVisibilityInfo(this.visibilityInfo())\n    }\n\n    delete context.mediaBlocks\n    delete context.mediaPath\n\n    return result\n  }\n\n  evalNested(context) {\n    let i\n    let value\n    const path = context.mediaPath.concat([this])\n\n    // Extract the media-query conditions separated with `,` (OR).\n    for (i = 0; i < path.length; i++) {\n      value =\n        path[i].features instanceof Value\n          ? path[i].features.value\n          : path[i].features\n      path[i] = Array.isArray(value) ? value : [value]\n    }\n\n    // Trace all permutations to generate the resulting media-query.\n    //\n    // (a, b and c) with nested (d, e) ->\n    //    a and d\n    //    a and e\n    //    b and c and d\n    //    b and c and e\n    this.features = new Value(\n      this.permute(path).map(path => {\n        path = path.map(\n          fragment => (fragment.toCSS ? fragment : new Anonymous(fragment))\n        )\n\n        for (i = path.length - 1; i > 0; i--) {\n          path.splice(i, 0, new Anonymous('and'))\n        }\n\n        return new Expression(path)\n      })\n    )\n\n    // Fake a tree-node that doesn't output anything.\n    return new Ruleset([], [])\n  }\n\n  permute(arr) {\n    if (arr.length === 0) {\n      return []\n    } else if (arr.length === 1) {\n      return arr[0]\n    } else {\n      const result = []\n      const rest = this.permute(arr.slice(1))\n      for (let i = 0; i < rest.length; i++) {\n        for (let j = 0; j < arr[0].length; j++) {\n          result.push([arr[0][j]].concat(rest[i]))\n        }\n      }\n      return result\n    }\n  }\n\n  bubbleSelectors(selectors) {\n    if (!selectors) {\n      return\n    }\n    this.rules = [new Ruleset(selectors.slice(0), [this.rules[0]])]\n  }\n}\n\nMedia.prototype.type = 'Media'\nMedia.prototype.isRulesetLike = true\nmodule.exports = Media\n","const Node = require('./node')\nconst Media = require('./media')\nconst URL = require('./url')\nconst Quoted = require('./quoted')\nconst Ruleset = require('./ruleset')\nconst Anonymous = require('./anonymous')\n\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nclass Import extends Node {\n  constructor(path, features, options, index, currentFileInfo, visibilityInfo) {\n    super()\n    this.options = options\n    this.index = index\n    this.path = path\n    this.features = features\n    this.currentFileInfo = currentFileInfo\n    this.allowRoot = true\n\n    if (this.options.less !== undefined || this.options.inline) {\n      this.css = !this.options.less || this.options.inline\n    } else {\n      const pathValue = this.getPath()\n      if (pathValue && /[#\\.\\&\\?\\/]css([\\?;].*)?$/.test(pathValue)) {\n        this.css = true\n      }\n    }\n    this.copyVisibilityInfo(visibilityInfo)\n  }\n\n  accept(visitor) {\n    if (this.features) {\n      this.features = visitor.visit(this.features)\n    }\n    this.path = visitor.visit(this.path)\n    if (!this.options.plugin && !this.options.inline && this.root) {\n      this.root = visitor.visit(this.root)\n    }\n  }\n\n  genCSS(context, output) {\n    if (this.css && this.path.currentFileInfo.reference === undefined) {\n      output.add('@import ', this.currentFileInfo, this.index)\n      this.path.genCSS(context, output)\n      if (this.features) {\n        output.add(' ')\n        this.features.genCSS(context, output)\n      }\n      output.add(';')\n    }\n  }\n\n  getPath() {\n    return this.path instanceof URL ? this.path.value.value : this.path.value\n  }\n\n  isVariableImport() {\n    let path = this.path\n    if (path instanceof URL) {\n      path = path.value\n    }\n    if (path instanceof Quoted) {\n      return path.containsVariables()\n    }\n\n    return true\n  }\n\n  evalForImport(context) {\n    let path = this.path\n\n    if (path instanceof URL) {\n      path = path.value\n    }\n\n    return new Import(\n      path.eval(context),\n      this.features,\n      this.options,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  evalPath(context) {\n    const path = this.path.eval(context)\n    const rootpath = this.currentFileInfo && this.currentFileInfo.rootpath\n\n    if (!(path instanceof URL)) {\n      if (rootpath) {\n        const pathValue = path.value\n        // Add the base path if the import is relative\n        if (pathValue && context.isPathRelative(pathValue)) {\n          path.value = rootpath + pathValue\n        }\n      }\n      path.value = context.normalizePath(path.value)\n    }\n\n    return path\n  }\n\n  eval(context) {\n    const result = this.doEval(context)\n    if (this.options.reference || this.blocksVisibility()) {\n      if (result.length || result.length === 0) {\n        result.forEach(node => {\n          node.addVisibilityBlock()\n        })\n      } else {\n        result.addVisibilityBlock()\n      }\n    }\n    return result\n  }\n\n  doEval(context) {\n    let ruleset\n    let registry\n    const features = this.features && this.features.eval(context)\n\n    if (this.options.plugin) {\n      registry = context.frames[0] && context.frames[0].functionRegistry\n      if (registry && this.root && this.root.functions) {\n        registry.addMultiple(this.root.functions)\n      }\n      return []\n    }\n\n    if (this.skip) {\n      if (typeof this.skip === 'function') {\n        this.skip = this.skip()\n      }\n      if (this.skip) {\n        return []\n      }\n    }\n    if (this.options.inline) {\n      const contents = new Anonymous(\n        this.root,\n        0,\n        {\n          filename: this.importedFilename,\n          reference:\n            this.path.currentFileInfo && this.path.currentFileInfo.reference,\n        },\n        true,\n        true\n      )\n\n      return this.features\n        ? new Media([contents], this.features.value)\n        : [contents]\n    } else if (this.css) {\n      const newImport = new Import(\n        this.evalPath(context),\n        features,\n        this.options,\n        this.index\n      )\n      if (!newImport.css && this.error) {\n        throw this.error\n      }\n      return newImport\n    } else {\n      ruleset = new Ruleset(null, this.root.rules.slice(0))\n      ruleset.evalImports(context)\n\n      return this.features\n        ? new Media(ruleset.rules, this.features.value)\n        : ruleset.rules\n    }\n  }\n}\n\nImport.prototype.type = 'Import'\nmodule.exports = Import\n","const Selector = require('./selector')\nconst Element = require('./element')\nconst Ruleset = require('./ruleset')\nconst Rule = require('./rule')\nconst Expression = require('./expression')\nconst contexts = require('../contexts')\n\nclass Definition extends Ruleset {\n  constructor(\n    name,\n    params,\n    rules,\n    condition,\n    variadic,\n    frames,\n    visibilityInfo\n  ) {\n    super()\n    this.name = name\n    this.selectors = [\n      new Selector([new Element(null, name, this.index, this.currentFileInfo)]),\n    ]\n    this.params = params\n    this.condition = condition\n    this.variadic = variadic\n    this.arity = params.length\n    this.rules = rules\n    this._lookups = {}\n    const optionalParameters = []\n    this.required = params.reduce((count, p) => {\n      if (!p.name || (p.name && !p.value)) {\n        return count + 1\n      } else {\n        optionalParameters.push(p.name)\n        return count\n      }\n    }, 0)\n    this.optionalParameters = optionalParameters\n    this.frames = frames\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.params && this.params.length) {\n      this.params = visitor.visitArray(this.params)\n    }\n    this.rules = visitor.visitArray(this.rules)\n    if (this.condition) {\n      this.condition = visitor.visit(this.condition)\n    }\n  }\n\n  evalParams(context, mixinEnv, args, evaldArguments) {\n    /*jshint boss:true */\n    const frame = new Ruleset(null, null)\n\n    let varargs\n    let arg\n    const params = this.params.slice(0)\n    let i\n    let j\n    let val\n    let name\n    let isNamedFound\n    let argIndex\n    let argsLength = 0\n\n    if (\n      mixinEnv.frames &&\n      mixinEnv.frames[0] &&\n      mixinEnv.frames[0].functionRegistry\n    ) {\n      frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit()\n    }\n    mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames))\n\n    if (args) {\n      args = args.slice(0)\n      argsLength = args.length\n\n      for (i = 0; i < argsLength; i++) {\n        arg = args[i]\n        if ((name = arg && arg.name)) {\n          isNamedFound = false\n          for (j = 0; j < params.length; j++) {\n            if (!evaldArguments[j] && name === params[j].name) {\n              evaldArguments[j] = arg.value.eval(context)\n              frame.prependRule(new Rule(name, arg.value.eval(context)))\n              isNamedFound = true\n              break\n            }\n          }\n          if (isNamedFound) {\n            args.splice(i, 1)\n            i--\n            continue\n          } else {\n            throw {\n              type: 'Runtime',\n              message: `Named argument for ${this.name} ${\n                args[i].name\n              } not found`,\n            }\n          }\n        }\n      }\n    }\n    argIndex = 0\n    for (i = 0; i < params.length; i++) {\n      if (evaldArguments[i]) {\n        continue\n      }\n\n      arg = args && args[argIndex]\n\n      if ((name = params[i].name)) {\n        if (params[i].variadic) {\n          varargs = []\n          for (j = argIndex; j < argsLength; j++) {\n            varargs.push(args[j].value.eval(context))\n          }\n          frame.prependRule(\n            new Rule(name, new Expression(varargs).eval(context))\n          )\n        } else {\n          val = arg && arg.value\n          if (val) {\n            val = val.eval(context)\n          } else if (params[i].value) {\n            val = params[i].value.eval(mixinEnv)\n            frame.resetCache()\n          } else {\n            throw {\n              type: 'Runtime',\n              message: `wrong number of arguments for ${\n                this.name\n              } (${argsLength} for ${this.arity})`,\n            }\n          }\n\n          frame.prependRule(new Rule(name, val))\n          evaldArguments[i] = val\n        }\n      }\n\n      if (params[i].variadic && args) {\n        for (j = argIndex; j < argsLength; j++) {\n          evaldArguments[j] = args[j].value.eval(context)\n        }\n      }\n      argIndex++\n    }\n\n    return frame\n  }\n\n  makeImportant() {\n    const rules = !this.rules\n      ? this.rules\n      : this.rules.map(r => {\n          if (r.makeImportant) {\n            return r.makeImportant(true)\n          } else {\n            return r\n          }\n        })\n    const result = new Definition(\n      this.name,\n      this.params,\n      rules,\n      this.condition,\n      this.variadic,\n      this.frames\n    )\n    return result\n  }\n\n  eval(context) {\n    return new Definition(\n      this.name,\n      this.params,\n      this.rules,\n      this.condition,\n      this.variadic,\n      this.frames || context.frames.slice(0)\n    )\n  }\n\n  evalCall(context, args, important) {\n    const _arguments = []\n    const mixinFrames = this.frames\n      ? this.frames.concat(context.frames)\n      : context.frames\n    const frame = this.evalParams(\n      context,\n      new contexts.Eval(context, mixinFrames),\n      args,\n      _arguments\n    )\n    let rules\n    let ruleset\n\n    frame.prependRule(\n      new Rule('@arguments', new Expression(_arguments).eval(context))\n    )\n\n    rules = this.rules.slice(0)\n\n    ruleset = new Ruleset(null, rules)\n    ruleset.originalRuleset = this\n    ruleset = ruleset.eval(\n      new contexts.Eval(context, [this, frame].concat(mixinFrames))\n    )\n    if (important) {\n      ruleset = ruleset.makeImportant()\n    }\n    return ruleset\n  }\n\n  matchCondition(args, context) {\n    if (\n      this.condition &&\n      !this.condition.eval(\n        new contexts.Eval(\n          context,\n          [\n            this.evalParams(\n              context /* the parameter variables*/,\n              new contexts.Eval(\n                context,\n                this.frames\n                  ? this.frames.concat(context.frames)\n                  : context.frames\n              ),\n              args,\n              []\n            ),\n          ]\n            .concat(this.frames || []) // the parent namespace/mixin frames\n            .concat(context.frames)\n        )\n      )\n    ) {\n      // the current environment frames\n      return false\n    }\n    return true\n  }\n\n  matchArgs(args, context) {\n    const allArgsCnt = (args && args.length) || 0\n    let len\n    const optionalParameters = this.optionalParameters\n    const requiredArgsCnt = !args\n      ? 0\n      : args.reduce((count, p) => {\n          if (optionalParameters.indexOf(p.name) < 0) {\n            return count + 1\n          } else {\n            return count\n          }\n        }, 0)\n\n    if (!this.variadic) {\n      if (requiredArgsCnt < this.required) {\n        return false\n      }\n      if (allArgsCnt > this.params.length) {\n        return false\n      }\n    } else {\n      if (requiredArgsCnt < this.required - 1) {\n        return false\n      }\n    }\n\n    // check patterns\n    len = Math.min(requiredArgsCnt, this.arity)\n\n    for (let i = 0; i < len; i++) {\n      if (!this.params[i].name && !this.params[i].variadic) {\n        if (\n          args[i].value.eval(context).toCSS() !=\n          this.params[i].value.eval(context).toCSS()\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nDefinition.prototype.type = 'MixinDefinition'\nDefinition.prototype.evalFirst = true\nmodule.exports = Definition\n","const Node = require('./node')\nconst Selector = require('./selector')\nconst MixinDefinition = require('./mixin-definition')\nconst defaultFunc = require('../functions/default')\n\nclass MixinCall extends Node {\n  constructor(elements, args, index, currentFileInfo, important) {\n    super()\n    this.selector = new Selector(elements)\n    this.arguments = args || []\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.important = important\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.selector) {\n      this.selector = visitor.visit(this.selector)\n    }\n    if (this.arguments.length) {\n      this.arguments = visitor.visitArray(this.arguments)\n    }\n  }\n\n  eval(context) {\n    let mixins\n    let mixin\n    let mixinPath\n    const args = []\n    let arg\n    let argValue\n    const rules = []\n    let match = false\n    let i\n    let m\n    let f\n    let isRecursive\n    let isOneFound\n    const candidates = []\n    let candidate\n    const conditionResult = []\n    let defaultResult\n    const defFalseEitherCase = -1\n    const defNone = 0\n    const defTrue = 1\n    const defFalse = 2\n    let count\n    let originalRuleset\n    let noArgumentsFilter\n\n    function calcDefGroup(mixin, mixinPath) {\n      let f\n      let p\n      let namespace\n\n      for (f = 0; f < 2; f++) {\n        conditionResult[f] = true\n        defaultFunc.value(f)\n        for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n          namespace = mixinPath[p]\n          if (namespace.matchCondition) {\n            conditionResult[f] =\n              conditionResult[f] && namespace.matchCondition(null, context)\n          }\n        }\n        if (mixin.matchCondition) {\n          conditionResult[f] =\n            conditionResult[f] && mixin.matchCondition(args, context)\n        }\n      }\n      if (conditionResult[0] || conditionResult[1]) {\n        if (conditionResult[0] != conditionResult[1]) {\n          return conditionResult[1] ? defTrue : defFalse\n        }\n\n        return defNone\n      }\n      return defFalseEitherCase\n    }\n\n    for (i = 0; i < this.arguments.length; i++) {\n      arg = this.arguments[i]\n      argValue = arg.value.eval(context)\n      if (arg.expand && Array.isArray(argValue.value)) {\n        argValue = argValue.value\n        for (m = 0; m < argValue.length; m++) {\n          args.push({ value: argValue[m] })\n        }\n      } else {\n        args.push({ name: arg.name, value: argValue })\n      }\n    }\n\n    noArgumentsFilter = rule => rule.matchArgs(null, context)\n\n    for (i = 0; i < context.frames.length; i++) {\n      if (\n        (mixins = context.frames[i].find(\n          this.selector,\n          null,\n          noArgumentsFilter\n        )).length > 0\n      ) {\n        isOneFound = true\n\n        // To make `default()` function independent of definition order we have two \"subpasses\" here.\n        // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n        // and build candidate list with corresponding flags. Then, when we know all possible matches,\n        // we make a final decision.\n\n        for (m = 0; m < mixins.length; m++) {\n          mixin = mixins[m].rule\n          mixinPath = mixins[m].path\n          isRecursive = false\n          for (f = 0; f < context.frames.length; f++) {\n            if (\n              !(mixin instanceof MixinDefinition) &&\n              mixin === (context.frames[f].originalRuleset || context.frames[f])\n            ) {\n              isRecursive = true\n              break\n            }\n          }\n          if (isRecursive) {\n            continue\n          }\n\n          if (mixin.matchArgs(args, context)) {\n            candidate = { mixin, group: calcDefGroup(mixin, mixinPath) }\n\n            if (candidate.group !== defFalseEitherCase) {\n              candidates.push(candidate)\n            }\n\n            match = true\n          }\n        }\n\n        defaultFunc.reset()\n\n        count = [0, 0, 0]\n        for (m = 0; m < candidates.length; m++) {\n          count[candidates[m].group]++\n        }\n\n        if (count[defNone] > 0) {\n          defaultResult = defFalse\n        } else {\n          defaultResult = defTrue\n          if (count[defTrue] + count[defFalse] > 1) {\n            throw {\n              type: 'Runtime',\n              message: `Ambiguous use of \\`default()\\` found when matching for \\`${this.format(\n                args\n              )}\\``,\n              index: this.index,\n              filename: this.currentFileInfo.filename,\n            }\n          }\n        }\n\n        for (m = 0; m < candidates.length; m++) {\n          candidate = candidates[m].group\n          if (candidate === defNone || candidate === defaultResult) {\n            try {\n              mixin = candidates[m].mixin\n              if (!(mixin instanceof MixinDefinition)) {\n                originalRuleset = mixin.originalRuleset || mixin\n                mixin = new MixinDefinition(\n                  '',\n                  [],\n                  mixin.rules,\n                  null,\n                  false,\n                  null,\n                  originalRuleset.visibilityInfo()\n                )\n                mixin.originalRuleset = originalRuleset\n              }\n              const newRules = mixin.evalCall(context, args, this.important)\n                .rules\n              this._setVisibilityToReplacement(newRules)\n              Array.prototype.push.apply(rules, newRules)\n            } catch (e) {\n              throw {\n                message: e.message,\n                index: this.index,\n                filename: this.currentFileInfo.filename,\n                stack: e.stack,\n              }\n            }\n          }\n        }\n\n        if (match) {\n          return rules\n        }\n      }\n    }\n    if (isOneFound) {\n      throw {\n        type: 'Runtime',\n        message: `No matching definition was found for \\`${this.format(\n          args\n        )}\\``,\n        index: this.index,\n        filename: this.currentFileInfo.filename,\n      }\n    } else {\n      throw {\n        type: 'Name',\n        message: `${this.selector.toCSS().trim()} is undefined`,\n        index: this.index,\n        filename: this.currentFileInfo.filename,\n      }\n    }\n  }\n\n  _setVisibilityToReplacement(replacement) {\n    let i\n    let rule\n    if (this.blocksVisibility()) {\n      for (i = 0; i < replacement.length; i++) {\n        rule = replacement[i]\n        rule.addVisibilityBlock()\n      }\n    }\n  }\n\n  format(args) {\n    return `${this.selector.toCSS().trim()}(${\n      args\n        ? args\n            .map(a => {\n              let argValue = ''\n              if (a.name) {\n                argValue += a.name + ':'\n              }\n              if (a.value.toCSS) {\n                argValue += a.value.toCSS()\n              } else {\n                argValue += '???'\n              }\n              return argValue\n            })\n            .join(', ')\n        : ''\n    })`\n  }\n}\n\nMixinCall.prototype.type = 'MixinCall'\nmodule.exports = MixinCall\n","const JsEvalNode = require('./js-eval-node')\nconst Dimension = require('./dimension')\nconst Quoted = require('./quoted')\nconst Anonymous = require('./anonymous')\n\nclass JavaScript extends JsEvalNode {\n  constructor(string, escaped, index, currentFileInfo) {\n    super()\n    this.escaped = escaped\n    this.expression = string\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n  }\n\n  eval(context) {\n    const result = this.evaluateJavaScript(this.expression, context)\n\n    if (typeof result === 'number') {\n      return new Dimension(result)\n    } else if (typeof result === 'string') {\n      return new Quoted(`\"${result}\"`, result, this.escaped, this.index)\n    } else if (Array.isArray(result)) {\n      return new Anonymous(result.join(', '))\n    } else {\n      return new Anonymous(result)\n    }\n  }\n}\n\nJavaScript.prototype.type = 'JavaScript'\n\nmodule.exports = JavaScript\n","const Node = require('./node')\n\nclass Assignment extends Node {\n  constructor(key, val) {\n    super()\n    this.key = key\n    this.value = val\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  eval(context) {\n    if (this.value.eval) {\n      return new Assignment(this.key, this.value.eval(context))\n    }\n    return this\n  }\n\n  genCSS(context, output) {\n    output.add(`${this.key}=`)\n    if (this.value.genCSS) {\n      this.value.genCSS(context, output)\n    } else {\n      output.add(this.value)\n    }\n  }\n}\n\nAssignment.prototype.type = 'Assignment'\nmodule.exports = Assignment\n","const Node = require('./node')\n\nclass Condition extends Node {\n  constructor(op, l, r, i, negate) {\n    super()\n    this.op = op.trim()\n    this.lvalue = l\n    this.rvalue = r\n    this.index = i\n    this.negate = negate\n  }\n\n  accept(visitor) {\n    this.lvalue = visitor.visit(this.lvalue)\n    this.rvalue = visitor.visit(this.rvalue)\n  }\n\n  eval(context) {\n    const result = ((op, a, b) => {\n      switch (op) {\n        case 'and':\n          return a && b\n        case 'or':\n          return a || b\n        default:\n          switch (Node.compare(a, b)) {\n            case -1:\n              return op === '<' || op === '=<' || op === '<='\n            case 0:\n              return op === '=' || op === '>=' || op === '=<' || op === '<='\n            case 1:\n              return op === '>' || op === '>='\n            default:\n              return false\n          }\n      }\n    })(this.op, this.lvalue.eval(context), this.rvalue.eval(context))\n\n    return this.negate ? !result : result\n  }\n}\n\nCondition.prototype.type = 'Condition'\nmodule.exports = Condition\n","const Node = require('./node')\n\nclass UnicodeDescriptor extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n  }\n}\n\nUnicodeDescriptor.prototype.type = 'UnicodeDescriptor'\n\nmodule.exports = UnicodeDescriptor\n","const Node = require('./node')\nconst Operation = require('./operation')\nconst Dimension = require('./dimension')\n\nclass Negative extends Node {\n  constructor(node) {\n    super()\n    this.value = node\n  }\n\n  genCSS(context, output) {\n    output.add('-')\n    this.value.genCSS(context, output)\n  }\n\n  eval(context) {\n    if (context.isMathOn()) {\n      return new Operation('*', [new Dimension(-1), this.value]).eval(context)\n    }\n    return new Negative(this.value.eval(context))\n  }\n}\n\nNegative.prototype.type = 'Negative'\nmodule.exports = Negative\n","const Node = require('./node')\nconst Selector = require('./selector')\n\nclass Extend extends Node {\n  constructor(selector, option, index, currentFileInfo, visibilityInfo) {\n    super()\n    this.selector = selector\n    this.option = option\n    this.index = index\n    this.object_id = Extend.next_id++\n    this.parent_ids = [this.object_id]\n    this.currentFileInfo = currentFileInfo || {}\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n\n    switch (option) {\n      case 'all':\n        this.allowBefore = true\n        this.allowAfter = true\n        break\n      default:\n        this.allowBefore = false\n        this.allowAfter = false\n        break\n    }\n  }\n\n  accept(visitor) {\n    this.selector = visitor.visit(this.selector)\n  }\n\n  eval(context) {\n    return new Extend(\n      this.selector.eval(context),\n      this.option,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  clone(context) {\n    return new Extend(\n      this.selector,\n      this.option,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  //it concatenates (joins) all selectors in selector array\n  findSelfSelectors(selectors) {\n    let selfElements = []\n    let i\n    let selectorElements\n\n    for (i = 0; i < selectors.length; i++) {\n      selectorElements = selectors[i].elements\n      // duplicate the logic in genCSS function inside the selector node.\n      // future TODO - move both logics into the selector joiner visitor\n      if (\n        i > 0 &&\n        selectorElements.length &&\n        selectorElements[0].combinator.value === ''\n      ) {\n        selectorElements[0].combinator.value = ' '\n      }\n      selfElements = selfElements.concat(selectors[i].elements)\n    }\n\n    this.selfSelectors = [new Selector(selfElements)]\n    this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo())\n  }\n}\n\nExtend.next_id = 0\n\nExtend.prototype.type = 'Extend'\nmodule.exports = Extend\n","const Node = require('./node')\nconst Variable = require('./variable')\n\nclass RulesetCall extends Node {\n  constructor(variable) {\n    super()\n    this.variable = variable\n    this.allowRoot = true\n  }\n\n  eval(context) {\n    const detachedRuleset = new Variable(this.variable).eval(context)\n    return detachedRuleset.callEval(context)\n  }\n}\n\nRulesetCall.prototype.type = 'RulesetCall'\nmodule.exports = RulesetCall\n","const tree = {}\n\ntree.Node = require('./node')\ntree.Alpha = require('./alpha')\ntree.Color = require('./color')\ntree.Directive = require('./directive')\ntree.DetachedRuleset = require('./detached-ruleset')\ntree.Operation = require('./operation')\ntree.Dimension = require('./dimension')\ntree.Unit = require('./unit')\ntree.Keyword = require('./keyword')\ntree.Variable = require('./variable')\ntree.Ruleset = require('./ruleset')\ntree.Element = require('./element')\ntree.Attribute = require('./attribute')\ntree.Combinator = require('./combinator')\ntree.Selector = require('./selector')\ntree.Quoted = require('./quoted')\ntree.Expression = require('./expression')\ntree.Rule = require('./rule')\ntree.Call = require('./call')\ntree.URL = require('./url')\ntree.Import = require('./import')\ntree.mixin = {\n  Call: require('./mixin-call'),\n  Definition: require('./mixin-definition'),\n}\ntree.Comment = require('./comment')\ntree.Anonymous = require('./anonymous')\ntree.Value = require('./value')\ntree.JavaScript = require('./javascript')\ntree.Assignment = require('./assignment')\ntree.Condition = require('./condition')\ntree.Paren = require('./paren')\ntree.Media = require('./media')\ntree.UnicodeDescriptor = require('./unicode-descriptor')\ntree.Negative = require('./negative')\ntree.Extend = require('./extend')\ntree.RulesetCall = require('./ruleset-call')\n\nmodule.exports = tree\n","const tree = require('../tree')\n\nconst _visitArgs = { visitDeeper: true }\nlet _hasIndexed = false\n\nfunction _noop(node) {\n  return node\n}\n\nfunction indexNodeTypes(parent, ticker) {\n  // add .typeIndex to tree node types for lookup table\n  let key\n\n  let child\n  for (key in parent) {\n    if (parent.hasOwnProperty(key)) {\n      child = parent[key]\n      switch (typeof child) {\n        case 'function':\n          // ignore bound functions directly on tree which do not have a prototype\n          // or aren't nodes\n          if (child.prototype && child.prototype.type) {\n            child.prototype.typeIndex = ticker++\n          }\n          break\n        case 'object':\n          ticker = indexNodeTypes(child, ticker)\n          break\n      }\n    }\n  }\n  return ticker\n}\n\nclass Visitor {\n  constructor(implementation) {\n    this._implementation = implementation\n    this._visitFnCache = []\n\n    if (!_hasIndexed) {\n      indexNodeTypes(tree, 1)\n      _hasIndexed = true\n    }\n  }\n\n  visit(node) {\n    if (!node) {\n      return node\n    }\n\n    const nodeTypeIndex = node.typeIndex\n    if (!nodeTypeIndex) {\n      return node\n    }\n\n    const visitFnCache = this._visitFnCache\n    const impl = this._implementation\n    const aryIndx = nodeTypeIndex << 1\n    const outAryIndex = aryIndx | 1\n    let func = visitFnCache[aryIndx]\n    let funcOut = visitFnCache[outAryIndex]\n    const visitArgs = _visitArgs\n    let fnName\n\n    visitArgs.visitDeeper = true\n\n    if (!func) {\n      fnName = `visit${node.type}`\n      func = impl[fnName] || _noop\n      funcOut = impl[`${fnName}Out`] || _noop\n      visitFnCache[aryIndx] = func\n      visitFnCache[outAryIndex] = funcOut\n    }\n\n    if (func !== _noop) {\n      const newNode = func.call(impl, node, visitArgs)\n      if (impl.isReplacing) {\n        node = newNode\n      }\n    }\n\n    if (visitArgs.visitDeeper && node && node.accept) {\n      node.accept(this)\n    }\n\n    if (funcOut != _noop) {\n      funcOut.call(impl, node)\n    }\n\n    return node\n  }\n\n  visitArray(nodes, nonReplacing) {\n    if (!nodes) {\n      return nodes\n    }\n\n    const cnt = nodes.length\n    let i\n\n    // Non-replacing\n    if (nonReplacing || !this._implementation.isReplacing) {\n      for (i = 0; i < cnt; i++) {\n        this.visit(nodes[i])\n      }\n      return nodes\n    }\n\n    // Replacing\n    const out = []\n    for (i = 0; i < cnt; i++) {\n      const evald = this.visit(nodes[i])\n      if (evald === undefined) {\n        continue\n      }\n      if (!evald.splice) {\n        out.push(evald)\n      } else if (evald.length) {\n        this.flatten(evald, out)\n      }\n    }\n    return out\n  }\n\n  flatten(arr, out) {\n    if (!out) {\n      out = []\n    }\n\n    let cnt\n    let i\n    let item\n    let nestedCnt\n    let j\n    let nestedItem\n\n    for (i = 0, cnt = arr.length; i < cnt; i++) {\n      item = arr[i]\n      if (item === undefined) {\n        continue\n      }\n      if (!item.splice) {\n        out.push(item)\n        continue\n      }\n\n      for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n        nestedItem = item[j]\n        if (nestedItem === undefined) {\n          continue\n        }\n        if (!nestedItem.splice) {\n          out.push(nestedItem)\n        } else if (nestedItem.length) {\n          this.flatten(nestedItem, out)\n        }\n      }\n    }\n\n    return out\n  }\n}\n\nmodule.exports = Visitor\n","class ImportSequencer {\n  constructor(onSequencerEmpty) {\n    this.imports = []\n    this.variableImports = []\n    this._onSequencerEmpty = onSequencerEmpty\n    this._currentDepth = 0\n  }\n\n  addImport(callback) {\n    const importSequencer = this\n\n    const importItem = {\n      callback,\n      args: null,\n      isReady: false,\n    }\n\n    this.imports.push(importItem)\n    return function(...args) {\n      importItem.args = Array.prototype.slice.call(args, 0)\n      importItem.isReady = true\n      importSequencer.tryRun()\n    }\n  }\n\n  addVariableImport(callback) {\n    this.variableImports.push(callback)\n  }\n\n  tryRun() {\n    this._currentDepth++\n    try {\n      while (true) {\n        while (this.imports.length > 0) {\n          const importItem = this.imports[0]\n          if (!importItem.isReady) {\n            return\n          }\n          this.imports = this.imports.slice(1)\n          importItem.callback.apply(null, importItem.args)\n        }\n        if (this.variableImports.length === 0) {\n          break\n        }\n        const variableImport = this.variableImports[0]\n        this.variableImports = this.variableImports.slice(1)\n        variableImport()\n      }\n    } finally {\n      this._currentDepth--\n    }\n    if (this._currentDepth === 0 && this._onSequencerEmpty) {\n      this._onSequencerEmpty()\n    }\n  }\n}\n\nmodule.exports = ImportSequencer\n","const contexts = require('../contexts')\nconst Visitor = require('./visitor')\nconst ImportSequencer = require('./import-sequencer')\n\nconst ImportVisitor = function(importer, finish) {\n  this._visitor = new Visitor(this)\n  this._importer = importer\n  this._finish = finish\n  this.context = new contexts.Eval()\n  this.importCount = 0\n  this.onceFileDetectionMap = {}\n  this.recursionDetector = {}\n  this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this))\n}\n\nImportVisitor.prototype = {\n  isReplacing: false,\n  run(root) {\n    try {\n      // process the contents\n      this._visitor.visit(root)\n    } catch (e) {\n      this.error = e\n    }\n\n    this.isFinished = true\n    this._sequencer.tryRun()\n  },\n  _onSequencerEmpty() {\n    if (!this.isFinished) {\n      return\n    }\n    this._finish(this.error)\n  },\n  visitImport(importNode, visitArgs) {\n    const inlineCSS = importNode.options.inline\n\n    if (!importNode.css || inlineCSS) {\n      const context = new contexts.Eval(\n        this.context,\n        this.context.frames.slice(0)\n      )\n      const importParent = context.frames[0]\n\n      this.importCount++\n      if (importNode.isVariableImport()) {\n        this._sequencer.addVariableImport(\n          this.processImportNode.bind(this, importNode, context, importParent)\n        )\n      } else {\n        this.processImportNode(importNode, context, importParent)\n      }\n    }\n    visitArgs.visitDeeper = false\n  },\n  processImportNode(importNode, context, importParent) {\n    let evaldImportNode\n    const inlineCSS = importNode.options.inline\n\n    try {\n      evaldImportNode = importNode.evalForImport(context)\n    } catch (e) {\n      if (!e.filename) {\n        e.index = importNode.index\n        e.filename = importNode.currentFileInfo.filename\n      }\n      // attempt to eval properly and treat as css\n      importNode.css = true\n      // if that fails, this error will be thrown\n      importNode.error = e\n    }\n\n    if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n      if (evaldImportNode.options.multiple) {\n        context.importMultiple = true\n      }\n\n      // try appending if we haven't determined if it is css or not\n      const tryAppendLessExtension = evaldImportNode.css === undefined\n\n      for (let i = 0; i < importParent.rules.length; i++) {\n        if (importParent.rules[i] === importNode) {\n          importParent.rules[i] = evaldImportNode\n          break\n        }\n      }\n\n      const onImported = this.onImported.bind(this, evaldImportNode, context)\n      const sequencedOnImported = this._sequencer.addImport(onImported)\n\n      this._importer.push(\n        evaldImportNode.getPath(),\n        tryAppendLessExtension,\n        evaldImportNode.currentFileInfo,\n        evaldImportNode.options,\n        sequencedOnImported\n      )\n    } else {\n      this.importCount--\n      if (this.isFinished) {\n        this._sequencer.tryRun()\n      }\n    }\n  },\n  onImported(importNode, context, e, root, importedAtRoot, fullPath) {\n    if (e) {\n      if (!e.filename) {\n        e.index = importNode.index\n        e.filename = importNode.currentFileInfo.filename\n      }\n      this.error = e\n    }\n\n    const importVisitor = this\n    const inlineCSS = importNode.options.inline\n    const isPlugin = importNode.options.plugin\n    const isOptional = importNode.options.optional\n    const duplicateImport =\n      importedAtRoot || fullPath in importVisitor.recursionDetector\n\n    if (!context.importMultiple) {\n      if (duplicateImport) {\n        importNode.skip = true\n      } else {\n        importNode.skip = () => {\n          if (fullPath in importVisitor.onceFileDetectionMap) {\n            return true\n          }\n          importVisitor.onceFileDetectionMap[fullPath] = true\n          return false\n        }\n      }\n    }\n\n    if (!fullPath && isOptional) {\n      importNode.skip = true\n    }\n\n    if (root) {\n      importNode.root = root\n      importNode.importedFilename = fullPath\n\n      if (\n        !inlineCSS &&\n        !isPlugin &&\n        (context.importMultiple || !duplicateImport)\n      ) {\n        importVisitor.recursionDetector[fullPath] = true\n\n        const oldContext = this.context\n        this.context = context\n        try {\n          this._visitor.visit(root)\n        } catch (e) {\n          this.error = e\n        }\n        this.context = oldContext\n      }\n    }\n\n    importVisitor.importCount--\n\n    if (importVisitor.isFinished) {\n      importVisitor._sequencer.tryRun()\n    }\n  },\n  visitRule(ruleNode, visitArgs) {\n    if (ruleNode.value.type === 'DetachedRuleset') {\n      this.context.frames.unshift(ruleNode)\n    } else {\n      visitArgs.visitDeeper = false\n    }\n  },\n  visitRuleOut(ruleNode) {\n    if (ruleNode.value.type === 'DetachedRuleset') {\n      this.context.frames.shift()\n    }\n  },\n  visitDirective(directiveNode, visitArgs) {\n    this.context.frames.unshift(directiveNode)\n  },\n  visitDirectiveOut(directiveNode) {\n    this.context.frames.shift()\n  },\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    this.context.frames.unshift(mixinDefinitionNode)\n  },\n  visitMixinDefinitionOut(mixinDefinitionNode) {\n    this.context.frames.shift()\n  },\n  visitRuleset(rulesetNode, visitArgs) {\n    this.context.frames.unshift(rulesetNode)\n  },\n  visitRulesetOut(rulesetNode) {\n    this.context.frames.shift()\n  },\n  visitMedia(mediaNode, visitArgs) {\n    this.context.frames.unshift(mediaNode.rules[0])\n  },\n  visitMediaOut(mediaNode) {\n    this.context.frames.shift()\n  },\n}\nmodule.exports = ImportVisitor\n","class SetTreeVisibilityVisitor {\n  constructor(visible) {\n    this.visible = visible\n  }\n\n  run(root) {\n    this.visit(root)\n  }\n\n  visitArray(nodes) {\n    if (!nodes) {\n      return nodes\n    }\n\n    const cnt = nodes.length\n    let i\n    for (i = 0; i < cnt; i++) {\n      this.visit(nodes[i])\n    }\n    return nodes\n  }\n\n  visit(node) {\n    if (!node) {\n      return node\n    }\n    if (node.constructor === Array) {\n      return this.visitArray(node)\n    }\n\n    if (!node.blocksVisibility || node.blocksVisibility()) {\n      return node\n    }\n    if (this.visible) {\n      node.ensureVisibility()\n    } else {\n      node.ensureInvisibility()\n    }\n\n    node.accept(this)\n    return node\n  }\n}\n\nmodule.exports = SetTreeVisibilityVisitor\n","const tree = require('../tree')\nconst Visitor = require('./visitor')\nconst logger = require('../logger')\n\n/*jshint loopfunc:true */\n\nclass ExtendFinderVisitor {\n  constructor() {\n    this._visitor = new Visitor(this)\n    this.contexts = []\n    this.allExtendsStack = [[]]\n  }\n\n  run(root) {\n    root = this._visitor.visit(root)\n    root.allExtends = this.allExtendsStack[0]\n    return root\n  }\n\n  visitRule(ruleNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitRuleset(rulesetNode, visitArgs) {\n    if (rulesetNode.root) {\n      return\n    }\n\n    let i\n    let j\n    let extend\n    const allSelectorsExtendList = []\n    let extendList\n\n    // get &:extend(.a); rules which apply to all selectors in this ruleset\n    const rules = rulesetNode.rules\n\n    const ruleCnt = rules ? rules.length : 0\n    for (i = 0; i < ruleCnt; i++) {\n      if (rulesetNode.rules[i] instanceof tree.Extend) {\n        allSelectorsExtendList.push(rules[i])\n        rulesetNode.extendOnEveryPath = true\n      }\n    }\n\n    // now find every selector and apply the extends that apply to all extends\n    // and the ones which apply to an individual extend\n    const paths = rulesetNode.paths\n    for (i = 0; i < paths.length; i++) {\n      const selectorPath = paths[i]\n      const selector = selectorPath[selectorPath.length - 1]\n      const selExtendList = selector.extendList\n\n      extendList = selExtendList\n        ? selExtendList.slice(0).concat(allSelectorsExtendList)\n        : allSelectorsExtendList\n\n      if (extendList) {\n        extendList = extendList.map(allSelectorsExtend =>\n          allSelectorsExtend.clone()\n        )\n      }\n\n      for (j = 0; j < extendList.length; j++) {\n        this.foundExtends = true\n        extend = extendList[j]\n        extend.findSelfSelectors(selectorPath)\n        extend.ruleset = rulesetNode\n        if (j === 0) {\n          extend.firstExtendOnThisSelectorPath = true\n        }\n        this.allExtendsStack[this.allExtendsStack.length - 1].push(extend)\n      }\n    }\n\n    this.contexts.push(rulesetNode.selectors)\n  }\n\n  visitRulesetOut(rulesetNode) {\n    if (!rulesetNode.root) {\n      this.contexts.length = this.contexts.length - 1\n    }\n  }\n\n  visitMedia(mediaNode, visitArgs) {\n    mediaNode.allExtends = []\n    this.allExtendsStack.push(mediaNode.allExtends)\n  }\n\n  visitMediaOut(mediaNode) {\n    this.allExtendsStack.length = this.allExtendsStack.length - 1\n  }\n\n  visitDirective(directiveNode, visitArgs) {\n    directiveNode.allExtends = []\n    this.allExtendsStack.push(directiveNode.allExtends)\n  }\n\n  visitDirectiveOut(directiveNode) {\n    this.allExtendsStack.length = this.allExtendsStack.length - 1\n  }\n}\n\nclass ProcessExtendsVisitor {\n  constructor() {\n    this._visitor = new Visitor(this)\n  }\n\n  run(root) {\n    const extendFinder = new ExtendFinderVisitor()\n    this.extendIndices = {}\n    extendFinder.run(root)\n    if (!extendFinder.foundExtends) {\n      return root\n    }\n    root.allExtends = root.allExtends.concat(\n      this.doExtendChaining(root.allExtends, root.allExtends)\n    )\n    this.allExtendsStack = [root.allExtends]\n    const newRoot = this._visitor.visit(root)\n    this.checkExtendsForNonMatched(root.allExtends)\n    return newRoot\n  }\n\n  checkExtendsForNonMatched(extendList) {\n    const indices = this.extendIndices\n    extendList\n      .filter(\n        extend => !extend.hasFoundMatches && extend.parent_ids.length == 1\n      )\n      .forEach(extend => {\n        let selector = '_unknown_'\n        try {\n          selector = extend.selector.toCSS({})\n        } catch (_) {}\n\n        if (!indices[`${extend.index} ${selector}`]) {\n          indices[`${extend.index} ${selector}`] = true\n          logger.warn(`extend '${selector}' has no matches`)\n        }\n      })\n  }\n\n  doExtendChaining(extendsList, extendsListTarget, iterationCount) {\n    //\n    // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering\n    // and pasting the selector we would do normally, but we are also adding an extend with the same target selector\n    // this means this new extend can then go and alter other extends\n    //\n    // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors\n    // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already\n    // processed if we look at each selector at a time, as is done in visitRuleset\n\n    let extendIndex\n\n    let targetExtendIndex\n    let matches\n    const extendsToAdd = []\n    let newSelector\n    const extendVisitor = this\n    let selectorPath\n    let extend\n    let targetExtend\n    let newExtend\n\n    iterationCount = iterationCount || 0\n\n    //loop through comparing every extend with every target extend.\n    // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n    // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n    // and the second is the target.\n    // the separation into two lists allows us to process a subset of chains with a bigger set, as is the\n    // case when processing media queries\n    for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {\n      for (\n        targetExtendIndex = 0;\n        targetExtendIndex < extendsListTarget.length;\n        targetExtendIndex++\n      ) {\n        extend = extendsList[extendIndex]\n        targetExtend = extendsListTarget[targetExtendIndex]\n\n        // look for circular references\n        if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {\n          continue\n        }\n\n        // find a match in the target extends self selector (the bit before :extend)\n        selectorPath = [targetExtend.selfSelectors[0]]\n        matches = extendVisitor.findMatch(extend, selectorPath)\n\n        if (matches.length) {\n          extend.hasFoundMatches = true\n\n          // we found a match, so for each self selector..\n          extend.selfSelectors.forEach(selfSelector => {\n            const info = targetExtend.visibilityInfo()\n\n            // process the extend as usual\n            newSelector = extendVisitor.extendSelector(\n              matches,\n              selectorPath,\n              selfSelector,\n              extend.isVisible()\n            )\n\n            // but now we create a new extend from it\n            newExtend = new tree.Extend(\n              targetExtend.selector,\n              targetExtend.option,\n              0,\n              targetExtend.currentFileInfo,\n              info\n            )\n            newExtend.selfSelectors = newSelector\n\n            // add the extend onto the list of extends for that selector\n            newSelector[newSelector.length - 1].extendList = [newExtend]\n\n            // record that we need to add it.\n            extendsToAdd.push(newExtend)\n            newExtend.ruleset = targetExtend.ruleset\n\n            //remember its parents for circular references\n            newExtend.parent_ids = newExtend.parent_ids.concat(\n              targetExtend.parent_ids,\n              extend.parent_ids\n            )\n\n            // only process the selector once.. if we have :extend(.a,.b) then multiple\n            // extends will look at the same selector path, so when extending\n            // we know that any others will be duplicates in terms of what is added to the css\n            if (targetExtend.firstExtendOnThisSelectorPath) {\n              newExtend.firstExtendOnThisSelectorPath = true\n              targetExtend.ruleset.paths.push(newSelector)\n            }\n          })\n        }\n      }\n    }\n\n    if (extendsToAdd.length) {\n      // try to detect circular references to stop a stack overflow.\n      // may no longer be needed.\n      this.extendChainCount++\n      if (iterationCount > 100) {\n        let selectorOne = '{unable to calculate}'\n        let selectorTwo = '{unable to calculate}'\n        try {\n          selectorOne = extendsToAdd[0].selfSelectors[0].toCSS()\n          selectorTwo = extendsToAdd[0].selector.toCSS()\n        } catch (e) {}\n        throw {\n          message: `extend circular reference detected. One of the circular extends is currently:${selectorOne}:extend(${selectorTwo})`,\n        }\n      }\n\n      // now process the new extends on the existing rules so that we can handle a extending b extending c extending\n      // d extending e...\n      return extendsToAdd.concat(\n        extendVisitor.doExtendChaining(\n          extendsToAdd,\n          extendsListTarget,\n          iterationCount + 1\n        )\n      )\n    } else {\n      return extendsToAdd\n    }\n  }\n\n  visitRule(ruleNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitSelector(selectorNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitRuleset(rulesetNode, visitArgs) {\n    if (rulesetNode.root) {\n      return\n    }\n    let matches\n    let pathIndex\n    let extendIndex\n    const allExtends = this.allExtendsStack[this.allExtendsStack.length - 1]\n    const selectorsToAdd = []\n    const extendVisitor = this\n    let selectorPath\n\n    // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n\n    for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n      for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n        selectorPath = rulesetNode.paths[pathIndex]\n\n        // extending extends happens initially, before the main pass\n        if (rulesetNode.extendOnEveryPath) {\n          continue\n        }\n        const extendList = selectorPath[selectorPath.length - 1].extendList\n        if (extendList && extendList.length) {\n          continue\n        }\n\n        matches = this.findMatch(allExtends[extendIndex], selectorPath)\n\n        if (matches.length) {\n          allExtends[extendIndex].hasFoundMatches = true\n\n          allExtends[extendIndex].selfSelectors.forEach(selfSelector => {\n            let extendedSelectors\n            extendedSelectors = extendVisitor.extendSelector(\n              matches,\n              selectorPath,\n              selfSelector,\n              allExtends[extendIndex].isVisible()\n            )\n            selectorsToAdd.push(extendedSelectors)\n          })\n        }\n      }\n    }\n    rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd)\n  }\n\n  findMatch(extend, haystackSelectorPath) {\n    //\n    // look through the haystack selector path to try and find the needle - extend.selector\n    // returns an array of selector matches that can then be replaced\n    //\n    let haystackSelectorIndex\n\n    let hackstackSelector\n    let hackstackElementIndex\n    let haystackElement\n    let targetCombinator\n    let i\n    const extendVisitor = this\n    const needleElements = extend.selector.elements\n    const potentialMatches = []\n    let potentialMatch\n    const matches = []\n\n    // loop through the haystack elements\n    for (\n      haystackSelectorIndex = 0;\n      haystackSelectorIndex < haystackSelectorPath.length;\n      haystackSelectorIndex++\n    ) {\n      hackstackSelector = haystackSelectorPath[haystackSelectorIndex]\n\n      for (\n        hackstackElementIndex = 0;\n        hackstackElementIndex < hackstackSelector.elements.length;\n        hackstackElementIndex++\n      ) {\n        haystackElement = hackstackSelector.elements[hackstackElementIndex]\n\n        // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n        if (\n          extend.allowBefore ||\n          (haystackSelectorIndex === 0 && hackstackElementIndex === 0)\n        ) {\n          potentialMatches.push({\n            pathIndex: haystackSelectorIndex,\n            index: hackstackElementIndex,\n            matched: 0,\n            initialCombinator: haystackElement.combinator,\n          })\n        }\n\n        for (i = 0; i < potentialMatches.length; i++) {\n          potentialMatch = potentialMatches[i]\n\n          // selectors add \" \" onto the first element. When we use & it joins the selectors together, but if we don't\n          // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to\n          // work out what the resulting combinator will be\n          targetCombinator = haystackElement.combinator.value\n          if (targetCombinator === '' && hackstackElementIndex === 0) {\n            targetCombinator = ' '\n          }\n\n          // if we don't match, null our match to indicate failure\n          if (\n            !extendVisitor.isElementValuesEqual(\n              needleElements[potentialMatch.matched].value,\n              haystackElement.value\n            ) ||\n            (potentialMatch.matched > 0 &&\n              needleElements[potentialMatch.matched].combinator.value !==\n                targetCombinator)\n          ) {\n            potentialMatch = null\n          } else {\n            potentialMatch.matched++\n          }\n\n          // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n          if (potentialMatch) {\n            potentialMatch.finished =\n              potentialMatch.matched === needleElements.length\n            if (\n              potentialMatch.finished &&\n              (!extend.allowAfter &&\n                (hackstackElementIndex + 1 <\n                  hackstackSelector.elements.length ||\n                  haystackSelectorIndex + 1 < haystackSelectorPath.length))\n            ) {\n              potentialMatch = null\n            }\n          }\n          // if null we remove, if not, we are still valid, so either push as a valid match or continue\n          if (potentialMatch) {\n            if (potentialMatch.finished) {\n              potentialMatch.length = needleElements.length\n              potentialMatch.endPathIndex = haystackSelectorIndex\n              potentialMatch.endPathElementIndex = hackstackElementIndex + 1 // index after end of match\n              potentialMatches.length = 0 // we don't allow matches to overlap, so start matching again\n              matches.push(potentialMatch)\n            }\n          } else {\n            potentialMatches.splice(i, 1)\n            i--\n          }\n        }\n      }\n    }\n    return matches\n  }\n\n  isElementValuesEqual(elementValue1, elementValue2) {\n    if (\n      typeof elementValue1 === 'string' ||\n      typeof elementValue2 === 'string'\n    ) {\n      return elementValue1 === elementValue2\n    }\n    if (elementValue1 instanceof tree.Attribute) {\n      if (\n        elementValue1.op !== elementValue2.op ||\n        elementValue1.key !== elementValue2.key\n      ) {\n        return false\n      }\n      if (!elementValue1.value || !elementValue2.value) {\n        if (elementValue1.value || elementValue2.value) {\n          return false\n        }\n        return true\n      }\n      elementValue1 = elementValue1.value.value || elementValue1.value\n      elementValue2 = elementValue2.value.value || elementValue2.value\n      return elementValue1 === elementValue2\n    }\n    elementValue1 = elementValue1.value\n    elementValue2 = elementValue2.value\n    if (elementValue1 instanceof tree.Selector) {\n      if (\n        !(elementValue2 instanceof tree.Selector) ||\n        elementValue1.elements.length !== elementValue2.elements.length\n      ) {\n        return false\n      }\n      for (let i = 0; i < elementValue1.elements.length; i++) {\n        if (\n          elementValue1.elements[i].combinator.value !==\n          elementValue2.elements[i].combinator.value\n        ) {\n          if (\n            i !== 0 ||\n            (elementValue1.elements[i].combinator.value || ' ') !==\n              (elementValue2.elements[i].combinator.value || ' ')\n          ) {\n            return false\n          }\n        }\n        if (\n          !this.isElementValuesEqual(\n            elementValue1.elements[i].value,\n            elementValue2.elements[i].value\n          )\n        ) {\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n\n  extendSelector(matches, selectorPath, replacementSelector, isVisible) {\n    //for a set of matches, replace each match with the replacement selector\n\n    let currentSelectorPathIndex = 0\n\n    let currentSelectorPathElementIndex = 0\n    let path = []\n    let matchIndex\n    let selector\n    let firstElement\n    let match\n    let newElements\n\n    for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n      match = matches[matchIndex]\n      selector = selectorPath[match.pathIndex]\n      firstElement = new tree.Element(\n        match.initialCombinator,\n        replacementSelector.elements[0].value,\n        replacementSelector.elements[0].index,\n        replacementSelector.elements[0].currentFileInfo\n      )\n\n      if (\n        match.pathIndex > currentSelectorPathIndex &&\n        currentSelectorPathElementIndex > 0\n      ) {\n        path[path.length - 1].elements = path[path.length - 1].elements.concat(\n          selectorPath[currentSelectorPathIndex].elements.slice(\n            currentSelectorPathElementIndex\n          )\n        )\n        currentSelectorPathElementIndex = 0\n        currentSelectorPathIndex++\n      }\n\n      newElements = selector.elements\n        .slice(currentSelectorPathElementIndex, match.index)\n        .concat([firstElement])\n        .concat(replacementSelector.elements.slice(1))\n\n      if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n        path[path.length - 1].elements = path[path.length - 1].elements.concat(\n          newElements\n        )\n      } else {\n        path = path.concat(\n          selectorPath.slice(currentSelectorPathIndex, match.pathIndex)\n        )\n\n        path.push(new tree.Selector(newElements))\n      }\n      currentSelectorPathIndex = match.endPathIndex\n      currentSelectorPathElementIndex = match.endPathElementIndex\n      if (\n        currentSelectorPathElementIndex >=\n        selectorPath[currentSelectorPathIndex].elements.length\n      ) {\n        currentSelectorPathElementIndex = 0\n        currentSelectorPathIndex++\n      }\n    }\n\n    if (\n      currentSelectorPathIndex < selectorPath.length &&\n      currentSelectorPathElementIndex > 0\n    ) {\n      path[path.length - 1].elements = path[path.length - 1].elements.concat(\n        selectorPath[currentSelectorPathIndex].elements.slice(\n          currentSelectorPathElementIndex\n        )\n      )\n      currentSelectorPathIndex++\n    }\n\n    path = path.concat(\n      selectorPath.slice(currentSelectorPathIndex, selectorPath.length)\n    )\n    path = path.map(currentValue => {\n      // we can re-use elements here, because the visibility property matters only for selectors\n      const derived = currentValue.createDerived(currentValue.elements)\n      if (isVisible) {\n        derived.ensureVisibility()\n      } else {\n        derived.ensureInvisibility()\n      }\n      return derived\n    })\n    return path\n  }\n\n  visitMedia(mediaNode, visitArgs) {\n    let newAllExtends = mediaNode.allExtends.concat(\n      this.allExtendsStack[this.allExtendsStack.length - 1]\n    )\n    newAllExtends = newAllExtends.concat(\n      this.doExtendChaining(newAllExtends, mediaNode.allExtends)\n    )\n    this.allExtendsStack.push(newAllExtends)\n  }\n\n  visitMediaOut(mediaNode) {\n    const lastIndex = this.allExtendsStack.length - 1\n    this.allExtendsStack.length = lastIndex\n  }\n\n  visitDirective(directiveNode, visitArgs) {\n    let newAllExtends = directiveNode.allExtends.concat(\n      this.allExtendsStack[this.allExtendsStack.length - 1]\n    )\n    newAllExtends = newAllExtends.concat(\n      this.doExtendChaining(newAllExtends, directiveNode.allExtends)\n    )\n    this.allExtendsStack.push(newAllExtends)\n  }\n\n  visitDirectiveOut(directiveNode) {\n    const lastIndex = this.allExtendsStack.length - 1\n    this.allExtendsStack.length = lastIndex\n  }\n}\n\nmodule.exports = ProcessExtendsVisitor\n","const Visitor = require('./visitor')\n\nclass JoinSelectorVisitor {\n  constructor() {\n    this.contexts = [[]]\n    this._visitor = new Visitor(this)\n  }\n\n  run(root) {\n    return this._visitor.visit(root)\n  }\n\n  visitRule(ruleNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitRuleset(rulesetNode, visitArgs) {\n    const context = this.contexts[this.contexts.length - 1]\n    const paths = []\n    let selectors\n\n    this.contexts.push(paths)\n\n    if (!rulesetNode.root) {\n      selectors = rulesetNode.selectors\n      if (selectors) {\n        selectors = selectors.filter(selector => selector.getIsOutput())\n        rulesetNode.selectors = selectors.length\n          ? selectors\n          : (selectors = null)\n        if (selectors) {\n          rulesetNode.joinSelectors(paths, context, selectors)\n        }\n      }\n      if (!selectors) {\n        rulesetNode.rules = null\n      }\n      rulesetNode.paths = paths\n    }\n  }\n\n  visitRulesetOut(rulesetNode) {\n    this.contexts.length = this.contexts.length - 1\n  }\n\n  visitMedia(mediaNode, visitArgs) {\n    const context = this.contexts[this.contexts.length - 1]\n    mediaNode.rules[0].root = context.length === 0 || context[0].multiMedia\n  }\n\n  visitDirective(directiveNode, visitArgs) {\n    const context = this.contexts[this.contexts.length - 1]\n    if (directiveNode.rules && directiveNode.rules.length) {\n      directiveNode.rules[0].root =\n        directiveNode.isRooted || context.length === 0 || null\n    }\n  }\n}\n\nmodule.exports = JoinSelectorVisitor\n","const tree = require('../tree')\nconst Visitor = require('./visitor')\n\nclass CSSVisitorUtils {\n  constructor(context) {\n    this._visitor = new Visitor(this)\n    this._context = context\n  }\n\n  containsSilentNonBlockedChild(bodyRules) {\n    let rule\n    if (bodyRules == null) {\n      return false\n    }\n    for (let r = 0; r < bodyRules.length; r++) {\n      rule = bodyRules[r]\n      if (\n        rule.isSilent &&\n        rule.isSilent(this._context) &&\n        !rule.blocksVisibility()\n      ) {\n        //the directive contains something that was referenced (likely by extend)\n        //therefore it needs to be shown in output too\n        return true\n      }\n    }\n    return false\n  }\n\n  keepOnlyVisibleChilds(owner) {\n    if (owner == null || owner.rules == null) {\n      return\n    }\n\n    owner.rules = owner.rules.filter(thing => thing.isVisible())\n  }\n\n  isEmpty(owner) {\n    if (owner == null || owner.rules == null) {\n      return true\n    }\n    return owner.rules.length === 0\n  }\n\n  hasVisibleSelector(rulesetNode) {\n    if (rulesetNode == null || rulesetNode.paths == null) {\n      return false\n    }\n    return rulesetNode.paths.length > 0\n  }\n\n  resolveVisibility(node, originalRules) {\n    if (!node.blocksVisibility()) {\n      if (\n        this.isEmpty(node) &&\n        !this.containsSilentNonBlockedChild(originalRules)\n      ) {\n        return\n      }\n\n      return node\n    }\n\n    const compiledRulesBody = node.rules[0]\n    this.keepOnlyVisibleChilds(compiledRulesBody)\n\n    if (this.isEmpty(compiledRulesBody)) {\n      return\n    }\n\n    node.ensureVisibility()\n    node.removeVisibilityBlock()\n\n    return node\n  }\n\n  isVisibleRuleset(rulesetNode) {\n    if (rulesetNode.firstRoot) {\n      return true\n    }\n\n    if (this.isEmpty(rulesetNode)) {\n      return false\n    }\n\n    if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n      return false\n    }\n\n    return true\n  }\n}\n\nconst ToCSSVisitor = function(context) {\n  this._visitor = new Visitor(this)\n  this._context = context\n  this.utils = new CSSVisitorUtils(context)\n  this._level = 0\n}\n\nToCSSVisitor.prototype = {\n  isReplacing: true,\n  run(root) {\n    return this._visitor.visit(root)\n  },\n\n  visitRule(ruleNode, visitArgs) {\n    if (ruleNode.blocksVisibility()) {\n      return\n    }\n    if (ruleNode.variable) {\n      if (!this._context.simplify) return //We don't need any variables\n      if (this._level > this._context.simplifyLevel) return //Variable is too deep\n      if (\n        this._context.simplifyFilter &&\n        !this._context.simplifyFilter.test(ruleNode.name)\n      )\n        return //Variable didnt pass filter\n    }\n    return ruleNode\n  },\n\n  visitMixinDefinition(mixinNode, visitArgs) {\n    // mixin definitions do not get eval'd - this means they keep state\n    // so we have to clear that state here so it isn't used if toCSS is called twice\n    mixinNode.frames = []\n  },\n\n  visitExtend(extendNode, visitArgs) {},\n\n  visitComment(commentNode, visitArgs) {\n    if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n      return\n    }\n    return commentNode\n  },\n\n  visitMedia(mediaNode, visitArgs) {\n    const originalRules = mediaNode.rules[0].rules\n    mediaNode.accept(this._visitor)\n    visitArgs.visitDeeper = false\n\n    return this.utils.resolveVisibility(mediaNode, originalRules)\n  },\n\n  visitImport(importNode, visitArgs) {\n    if (importNode.blocksVisibility()) {\n      return\n    }\n    return importNode\n  },\n\n  visitDirective(directiveNode, visitArgs) {\n    if (directiveNode.rules && directiveNode.rules.length) {\n      return this.visitDirectiveWithBody(directiveNode, visitArgs)\n    } else {\n      return this.visitDirectiveWithoutBody(directiveNode, visitArgs)\n    }\n  },\n\n  visitDirectiveWithBody(directiveNode, visitArgs) {\n    //if there is only one nested ruleset and that one has no path, then it is\n    //just fake ruleset\n    function hasFakeRuleset(directiveNode) {\n      const bodyRules = directiveNode.rules\n      return (\n        bodyRules.length === 1 &&\n        (!bodyRules[0].paths || bodyRules[0].paths.length === 0)\n      )\n    }\n    function getBodyRules(directiveNode) {\n      const nodeRules = directiveNode.rules\n      if (hasFakeRuleset(directiveNode)) {\n        return nodeRules[0].rules\n      }\n\n      return nodeRules\n    }\n    //it is still true that it is only one ruleset in array\n    //this is last such moment\n    //process childs\n    const originalRules = getBodyRules(directiveNode)\n    directiveNode.accept(this._visitor)\n    visitArgs.visitDeeper = false\n\n    if (!this.utils.isEmpty(directiveNode)) {\n      this._mergeRules(directiveNode.rules[0].rules)\n    }\n\n    return this.utils.resolveVisibility(directiveNode, originalRules)\n  },\n\n  visitDirectiveWithoutBody(directiveNode, visitArgs) {\n    if (directiveNode.blocksVisibility()) {\n      return\n    }\n\n    if (directiveNode.name === '@charset') {\n      // Only output the debug info together with subsequent @charset definitions\n      // a comment (or @media statement) before the actual @charset directive would\n      // be considered illegal css as it has to be on the first line\n      if (this.charset) {\n        if (directiveNode.debugInfo) {\n          const comment = new tree.Comment(\n            `/* ${directiveNode.toCSS(this._context).replace(/\\n/g, '')} */\\n`\n          )\n          comment.debugInfo = directiveNode.debugInfo\n          return this._visitor.visit(comment)\n        }\n        return\n      }\n      this.charset = true\n    }\n\n    return directiveNode\n  },\n\n  checkValidNodes(rules, isRoot) {\n    if (!rules) {\n      return\n    }\n\n    for (let i = 0; i < rules.length; i++) {\n      const ruleNode = rules[i]\n      if (isRoot && ruleNode instanceof tree.Rule && !ruleNode.variable) {\n        throw {\n          message:\n            'Properties must be inside selector blocks. They cannot be in the root',\n          index: ruleNode.index,\n          filename:\n            ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename,\n        }\n      }\n      if (ruleNode instanceof tree.Call) {\n        throw {\n          message: `Function '${ruleNode.name}' is undefined`,\n          index: ruleNode.index,\n          filename:\n            ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename,\n        }\n      }\n      if (ruleNode.type && !ruleNode.allowRoot) {\n        throw {\n          message: `${\n            ruleNode.type\n          } node returned by a function is not valid here`,\n          index: ruleNode.index,\n          filename:\n            ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename,\n        }\n      }\n    }\n  },\n  visitRulesetOut(rulesetNode) {\n    this._level--\n  },\n  visitRuleset(rulesetNode, visitArgs) {\n    this._level++\n\n    //at this point rulesets are nested into each other\n    let rule\n\n    const rulesets = []\n\n    this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot)\n\n    if (!rulesetNode.root) {\n      //remove invisible paths\n      this._compileRulesetPaths(rulesetNode)\n\n      // remove rulesets from this ruleset body and compile them separately\n      const nodeRules = rulesetNode.rules\n\n      let nodeRuleCnt = nodeRules ? nodeRules.length : 0\n      for (let i = 0; i < nodeRuleCnt; ) {\n        rule = nodeRules[i]\n        if (rule && rule.rules) {\n          // visit because we are moving them out from being a child\n          rulesets.push(this._visitor.visit(rule))\n          nodeRules.splice(i, 1)\n          nodeRuleCnt--\n          continue\n        }\n        i++\n      }\n      // accept the visitor to remove rules and refactor itself\n      // then we can decide nogw whether we want it or not\n      // compile body\n      if (nodeRuleCnt > 0) {\n        rulesetNode.accept(this._visitor)\n      } else {\n        rulesetNode.rules = null\n      }\n      visitArgs.visitDeeper = false\n    } else {\n      //if (! rulesetNode.root) {\n      rulesetNode.accept(this._visitor)\n      visitArgs.visitDeeper = false\n    }\n\n    if (rulesetNode.rules) {\n      this._mergeRules(rulesetNode.rules)\n      this._removeDuplicateRules(rulesetNode.rules)\n    }\n\n    //now decide whether we keep the ruleset\n    if (this.utils.isVisibleRuleset(rulesetNode)) {\n      rulesetNode.ensureVisibility()\n      rulesets.splice(0, 0, rulesetNode)\n    }\n\n    if (rulesets.length === 1) {\n      return rulesets[0]\n    }\n    return rulesets\n  },\n\n  _compileRulesetPaths(rulesetNode) {\n    if (rulesetNode.paths) {\n      rulesetNode.paths = rulesetNode.paths.filter(p => {\n        let i\n        if (p[0].elements[0].combinator.value === ' ') {\n          p[0].elements[0].combinator = new tree.Combinator('')\n        }\n        for (i = 0; i < p.length; i++) {\n          if (p[i].isVisible() && p[i].getIsOutput()) {\n            return true\n          }\n        }\n        return false\n      })\n    }\n  },\n\n  _removeDuplicateRules(rules) {\n    if (!rules) {\n      return\n    }\n\n    // remove duplicates\n    const ruleCache = {}\n\n    let ruleList\n    let rule\n    let i\n\n    for (i = rules.length - 1; i >= 0; i--) {\n      rule = rules[i]\n      if (rule instanceof tree.Rule) {\n        if (!ruleCache[rule.name]) {\n          ruleCache[rule.name] = rule\n        } else {\n          ruleList = ruleCache[rule.name]\n          if (ruleList instanceof tree.Rule) {\n            ruleList = ruleCache[rule.name] = [\n              ruleCache[rule.name].toCSS(this._context),\n            ]\n          }\n          const ruleCSS = rule.toCSS(this._context)\n          if (ruleList.indexOf(ruleCSS) !== -1) {\n            rules.splice(i, 1)\n          } else {\n            ruleList.push(ruleCSS)\n          }\n        }\n      }\n    }\n  },\n\n  _mergeRules(rules) {\n    if (!rules) {\n      return\n    }\n\n    const groups = {}\n    let parts\n    let rule\n    let key\n\n    for (let i = 0; i < rules.length; i++) {\n      rule = rules[i]\n\n      if (rule instanceof tree.Rule && rule.merge) {\n        key = [rule.name, rule.important ? '!' : ''].join(',')\n\n        if (!groups[key]) {\n          groups[key] = []\n        } else {\n          rules.splice(i--, 1)\n        }\n\n        groups[key].push(rule)\n      }\n    }\n\n    Object.keys(groups).map(k => {\n      function toExpression(values) {\n        return new tree.Expression(values.map(p => p.value))\n      }\n\n      function toValue(values) {\n        return new tree.Value(values.map(p => p))\n      }\n\n      parts = groups[k]\n\n      if (parts.length > 1) {\n        rule = parts[0]\n        const spacedGroups = []\n        let lastSpacedGroup = []\n        parts.map(p => {\n          if (p.merge === '+') {\n            if (lastSpacedGroup.length > 0) {\n              spacedGroups.push(toExpression(lastSpacedGroup))\n            }\n            lastSpacedGroup = []\n          }\n          lastSpacedGroup.push(p)\n        })\n        spacedGroups.push(toExpression(lastSpacedGroup))\n        rule.value = toValue(spacedGroups)\n      }\n    })\n  },\n\n  visitAnonymous(anonymousNode, visitArgs) {\n    if (anonymousNode.blocksVisibility()) {\n      return\n    }\n    anonymousNode.accept(this._visitor)\n    return anonymousNode\n  },\n}\n\nmodule.exports = ToCSSVisitor\n","const visitors = {\n  Visitor: require('./visitor'),\n  ImportVisitor: require('./import-visitor'),\n  MarkVisibleSelectorsVisitor: require('./set-tree-visibility-visitor'),\n  ExtendVisitor: require('./extend-visitor'),\n  JoinSelectorVisitor: require('./join-selector-visitor'),\n  ToCSSVisitor: require('./to-css-visitor'),\n}\n\nmodule.exports = visitors\n","const contexts = require('./contexts')\nconst visitor = require('./visitors')\nconst tree = require('./tree')\n\nmodule.exports = (root, options) => {\n  options = options || {}\n  let evaldRoot\n  let variables = options.variables\n  const evalEnv = new contexts.Eval(options)\n\n  //\n  // Allows setting variables with a hash, so:\n  //\n  //   `{ color: new tree.Color('#f01') }` will become:\n  //\n  //   new tree.Rule('@color',\n  //     new tree.Value([\n  //       new tree.Expression([\n  //         new tree.Color('#f01')\n  //       ])\n  //     ])\n  //   )\n  //\n  if (typeof variables === 'object' && !Array.isArray(variables)) {\n    variables = Object.keys(variables).map(k => {\n      let value = variables[k]\n\n      if (!(value instanceof tree.Value)) {\n        if (!(value instanceof tree.Expression)) {\n          value = new tree.Expression([value])\n        }\n        value = new tree.Value([value])\n      }\n      return new tree.Rule(`@${k}`, value, false, null, 0)\n    })\n    evalEnv.frames = [new tree.Ruleset(null, variables)]\n  }\n\n  const preEvalVisitors = []\n\n  const visitors = [\n    new visitor.JoinSelectorVisitor(),\n    new visitor.MarkVisibleSelectorsVisitor(true),\n    new visitor.ExtendVisitor(),\n    new visitor.ToCSSVisitor({\n      compress: Boolean(options.compress),\n      simplify: Boolean(options.simplify),\n      simplifyLevel: Number(options.simplifyLevel || 1),\n      simplifyFilter: options.simplifyFilter,\n    }),\n  ]\n\n  let i\n\n  if (options.pluginManager) {\n    const pluginVisitors = options.pluginManager.getVisitors()\n    for (i = 0; i < pluginVisitors.length; i++) {\n      const pluginVisitor = pluginVisitors[i]\n      if (pluginVisitor.isPreEvalVisitor) {\n        preEvalVisitors.push(pluginVisitor)\n      } else {\n        if (pluginVisitor.isPreVisitor) {\n          visitors.splice(0, 0, pluginVisitor)\n        } else {\n          visitors.push(pluginVisitor)\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < preEvalVisitors.length; i++) {\n    preEvalVisitors[i].run(root)\n  }\n\n  evaldRoot = root.eval(evalEnv)\n\n  for (i = 0; i < visitors.length; i++) {\n    visitors[i].run(evaldRoot)\n  }\n\n  return evaldRoot\n}\n","const LessError = require('./less-error')\nconst transformTree = require('./transform-tree')\nconst logger = require('./logger')\n\nmodule.exports = SourceMapBuilder => {\n  class ParseTree {\n    constructor(root, imports) {\n      this.root = root\n      this.imports = imports\n    }\n\n    toCSS(options) {\n      let evaldRoot\n      const result = {}\n      let sourceMapBuilder\n      try {\n        evaldRoot = transformTree(this.root, options)\n      } catch (e) {\n        throw new LessError(e, this.imports)\n      }\n\n      try {\n        const compress = Boolean(options.compress)\n        if (compress) {\n          logger.warn(\n            'The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.'\n          )\n        }\n\n        const toCSSOptions = {\n          compress,\n          dumpLineNumbers: options.dumpLineNumbers,\n          strictUnits: Boolean(options.strictUnits),\n          numPrecision: 8,\n        }\n\n        if (options.sourceMap) {\n          sourceMapBuilder = new SourceMapBuilder(options.sourceMap)\n          result.css = sourceMapBuilder.toCSS(\n            evaldRoot,\n            toCSSOptions,\n            this.imports\n          )\n        } else {\n          result.css = evaldRoot.toCSS(toCSSOptions)\n        }\n      } catch (e) {\n        throw new LessError(e, this.imports)\n      }\n\n      if (options.pluginManager) {\n        const postProcessors = options.pluginManager.getPostProcessors()\n        for (let i = 0; i < postProcessors.length; i++) {\n          result.css = postProcessors[i].process(result.css, {\n            sourceMap: sourceMapBuilder,\n            options,\n            imports: this.imports,\n          })\n        }\n      }\n      if (options.sourceMap) {\n        result.map = sourceMapBuilder.getExternalSourceMap()\n      }\n\n      result.imports = []\n      for (const file in this.imports.files) {\n        if (\n          this.imports.files.hasOwnProperty(file) &&\n          file !== this.imports.rootFilename\n        ) {\n          result.imports.push(file)\n        }\n      }\n      return result\n    }\n  }\n\n  return ParseTree\n}\n","// Split the input into chunks.\nmodule.exports = (input, fail) => {\n  const len = input.length\n  let level = 0\n  let parenLevel = 0\n  let lastOpening\n  let lastOpeningParen\n  let lastMultiComment\n  let lastMultiCommentEndBrace\n  const chunks = []\n  let emitFrom = 0\n  let chunkerCurrentIndex\n  let currentChunkStartIndex\n  let cc\n  let cc2\n  let matched\n\n  function emitChunk(force) {\n    const len = chunkerCurrentIndex - emitFrom\n    if ((len < 512 && !force) || !len) {\n      return\n    }\n    chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1))\n    emitFrom = chunkerCurrentIndex + 1\n  }\n\n  for (\n    chunkerCurrentIndex = 0;\n    chunkerCurrentIndex < len;\n    chunkerCurrentIndex++\n  ) {\n    cc = input.charCodeAt(chunkerCurrentIndex)\n    if ((cc >= 97 && cc <= 122) || cc < 34) {\n      // a-z or whitespace\n      continue\n    }\n\n    switch (cc) {\n      case 40: // (\n        parenLevel++\n        lastOpeningParen = chunkerCurrentIndex\n        continue\n      case 41: // )\n        if (--parenLevel < 0) {\n          return fail('missing opening `(`', chunkerCurrentIndex)\n        }\n        continue\n      case 59: // ;\n        if (!parenLevel) {\n          emitChunk()\n        }\n        continue\n      case 123: // {\n        level++\n        lastOpening = chunkerCurrentIndex\n        continue\n      case 125: // }\n        if (--level < 0) {\n          return fail('missing opening `{`', chunkerCurrentIndex)\n        }\n        if (!level && !parenLevel) {\n          emitChunk()\n        }\n        continue\n      case 92: // \\\n        if (chunkerCurrentIndex < len - 1) {\n          chunkerCurrentIndex++\n          continue\n        }\n        return fail('unescaped `\\\\`', chunkerCurrentIndex)\n      case 34:\n      case 39:\n      case 96: // \", ' and `\n        matched = 0\n        currentChunkStartIndex = chunkerCurrentIndex\n        for (\n          chunkerCurrentIndex = chunkerCurrentIndex + 1;\n          chunkerCurrentIndex < len;\n          chunkerCurrentIndex++\n        ) {\n          cc2 = input.charCodeAt(chunkerCurrentIndex)\n          if (cc2 > 96) {\n            continue\n          }\n          if (cc2 == cc) {\n            matched = 1\n            break\n          }\n          if (cc2 == 92) {\n            // \\\n            if (chunkerCurrentIndex == len - 1) {\n              return fail('unescaped `\\\\`', chunkerCurrentIndex)\n            }\n            chunkerCurrentIndex++\n          }\n        }\n        if (matched) {\n          continue\n        }\n        return fail(\n          `unmatched \\`${String.fromCharCode(cc)}\\``,\n          currentChunkStartIndex\n        )\n      case 47: // /, check for comment\n        if (parenLevel || chunkerCurrentIndex == len - 1) {\n          continue\n        }\n        cc2 = input.charCodeAt(chunkerCurrentIndex + 1)\n        if (cc2 == 47) {\n          // //, find lnfeed\n          for (\n            chunkerCurrentIndex = chunkerCurrentIndex + 2;\n            chunkerCurrentIndex < len;\n            chunkerCurrentIndex++\n          ) {\n            cc2 = input.charCodeAt(chunkerCurrentIndex)\n            if (cc2 <= 13 && (cc2 == 10 || cc2 == 13)) {\n              break\n            }\n          }\n        } else if (cc2 == 42) {\n          // /*, find */\n          lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex\n          for (\n            chunkerCurrentIndex = chunkerCurrentIndex + 2;\n            chunkerCurrentIndex < len - 1;\n            chunkerCurrentIndex++\n          ) {\n            cc2 = input.charCodeAt(chunkerCurrentIndex)\n            if (cc2 == 125) {\n              lastMultiCommentEndBrace = chunkerCurrentIndex\n            }\n            if (cc2 != 42) {\n              continue\n            }\n            if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {\n              break\n            }\n          }\n          if (chunkerCurrentIndex == len - 1) {\n            return fail('missing closing `*/`', currentChunkStartIndex)\n          }\n          chunkerCurrentIndex++\n        }\n        continue\n      case 42: // *, check for unmatched */\n        if (\n          chunkerCurrentIndex < len - 1 &&\n          input.charCodeAt(chunkerCurrentIndex + 1) == 47\n        ) {\n          return fail('unmatched `/*`', chunkerCurrentIndex)\n        }\n        continue\n    }\n  }\n\n  if (level !== 0) {\n    if (\n      lastMultiComment > lastOpening &&\n      lastMultiCommentEndBrace > lastMultiComment\n    ) {\n      return fail('missing closing `}` or `*/`', lastOpening)\n    } else {\n      return fail('missing closing `}`', lastOpening)\n    }\n  } else if (parenLevel !== 0) {\n    return fail('missing closing `)`', lastOpeningParen)\n  }\n\n  emitChunk(true)\n  return chunks\n}\n","const chunker = require('./chunker')\n\nmodule.exports = () => {\n  let // LeSS input string\n  input\n\n  let // current chunk\n  j\n\n  const // holds state for backtracking\n  saveStack = []\n\n  let // furthest index the parser has gone to\n  furthest\n\n  let // if this is furthest we got to, this is the probably cause\n  furthestPossibleErrorMessage\n\n  let // chunkified input\n  chunks\n\n  let // current chunk\n  current\n\n  let // index of current chunk, in `input`\n  currentPos\n\n  const parserInput = {}\n  const CHARCODE_SPACE = 32\n  const CHARCODE_TAB = 9\n  const CHARCODE_LF = 10\n  const CHARCODE_CR = 13\n  const CHARCODE_PLUS = 43\n  const CHARCODE_COMMA = 44\n  const CHARCODE_FORWARD_SLASH = 47\n  const CHARCODE_9 = 57\n\n  function skipWhitespace(length) {\n    const oldi = parserInput.i\n    const oldj = j\n    const curr = parserInput.i - currentPos\n    const endIndex = parserInput.i + current.length - curr\n    const mem = (parserInput.i += length)\n    const inp = input\n    let c\n    let nextChar\n    let comment\n\n    for (; parserInput.i < endIndex; parserInput.i++) {\n      c = inp.charCodeAt(parserInput.i)\n\n      if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n        nextChar = inp.charAt(parserInput.i + 1)\n        if (nextChar === '/') {\n          comment = { index: parserInput.i, isLineComment: true }\n          let nextNewLine = inp.indexOf('\\n', parserInput.i + 2)\n          if (nextNewLine < 0) {\n            nextNewLine = endIndex\n          }\n          parserInput.i = nextNewLine\n          comment.text = inp.substr(\n            comment.index,\n            parserInput.i - comment.index\n          )\n          parserInput.commentStore.push(comment)\n          continue\n        } else if (nextChar === '*') {\n          const nextStarSlash = inp.indexOf('*/', parserInput.i + 2)\n          if (nextStarSlash >= 0) {\n            comment = {\n              index: parserInput.i,\n              text: inp.substr(\n                parserInput.i,\n                nextStarSlash + 2 - parserInput.i\n              ),\n              isLineComment: false,\n            }\n            parserInput.i += comment.text.length - 1\n            parserInput.commentStore.push(comment)\n            continue\n          }\n        }\n        break\n      }\n\n      if (\n        c !== CHARCODE_SPACE &&\n        c !== CHARCODE_LF &&\n        c !== CHARCODE_TAB &&\n        c !== CHARCODE_CR\n      ) {\n        break\n      }\n    }\n\n    current = current.slice(length + parserInput.i - mem + curr)\n    currentPos = parserInput.i\n\n    if (!current.length) {\n      if (j < chunks.length - 1) {\n        current = chunks[++j]\n        skipWhitespace(0) // skip space at the beginning of a chunk\n        return true // things changed\n      }\n      parserInput.finished = true\n    }\n\n    return oldi !== parserInput.i || oldj !== j\n  }\n\n  parserInput.save = () => {\n    currentPos = parserInput.i\n    saveStack.push({ current, i: parserInput.i, j })\n  }\n  parserInput.restore = possibleErrorMessage => {\n    if (\n      parserInput.i > furthest ||\n      (parserInput.i === furthest &&\n        possibleErrorMessage &&\n        !furthestPossibleErrorMessage)\n    ) {\n      furthest = parserInput.i\n      furthestPossibleErrorMessage = possibleErrorMessage\n    }\n    const state = saveStack.pop()\n    current = state.current\n    currentPos = parserInput.i = state.i\n    j = state.j\n  }\n  parserInput.forget = () => {\n    saveStack.pop()\n  }\n  parserInput.isWhitespace = offset => {\n    const pos = parserInput.i + (offset || 0)\n    const code = input.charCodeAt(pos)\n    return (\n      code === CHARCODE_SPACE ||\n      code === CHARCODE_CR ||\n      code === CHARCODE_TAB ||\n      code === CHARCODE_LF\n    )\n  }\n\n  // Specialization of $(tok)\n  parserInput.$re = tok => {\n    if (parserInput.i > currentPos) {\n      current = current.slice(parserInput.i - currentPos)\n      currentPos = parserInput.i\n    }\n\n    const m = tok.exec(current)\n    if (!m) {\n      return null\n    }\n\n    skipWhitespace(m[0].length)\n    if (typeof m === 'string') {\n      return m\n    }\n\n    return m.length === 1 ? m[0] : m\n  }\n\n  parserInput.$char = tok => {\n    if (input.charAt(parserInput.i) !== tok) {\n      return null\n    }\n    skipWhitespace(1)\n    return tok\n  }\n\n  parserInput.$str = tok => {\n    const tokLength = tok.length\n\n    // https://jsperf.com/string-startswith/21\n    for (let i = 0; i < tokLength; i++) {\n      if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n        return null\n      }\n    }\n\n    skipWhitespace(tokLength)\n    return tok\n  }\n\n  parserInput.$quoted = () => {\n    const startChar = input.charAt(parserInput.i)\n    if (startChar !== \"'\" && startChar !== '\"') {\n      return\n    }\n    const length = input.length\n    const currentPosition = parserInput.i\n\n    for (let i = 1; i + currentPosition < length; i++) {\n      const nextChar = input.charAt(i + currentPosition)\n      switch (nextChar) {\n        case '\\\\':\n          i++\n          continue\n        case '\\r':\n        case '\\n':\n          break\n        case startChar:\n          const str = input.substr(currentPosition, i + 1)\n          skipWhitespace(i + 1)\n          return str\n        default:\n      }\n    }\n    return null\n  }\n\n  parserInput.autoCommentAbsorb = true\n  parserInput.commentStore = []\n  parserInput.finished = false\n\n  // Same as $(), but don't change the state of the parser,\n  // just return the match.\n  parserInput.peek = tok => {\n    if (typeof tok === 'string') {\n      // https://jsperf.com/string-startswith/21\n      for (let i = 0; i < tok.length; i++) {\n        if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n          return false\n        }\n      }\n      return true\n    } else {\n      return tok.test(current)\n    }\n  }\n\n  // Specialization of peek()\n  // TODO remove or change some currentChar calls to peekChar\n  parserInput.peekChar = tok => input.charAt(parserInput.i) === tok\n\n  parserInput.currentChar = () => input.charAt(parserInput.i)\n\n  parserInput.getInput = () => input\n\n  parserInput.peekNotNumeric = () => {\n    const c = input.charCodeAt(parserInput.i)\n    //Is the first char of the dimension 0-9, '.', '+' or '-'\n    return (\n      c > CHARCODE_9 ||\n      c < CHARCODE_PLUS ||\n      c === CHARCODE_FORWARD_SLASH ||\n      c === CHARCODE_COMMA\n    )\n  }\n\n  parserInput.start = (str, chunkInput, failFunction) => {\n    input = str\n    parserInput.i = j = currentPos = furthest = 0\n\n    // chunking apparently makes things quicker (but my tests indicate\n    // it might actually make things slower in node at least)\n    // and it is a non-perfect parse - it can't recognise\n    // unquoted urls, meaning it can't distinguish comments\n    // meaning comments with quotes or {}() in them get 'counted'\n    // and then lead to parse errors.\n    // In addition if the chunking chunks in the wrong place we might\n    // not be able to parse a parser statement in one go\n    // this is officially deprecated but can be switched on via an option\n    // in the case it causes too much performance issues.\n    if (chunkInput) {\n      chunks = chunker(str, failFunction)\n    } else {\n      chunks = [str]\n    }\n\n    current = chunks[0]\n\n    skipWhitespace(0)\n  }\n\n  parserInput.end = () => {\n    let message\n    const isFinished = parserInput.i >= input.length\n\n    if (parserInput.i < furthest) {\n      message = furthestPossibleErrorMessage\n      parserInput.i = furthest\n    }\n    return {\n      isFinished,\n      furthest: parserInput.i,\n      furthestPossibleErrorMessage: message,\n      furthestReachedEnd: parserInput.i >= input.length - 1,\n      furthestChar: input[parserInput.i],\n    }\n  }\n\n  return parserInput\n}\n","const LessError = require('../less-error')\nconst tree = require('../tree')\nconst visitors = require('../visitors')\nconst getParserInput = require('./parser-input')\nconst utils = require('../utils')\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//`\n//\nconst Parser = function Parser(context, imports, fileInfo) {\n  let parsers\n  const parserInput = getParserInput()\n\n  function error(msg, type) {\n    throw new LessError(\n      {\n        index: parserInput.i,\n        filename: fileInfo.filename,\n        type: type || 'Syntax',\n        message: msg,\n      },\n      imports\n    )\n  }\n\n  function expect(arg, msg, index) {\n    // some older browsers return typeof 'function' for RegExp\n    const result =\n      arg instanceof Function ? arg.call(parsers) : parserInput.$re(arg)\n    if (result) {\n      return result\n    }\n    error(\n      msg ||\n        (typeof arg === 'string'\n          ? `expected '${arg}' got '${parserInput.currentChar()}'`\n          : 'unexpected token')\n    )\n  }\n\n  // Specialization of expect()\n  function expectChar(arg, msg) {\n    if (parserInput.$char(arg)) {\n      return arg\n    }\n    error(msg || `expected '${arg}' got '${parserInput.currentChar()}'`)\n  }\n\n  function getDebugInfo(index) {\n    const filename = fileInfo.filename\n\n    return {\n      lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n      fileName: filename,\n    }\n  }\n\n  //\n  // The Parser\n  //\n  return {\n    //\n    // Parse an input string into an abstract syntax tree,\n    // @param str A string containing 'less' markup\n    // @param callback call `callback` when done.\n    // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n    //\n    parse(str, callback, additionalData) {\n      let root\n      let error = null\n      let globalVars\n      let modifyVars\n      let ignored\n      let preText = ''\n\n      globalVars =\n        additionalData && additionalData.globalVars\n          ? `${Parser.serializeVars(additionalData.globalVars)}\\n`\n          : ''\n      modifyVars =\n        additionalData && additionalData.modifyVars\n          ? `\\n${Parser.serializeVars(additionalData.modifyVars)}`\n          : ''\n\n      if (context.pluginManager) {\n        const preProcessors = context.pluginManager.getPreProcessors()\n        for (let i = 0; i < preProcessors.length; i++) {\n          str = preProcessors[i].process(str, { context, imports, fileInfo })\n        }\n      }\n\n      if (globalVars || (additionalData && additionalData.banner)) {\n        preText =\n          (additionalData && additionalData.banner\n            ? additionalData.banner\n            : '') + globalVars\n        ignored = imports.contentsIgnoredChars\n        ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0\n        ignored[fileInfo.filename] += preText.length\n      }\n\n      str = str.replace(/\\r\\n?/g, '\\n')\n      // Remove potential UTF Byte Order Mark\n      str = preText + str.replace(/^\\uFEFF/, '') + modifyVars\n      imports.contents[fileInfo.filename] = str\n\n      // Start with the primary rule.\n      // The whole syntax tree is held under a Ruleset node,\n      // with the `root` property set to true, so no `{}` are\n      // output. The callback is called when the input is parsed.\n      try {\n        parserInput.start(str, context.chunkInput, function fail(msg, index) {\n          throw new LessError(\n            {\n              index,\n              type: 'Parse',\n              message: msg,\n              filename: fileInfo.filename,\n            },\n            imports\n          )\n        })\n\n        root = new tree.Ruleset(null, this.parsers.primary())\n        root.root = true\n        root.firstRoot = true\n      } catch (e) {\n        return callback(new LessError(e, imports, fileInfo.filename))\n      }\n\n      // If `i` is smaller than the `input.length - 1`,\n      // it means the parser wasn't able to parse the whole\n      // string, so we've got a parsing error.\n      //\n      // We try to extract a \\n delimited string,\n      // showing the line where the parse error occurred.\n      // We split it up into two parts (the part which parsed,\n      // and the part which didn't), so we can color them differently.\n      const endInfo = parserInput.end()\n      if (!endInfo.isFinished) {\n        let message = endInfo.furthestPossibleErrorMessage\n\n        if (!message) {\n          message = 'Unrecognised input'\n          if (endInfo.furthestChar === '}') {\n            message += \". Possibly missing opening '{'\"\n          } else if (endInfo.furthestChar === ')') {\n            message += \". Possibly missing opening '('\"\n          } else if (endInfo.furthestReachedEnd) {\n            message += '. Possibly missing something'\n          }\n        }\n\n        error = new LessError(\n          {\n            type: 'Parse',\n            message,\n            index: endInfo.furthest,\n            filename: fileInfo.filename,\n          },\n          imports\n        )\n      }\n\n      const finish = e => {\n        e = error || e || imports.error\n\n        if (e) {\n          if (!(e instanceof LessError)) {\n            e = new LessError(e, imports, fileInfo.filename)\n          }\n\n          return callback(e)\n        } else {\n          return callback(null, root)\n        }\n      }\n\n      if (context.processImports !== false) {\n        new visitors.ImportVisitor(imports, finish).run(root)\n      } else {\n        return finish()\n      }\n    },\n\n    //\n    // Here in, the parsing rules/functions\n    //\n    // The basic structure of the syntax tree generated is as follows:\n    //\n    //   Ruleset ->  Rule -> Value -> Expression -> Entity\n    //\n    // Here's some Less code:\n    //\n    //    .class {\n    //      color: #fff;\n    //      border: 1px solid #000;\n    //      width: @w + 4px;\n    //      > .child {...}\n    //    }\n    //\n    // And here's what the parse tree might look like:\n    //\n    //     Ruleset (Selector '.class', [\n    //         Rule (\"color\",  Value ([Expression [Color #fff]]))\n    //         Rule (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n    //         Rule (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n    //         Ruleset (Selector [Element '>', '.child'], [...])\n    //     ])\n    //\n    //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n    //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n    //  first, before parsing, that's when we use `peek()`.\n    //\n    parsers: (parsers = {\n      //\n      // The `primary` rule is the *entry* and *exit* point of the parser.\n      // The rules here can appear at any level of the parse tree.\n      //\n      // The recursive nature of the grammar is an interplay between the `block`\n      // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n      // as represented by this simplified grammar:\n      //\n      //     primary  →  (ruleset | rule)+\n      //     ruleset  →  selector+ block\n      //     block    →  '{' primary '}'\n      //\n      // Only at one point is the primary rule not called from the\n      // block rule: at the root level.\n      //\n      primary() {\n        const mixin = this.mixin\n        let root = []\n        let node\n\n        while (true) {\n          while (true) {\n            node = this.comment()\n            if (!node) {\n              break\n            }\n            root.push(node)\n          }\n          // always process comments before deciding if finished\n          if (parserInput.finished) {\n            break\n          }\n          if (parserInput.peek('}')) {\n            break\n          }\n\n          node = this.extendRule()\n          if (node) {\n            root = root.concat(node)\n            continue\n          }\n\n          node =\n            mixin.definition() ||\n            this.rule() ||\n            this.ruleset() ||\n            mixin.call() ||\n            this.rulesetCall() ||\n            this.entities.call() ||\n            this.directive()\n          if (node) {\n            root.push(node)\n          } else {\n            let foundSemiColon = false\n            while (parserInput.$char(';')) {\n              foundSemiColon = true\n            }\n            if (!foundSemiColon) {\n              break\n            }\n          }\n        }\n\n        return root\n      },\n\n      // comments are collected by the main parsing mechanism and then assigned to nodes\n      // where the current structure allows it\n      comment() {\n        if (parserInput.commentStore.length) {\n          const comment = parserInput.commentStore.shift()\n          return new tree.Comment(\n            comment.text,\n            comment.isLineComment,\n            comment.index,\n            fileInfo\n          )\n        }\n      },\n\n      //\n      // Entities are tokens which can be found inside an Expression\n      //\n      entities: {\n        //\n        // A string, which supports escaping \" and '\n        //\n        //     \"milky way\" 'he\\'s the one!'\n        //\n        quoted() {\n          let str\n          const index = parserInput.i\n          let isEscaped = false\n\n          parserInput.save()\n          if (parserInput.$char('~')) {\n            isEscaped = true\n          }\n          str = parserInput.$quoted()\n          if (!str) {\n            parserInput.restore()\n            return\n          }\n          parserInput.forget()\n\n          return new tree.Quoted(\n            str.charAt(0),\n            str.substr(1, str.length - 2),\n            isEscaped,\n            index,\n            fileInfo\n          )\n        },\n\n        //\n        // A catch-all word, such as:\n        //\n        //     black border-collapse\n        //\n        keyword() {\n          const k =\n            parserInput.$char('%') ||\n            parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/)\n          if (k) {\n            return tree.Color.fromKeyword(k) || new tree.Keyword(k)\n          }\n        },\n\n        //\n        // A function call\n        //\n        //     rgb(255, 0, 255)\n        //\n        // We also try to catch IE's `alpha()`, but let the `alpha` parser\n        // deal with the details.\n        //\n        // The arguments are parsed with the `entities.arguments` parser.\n        //\n        call() {\n          let name\n          let nameLC\n          let args\n          let alpha\n          const index = parserInput.i\n\n          // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n          if (parserInput.peek(/^url\\(/i)) {\n            return\n          }\n\n          parserInput.save()\n\n          name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/)\n          if (!name) {\n            parserInput.forget()\n            return\n          }\n\n          name = name[1]\n          nameLC = name.toLowerCase()\n\n          if (nameLC === 'alpha') {\n            alpha = parsers.alpha()\n            if (alpha) {\n              parserInput.forget()\n              return alpha\n            }\n          }\n\n          args = this.arguments()\n\n          if (!parserInput.$char(')')) {\n            parserInput.restore(\"Could not parse call arguments or missing ')'\")\n            return\n          }\n\n          parserInput.forget()\n          return new tree.Call(name, args, index, fileInfo)\n        },\n        arguments() {\n          const argsSemiColon = []\n          const argsComma = []\n          let expressions = []\n          let isSemiColonSeparated\n          let value\n          let arg\n\n          parserInput.save()\n\n          while (true) {\n            arg =\n              parsers.detachedRuleset() ||\n              this.assignment() ||\n              parsers.expression()\n\n            if (!arg) {\n              break\n            }\n\n            value = arg\n\n            if (arg.value && arg.value.length == 1) {\n              value = arg.value[0]\n            }\n\n            if (value) {\n              expressions.push(value)\n            }\n\n            argsComma.push(value)\n\n            if (parserInput.$char(',')) {\n              continue\n            }\n\n            if (parserInput.$char(';') || isSemiColonSeparated) {\n              isSemiColonSeparated = true\n\n              if (expressions.length > 1) {\n                value = new tree.Value(expressions)\n              }\n              argsSemiColon.push(value)\n\n              expressions = []\n            }\n          }\n\n          parserInput.forget()\n          return isSemiColonSeparated ? argsSemiColon : argsComma\n        },\n        literal() {\n          return (\n            this.dimension() ||\n            this.color() ||\n            this.quoted() ||\n            this.unicodeDescriptor()\n          )\n        },\n\n        // Assignments are argument entities for calls.\n        // They are present in ie filter properties as shown below.\n        //\n        //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n        //\n\n        assignment() {\n          let key\n          let value\n          parserInput.save()\n          key = parserInput.$re(/^\\w+(?=\\s?=)/i)\n          if (!key) {\n            parserInput.restore()\n            return\n          }\n          if (!parserInput.$char('=')) {\n            parserInput.restore()\n            return\n          }\n          value = parsers.entity()\n          if (value) {\n            parserInput.forget()\n            return new tree.Assignment(key, value)\n          } else {\n            parserInput.restore()\n          }\n        },\n\n        //\n        // Parse url() tokens\n        //\n        // We use a specific rule for urls, because they don't really behave like\n        // standard function calls. The difference is that the argument doesn't have\n        // to be enclosed within a string, so it can't be parsed as an Expression.\n        //\n        url() {\n          let value\n          const index = parserInput.i\n\n          parserInput.autoCommentAbsorb = false\n\n          if (!parserInput.$str('url(')) {\n            parserInput.autoCommentAbsorb = true\n            return\n          }\n\n          value =\n            this.quoted() ||\n            this.variable() ||\n            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) ||\n            ''\n\n          parserInput.autoCommentAbsorb = true\n\n          expectChar(')')\n\n          return new tree.URL(\n            value.value != null || value instanceof tree.Variable\n              ? value\n              : new tree.Anonymous(value),\n            index,\n            fileInfo\n          )\n        },\n\n        //\n        // A Variable entity, such as `@fink`, in\n        //\n        //     width: @fink + 2px\n        //\n        // We use a different parser for variable definitions,\n        // see `parsers.variable`.\n        //\n        variable() {\n          let name\n          const index = parserInput.i\n\n          if (\n            parserInput.currentChar() === '@' &&\n            (name = parserInput.$re(/^@@?[\\w-]+/))\n          ) {\n            return new tree.Variable(name, index, fileInfo)\n          }\n        },\n\n        // A variable entity using the protective {} e.g. @{var}\n        variableCurly() {\n          let curly\n          const index = parserInput.i\n\n          if (\n            parserInput.currentChar() === '@' &&\n            (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))\n          ) {\n            return new tree.Variable(`@${curly[1]}`, index, fileInfo)\n          }\n        },\n\n        //\n        // A Hexadecimal color\n        //\n        //     #4F3C2F\n        //\n        // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n        //\n        color() {\n          let rgb\n\n          if (\n            parserInput.currentChar() === '#' &&\n            (rgb = parserInput.$re(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))\n          ) {\n            // strip colons, brackets, whitespaces and other characters that should not\n            // definitely be part of color string\n            let colorCandidateString = rgb.input.match(/^#([\\w]+).*/)\n            colorCandidateString = colorCandidateString[1]\n            if (!colorCandidateString.match(/^[A-Fa-f0-9]+$/)) {\n              // verify if candidate consists only of allowed HEX characters\n              error('Invalid HEX color code')\n            }\n            return new tree.Color(rgb[1], undefined, `#${colorCandidateString}`)\n          }\n        },\n\n        colorKeyword() {\n          parserInput.save()\n          const autoCommentAbsorb = parserInput.autoCommentAbsorb\n          parserInput.autoCommentAbsorb = false\n          const k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/)\n          parserInput.autoCommentAbsorb = autoCommentAbsorb\n          if (!k) {\n            parserInput.forget()\n            return\n          }\n          parserInput.restore()\n          const color = tree.Color.fromKeyword(k)\n          if (color) {\n            parserInput.$str(k)\n            return color\n          }\n        },\n\n        //\n        // A Dimension, that is, a number and a unit\n        //\n        //     0.5em 95%\n        //\n        dimension() {\n          if (parserInput.peekNotNumeric()) {\n            return\n          }\n\n          const value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i)\n          if (value) {\n            return new tree.Dimension(value[1], value[2])\n          }\n        },\n\n        //\n        // A unicode descriptor, as is used in unicode-range\n        //\n        // U+0??  or U+00A1-00A9\n        //\n        unicodeDescriptor() {\n          let ud\n\n          ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/)\n          if (ud) {\n            return new tree.UnicodeDescriptor(ud[0])\n          }\n        },\n\n        //\n        // JavaScript code to be evaluated\n        //\n        //     `window.location.href`\n        //\n        javascript() {\n          let js\n          const index = parserInput.i\n\n          parserInput.save()\n\n          const escape = parserInput.$char('~')\n          const jsQuote = parserInput.$char('`')\n\n          if (!jsQuote) {\n            parserInput.restore()\n            return\n          }\n\n          js = parserInput.$re(/^[^`]*`/)\n          if (js) {\n            parserInput.forget()\n            return new tree.JavaScript(\n              js.substr(0, js.length - 1),\n              Boolean(escape),\n              index,\n              fileInfo\n            )\n          }\n          parserInput.restore('invalid javascript definition')\n        },\n      },\n\n      //\n      // The variable part of a variable definition. Used in the `rule` parser\n      //\n      //     @fink:\n      //\n      variable() {\n        let name\n\n        if (\n          parserInput.currentChar() === '@' &&\n          (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))\n        ) {\n          return name[1]\n        }\n      },\n\n      //\n      // The variable part of a variable definition. Used in the `rule` parser\n      //\n      //     @fink();\n      //\n      rulesetCall() {\n        let name\n\n        if (\n          parserInput.currentChar() === '@' &&\n          (name = parserInput.$re(/^(@[\\w-]+)\\(\\s*\\)\\s*;/))\n        ) {\n          return new tree.RulesetCall(name[1])\n        }\n      },\n\n      //\n      // extend syntax - used to extend selectors\n      //\n      extend(isRule) {\n        let elements\n        let e\n        const index = parserInput.i\n        let option\n        let extendList\n        let extend\n\n        if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n          return\n        }\n\n        do {\n          option = null\n          elements = null\n          while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n            e = this.element()\n            if (!e) {\n              break\n            }\n            if (elements) {\n              elements.push(e)\n            } else {\n              elements = [e]\n            }\n          }\n\n          option = option && option[1]\n          if (!elements) {\n            error('Missing target selector for :extend().')\n          }\n          extend = new tree.Extend(\n            new tree.Selector(elements),\n            option,\n            index,\n            fileInfo\n          )\n          if (extendList) {\n            extendList.push(extend)\n          } else {\n            extendList = [extend]\n          }\n        } while (parserInput.$char(','))\n\n        expect(/^\\)/)\n\n        if (isRule) {\n          expect(/^;/)\n        }\n\n        return extendList\n      },\n\n      //\n      // extendRule - used in a rule to extend all the parent selectors\n      //\n      extendRule() {\n        return this.extend(true)\n      },\n\n      //\n      // Mixins\n      //\n      mixin: {\n        //\n        // A Mixin call, with an optional argument list\n        //\n        //     #mixins > .square(#fff);\n        //     .rounded(4px, black);\n        //     .button;\n        //\n        // The `while` loop is there because mixins can be\n        // namespaced, but we only support the child and descendant\n        // selector for now.\n        //\n        call() {\n          const s = parserInput.currentChar()\n          let important = false\n          const index = parserInput.i\n          let elemIndex\n          let elements\n          let elem\n          let e\n          let c\n          let args\n\n          if (s !== '.' && s !== '#') {\n            return\n          }\n\n          parserInput.save() // stop us absorbing part of an invalid selector\n\n          while (true) {\n            elemIndex = parserInput.i\n            e = parserInput.$re(\n              /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/\n            )\n            if (!e) {\n              break\n            }\n            elem = new tree.Element(c, e, elemIndex, fileInfo)\n            if (elements) {\n              elements.push(elem)\n            } else {\n              elements = [elem]\n            }\n            c = parserInput.$char('>')\n          }\n\n          if (elements) {\n            if (parserInput.$char('(')) {\n              args = this.args(true).args\n              expectChar(')')\n            }\n\n            if (parsers.important()) {\n              important = true\n            }\n\n            if (parsers.end()) {\n              parserInput.forget()\n              return new tree.mixin.Call(\n                elements,\n                args,\n                index,\n                fileInfo,\n                important\n              )\n            }\n          }\n\n          parserInput.restore()\n        },\n        args(isCall) {\n          const entities = parsers.entities\n          const returner = { args: null, variadic: false }\n          let expressions = []\n          const argsSemiColon = []\n          const argsComma = []\n          let isSemiColonSeparated\n          let expressionContainsNamed\n          let name\n          let nameLoop\n          let value\n          let arg\n          let expand\n\n          parserInput.save()\n\n          while (true) {\n            if (isCall) {\n              arg = parsers.detachedRuleset() || parsers.expression()\n            } else {\n              parserInput.commentStore.length = 0\n              if (parserInput.$str('...')) {\n                returner.variadic = true\n                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                  isSemiColonSeparated = true\n                }\n                ;(isSemiColonSeparated ? argsSemiColon : argsComma).push({\n                  variadic: true,\n                })\n                break\n              }\n              arg =\n                entities.variable() || entities.literal() || entities.keyword()\n            }\n\n            if (!arg) {\n              break\n            }\n\n            nameLoop = null\n            if (arg.throwAwayComments) {\n              arg.throwAwayComments()\n            }\n            value = arg\n            let val = null\n\n            if (isCall) {\n              // Variable\n              if (arg.value && arg.value.length == 1) {\n                val = arg.value[0]\n              }\n            } else {\n              val = arg\n            }\n\n            if (val && val instanceof tree.Variable) {\n              if (parserInput.$char(':')) {\n                if (expressions.length > 0) {\n                  if (isSemiColonSeparated) {\n                    error('Cannot mix ; and , as delimiter types')\n                  }\n                  expressionContainsNamed = true\n                }\n\n                value = parsers.detachedRuleset() || parsers.expression()\n\n                if (!value) {\n                  if (isCall) {\n                    error('could not understand value for named argument')\n                  } else {\n                    parserInput.restore()\n                    returner.args = []\n                    return returner\n                  }\n                }\n                nameLoop = name = val.name\n              } else if (parserInput.$str('...')) {\n                if (!isCall) {\n                  returner.variadic = true\n                  if (parserInput.$char(';') && !isSemiColonSeparated) {\n                    isSemiColonSeparated = true\n                  }\n                  ;(isSemiColonSeparated ? argsSemiColon : argsComma).push({\n                    name: arg.name,\n                    variadic: true,\n                  })\n                  break\n                } else {\n                  expand = true\n                }\n              } else if (!isCall) {\n                name = nameLoop = val.name\n                value = null\n              }\n            }\n\n            if (value) {\n              expressions.push(value)\n            }\n\n            argsComma.push({ name: nameLoop, value, expand })\n\n            if (parserInput.$char(',')) {\n              continue\n            }\n\n            if (parserInput.$char(';') || isSemiColonSeparated) {\n              if (expressionContainsNamed) {\n                error('Cannot mix ; and , as delimiter types')\n              }\n\n              isSemiColonSeparated = true\n\n              if (expressions.length > 1) {\n                value = new tree.Value(expressions)\n              }\n              argsSemiColon.push({ name, value, expand })\n\n              name = null\n              expressions = []\n              expressionContainsNamed = false\n            }\n          }\n\n          parserInput.forget()\n          returner.args = isSemiColonSeparated ? argsSemiColon : argsComma\n          return returner\n        },\n        //\n        // A Mixin definition, with a list of parameters\n        //\n        //     .rounded (@radius: 2px, @color) {\n        //        ...\n        //     }\n        //\n        // Until we have a finer grained state-machine, we have to\n        // do a look-ahead, to make sure we don't have a mixin call.\n        // See the `rule` function for more information.\n        //\n        // We start by matching `.rounded (`, and then proceed on to\n        // the argument list, which has optional default values.\n        // We store the parameters in `params`, with a `value` key,\n        // if there is a value, such as in the case of `@radius`.\n        //\n        // Once we've got our params list, and a closing `)`, we parse\n        // the `{...}` block.\n        //\n        definition() {\n          let name\n          let params = []\n          let match\n          let ruleset\n          let cond\n          let variadic = false\n          if (\n            (parserInput.currentChar() !== '.' &&\n              parserInput.currentChar() !== '#') ||\n            parserInput.peek(/^[^{]*\\}/)\n          ) {\n            return\n          }\n\n          parserInput.save()\n\n          match = parserInput.$re(\n            /^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/\n          )\n          if (match) {\n            name = match[1]\n\n            const argInfo = this.args(false)\n            params = argInfo.args\n            variadic = argInfo.variadic\n\n            // .mixincall(\"@{a}\");\n            // looks a bit like a mixin definition..\n            // also\n            // .mixincall(@a: {rule: set;});\n            // so we have to be nice and restore\n            if (!parserInput.$char(')')) {\n              parserInput.restore(\"Missing closing ')'\")\n              return\n            }\n\n            parserInput.commentStore.length = 0\n\n            if (parserInput.$str('when')) {\n              // Guard\n              cond = expect(parsers.conditions, 'expected condition')\n            }\n\n            ruleset = parsers.block()\n\n            if (ruleset) {\n              parserInput.forget()\n              return new tree.mixin.Definition(\n                name,\n                params,\n                ruleset,\n                cond,\n                variadic\n              )\n            } else {\n              parserInput.restore()\n            }\n          } else {\n            parserInput.forget()\n          }\n        },\n      },\n\n      //\n      // Entities are the smallest recognized token,\n      // and can be found inside a rule's value.\n      //\n      entity() {\n        const entities = this.entities\n\n        return (\n          this.comment() ||\n          entities.literal() ||\n          entities.variable() ||\n          entities.url() ||\n          entities.call() ||\n          entities.keyword() ||\n          entities.javascript()\n        )\n      },\n\n      //\n      // A Rule terminator. Note that we use `peek()` to check for '}',\n      // because the `block` rule will be expecting it, but we still need to make sure\n      // it's there, if ';' was omitted.\n      //\n      end() {\n        return parserInput.$char(';') || parserInput.peek('}')\n      },\n\n      //\n      // IE's alpha function\n      //\n      //     alpha(opacity=88)\n      //\n      alpha() {\n        let value\n\n        // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n        if (!parserInput.$re(/^opacity=/i)) {\n          return\n        }\n        value = parserInput.$re(/^\\d+/)\n        if (!value) {\n          value = expect(this.entities.variable, 'Could not parse alpha')\n        }\n        expectChar(')')\n        return new tree.Alpha(value)\n      },\n\n      //\n      // A Selector Element\n      //\n      //     div\n      //     + h1\n      //     #socks\n      //     input[type=\"text\"]\n      //\n      // Elements are the building blocks for Selectors,\n      // they are made out of a `Combinator` (see combinator rule),\n      // and an element name, such as a tag a class, or `*`.\n      //\n      element() {\n        let e\n        let c\n        let v\n        const index = parserInput.i\n\n        c = this.combinator()\n\n        e =\n          parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n          parserInput.$re(\n            /^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/\n          ) ||\n          parserInput.$char('*') ||\n          parserInput.$char('&') ||\n          this.attribute() ||\n          parserInput.$re(/^\\([^&()@]+\\)/) ||\n          parserInput.$re(/^[\\.#:](?=@)/) ||\n          this.entities.variableCurly()\n\n        if (!e) {\n          parserInput.save()\n          if (parserInput.$char('(')) {\n            if ((v = this.selector()) && parserInput.$char(')')) {\n              e = new tree.Paren(v)\n              parserInput.forget()\n            } else {\n              parserInput.restore(\"Missing closing ')'\")\n            }\n          } else {\n            parserInput.forget()\n          }\n        }\n\n        if (e) {\n          return new tree.Element(c, e, index, fileInfo)\n        }\n      },\n\n      //\n      // Combinators combine elements together, in a Selector.\n      //\n      // Because our parser isn't white-space sensitive, special care\n      // has to be taken, when parsing the descendant combinator, ` `,\n      // as it's an empty space. We have to check the previous character\n      // in the input, to see if it's a ` ` character. More info on how\n      // we deal with this in *combinator.js*.\n      //\n      combinator() {\n        let c = parserInput.currentChar()\n\n        if (c === '/') {\n          parserInput.save()\n          const slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i)\n          if (slashedCombinator) {\n            parserInput.forget()\n            return new tree.Combinator(slashedCombinator)\n          }\n          parserInput.restore()\n        }\n\n        if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n          parserInput.i++\n          if (c === '^' && parserInput.currentChar() === '^') {\n            c = '^^'\n            parserInput.i++\n          }\n          while (parserInput.isWhitespace()) {\n            parserInput.i++\n          }\n          return new tree.Combinator(c)\n        } else if (parserInput.isWhitespace(-1)) {\n          return new tree.Combinator(' ')\n        } else {\n          return new tree.Combinator(null)\n        }\n      },\n      //\n      // A CSS selector (see selector below)\n      // with less extensions e.g. the ability to extend and guard\n      //\n      lessSelector() {\n        return this.selector(true)\n      },\n      //\n      // A CSS Selector\n      //\n      //     .class > div + h1\n      //     li a:hover\n      //\n      // Selectors are made out of one or more Elements, see above.\n      //\n      selector(isLess) {\n        const index = parserInput.i\n        let elements\n        let extendList\n        let c\n        let e\n        let allExtends\n        let when\n        let condition\n\n        while (\n          (isLess && (extendList = this.extend())) ||\n          (isLess && (when = parserInput.$str('when'))) ||\n          (e = this.element())\n        ) {\n          if (when) {\n            condition = expect(this.conditions, 'expected condition')\n          } else if (condition) {\n            error('CSS guard can only be used at the end of selector')\n          } else if (extendList) {\n            if (allExtends) {\n              allExtends = allExtends.concat(extendList)\n            } else {\n              allExtends = extendList\n            }\n          } else {\n            if (allExtends) {\n              error('Extend can only be used at the end of selector')\n            }\n            c = parserInput.currentChar()\n            if (elements) {\n              elements.push(e)\n            } else {\n              elements = [e]\n            }\n            e = null\n          }\n          if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n            break\n          }\n        }\n\n        if (elements) {\n          return new tree.Selector(\n            elements,\n            allExtends,\n            condition,\n            index,\n            fileInfo\n          )\n        }\n        if (allExtends) {\n          error(\n            'Extend must be used to extend a selector, it cannot be used on its own'\n          )\n        }\n      },\n      attribute() {\n        if (!parserInput.$char('[')) {\n          return\n        }\n\n        const entities = this.entities\n        let key\n        let val\n        let op\n\n        if (!(key = entities.variableCurly())) {\n          key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/)\n        }\n\n        op = parserInput.$re(/^[|~*$^]?=/)\n        if (op) {\n          val =\n            entities.quoted() ||\n            parserInput.$re(/^[0-9]+%/) ||\n            parserInput.$re(/^[\\w-]+/) ||\n            entities.variableCurly()\n        }\n\n        expectChar(']')\n\n        return new tree.Attribute(key, op, val)\n      },\n\n      //\n      // The `block` rule is used by `ruleset` and `mixin.definition`.\n      // It's a wrapper around the `primary` rule, with added `{}`.\n      //\n      block() {\n        let content\n        if (\n          parserInput.$char('{') &&\n          (content = this.primary()) &&\n          parserInput.$char('}')\n        ) {\n          return content\n        }\n      },\n\n      blockRuleset() {\n        let block = this.block()\n\n        if (block) {\n          block = new tree.Ruleset(null, block)\n        }\n        return block\n      },\n\n      detachedRuleset() {\n        const blockRuleset = this.blockRuleset()\n        if (blockRuleset) {\n          return new tree.DetachedRuleset(blockRuleset)\n        }\n      },\n\n      //\n      // div, .class, body > p {...}\n      //\n      ruleset() {\n        let selectors\n        let s\n        let rules\n        let debugInfo\n\n        parserInput.save()\n\n        if (context.dumpLineNumbers) {\n          debugInfo = getDebugInfo(parserInput.i)\n        }\n\n        while (true) {\n          s = this.lessSelector()\n          if (!s) {\n            break\n          }\n          if (selectors) {\n            selectors.push(s)\n          } else {\n            selectors = [s]\n          }\n          parserInput.commentStore.length = 0\n          if (s.condition && selectors.length > 1) {\n            error('Guards are only currently allowed on a single selector.')\n          }\n          if (!parserInput.$char(',')) {\n            break\n          }\n          if (s.condition) {\n            error('Guards are only currently allowed on a single selector.')\n          }\n          parserInput.commentStore.length = 0\n        }\n\n        if (selectors && (rules = this.block())) {\n          parserInput.forget()\n          const ruleset = new tree.Ruleset(\n            selectors,\n            rules,\n            context.strictImports\n          )\n          if (context.dumpLineNumbers) {\n            ruleset.debugInfo = debugInfo\n          }\n          return ruleset\n        } else {\n          parserInput.restore()\n        }\n      },\n      rule(tryAnonymous) {\n        let name\n        let value\n        const startOfRule = parserInput.i\n        const c = parserInput.currentChar()\n        let important\n        let merge\n        let isVariable\n\n        if (c === '.' || c === '#' || c === '&' || c === ':') {\n          return\n        }\n\n        parserInput.save()\n\n        name = this.variable() || this.ruleProperty()\n        if (name) {\n          isVariable = typeof name === 'string'\n\n          if (isVariable) {\n            value = this.detachedRuleset()\n          }\n\n          parserInput.commentStore.length = 0\n          if (!value) {\n            // a name returned by this.ruleProperty() is always an array of the form:\n            // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n            // where each item is a tree.Keyword or tree.Variable\n            merge = !isVariable && name.length > 1 && name.pop().value\n\n            // prefer to try to parse first if its a variable or we are compressing\n            // but always fallback on the other one\n            const tryValueFirst =\n              !tryAnonymous && (context.compress || isVariable)\n\n            if (tryValueFirst) {\n              value = this.value()\n            }\n            if (!value) {\n              value = this.anonymousValue()\n              if (value) {\n                parserInput.forget()\n                // anonymous values absorb the end ';' which is required for them to work\n                return new tree.Rule(\n                  name,\n                  value,\n                  false,\n                  merge,\n                  startOfRule,\n                  fileInfo\n                )\n              }\n            }\n            if (!tryValueFirst && !value) {\n              value = this.value()\n            }\n\n            important = this.important()\n          }\n\n          if (value && this.end()) {\n            parserInput.forget()\n            return new tree.Rule(\n              name,\n              value,\n              important,\n              merge,\n              startOfRule,\n              fileInfo\n            )\n          } else {\n            parserInput.restore()\n            if (value && !tryAnonymous) {\n              return this.rule(true)\n            }\n          }\n        } else {\n          parserInput.forget()\n        }\n      },\n      anonymousValue() {\n        const match = parserInput.$re(/^([^@+\\/'\"*`(;{}-]*);/)\n        if (match) {\n          return new tree.Anonymous(match[1])\n        }\n      },\n\n      //\n      // An @import directive\n      //\n      //     @import \"lib\";\n      //\n      // Depending on our environment, importing is done differently:\n      // In the browser, it's an XHR request, in Node, it would be a\n      // file-system operation. The function used for importing is\n      // stored in `import`, which we pass to the Import constructor.\n      //\n      import: function() {\n        let path\n        let features\n        const index = parserInput.i\n\n        const dir = parserInput.$re(/^@import?\\s+/)\n\n        if (dir) {\n          const options = (dir ? this.importOptions() : null) || {}\n\n          if ((path = this.entities.quoted() || this.entities.url())) {\n            features = this.mediaFeatures()\n\n            if (!parserInput.$char(';')) {\n              parserInput.i = index\n              error(\n                'missing semi-colon or unrecognised media features on import'\n              )\n            }\n            features = features && new tree.Value(features)\n            return new tree.Import(path, features, options, index, fileInfo)\n          } else {\n            parserInput.i = index\n            error('malformed import statement')\n          }\n        }\n      },\n\n      importOptions() {\n        let o\n        const options = {}\n        let optionName\n        let value\n\n        // list of options, surrounded by parens\n        if (!parserInput.$char('(')) {\n          return null\n        }\n        do {\n          o = this.importOption()\n          if (o) {\n            optionName = o\n            value = true\n            switch (optionName) {\n              case 'css':\n                optionName = 'less'\n                value = false\n                break\n              case 'once':\n                optionName = 'multiple'\n                value = false\n                break\n            }\n            options[optionName] = value\n            if (!parserInput.$char(',')) {\n              break\n            }\n          }\n        } while (o)\n        expectChar(')')\n        return options\n      },\n\n      importOption() {\n        const opt = parserInput.$re(\n          /^(less|css|multiple|once|inline|reference|optional)/\n        )\n        if (opt) {\n          return opt[1]\n        }\n      },\n\n      mediaFeature() {\n        const entities = this.entities\n        const nodes = []\n        let e\n        let p\n        parserInput.save()\n        do {\n          e = entities.keyword() || entities.variable()\n          if (e) {\n            nodes.push(e)\n          } else if (parserInput.$char('(')) {\n            p = this.property()\n            e = this.value()\n            if (parserInput.$char(')')) {\n              if (p && e) {\n                nodes.push(\n                  new tree.Paren(\n                    new tree.Rule(\n                      p,\n                      e,\n                      null,\n                      null,\n                      parserInput.i,\n                      fileInfo,\n                      true\n                    )\n                  )\n                )\n              } else if (e) {\n                nodes.push(new tree.Paren(e))\n              } else {\n                error('badly formed media feature definition')\n              }\n            } else {\n              error(\"Missing closing ')'\", 'Parse')\n            }\n          }\n        } while (e)\n\n        parserInput.forget()\n        if (nodes.length > 0) {\n          return new tree.Expression(nodes)\n        }\n      },\n\n      mediaFeatures() {\n        const entities = this.entities\n        const features = []\n        let e\n        do {\n          e = this.mediaFeature()\n          if (e) {\n            features.push(e)\n            if (!parserInput.$char(',')) {\n              break\n            }\n          } else {\n            e = entities.variable()\n            if (e) {\n              features.push(e)\n              if (!parserInput.$char(',')) {\n                break\n              }\n            }\n          }\n        } while (e)\n\n        return features.length > 0 ? features : null\n      },\n\n      media() {\n        let features\n        let rules\n        let media\n        let debugInfo\n        const index = parserInput.i\n\n        if (context.dumpLineNumbers) {\n          debugInfo = getDebugInfo(index)\n        }\n\n        parserInput.save()\n\n        if (parserInput.$str('@media')) {\n          features = this.mediaFeatures()\n\n          rules = this.block()\n\n          if (!rules) {\n            error(\n              'media definitions require block statements after any features'\n            )\n          }\n\n          parserInput.forget()\n\n          media = new tree.Media(rules, features, index, fileInfo)\n          if (context.dumpLineNumbers) {\n            media.debugInfo = debugInfo\n          }\n\n          return media\n        }\n\n        parserInput.restore()\n      },\n\n      //\n      // A @plugin directive, used to import compiler extensions dynamically.\n      //\n      //     @plugin \"lib\";\n      //\n      // Depending on our environment, importing is done differently:\n      // In the browser, it's an XHR request, in Node, it would be a\n      // file-system operation. The function used for importing is\n      // stored in `import`, which we pass to the Import constructor.\n      //\n      plugin() {\n        let path\n        const index = parserInput.i\n        const dir = parserInput.$re(/^@plugin?\\s+/)\n\n        if (dir) {\n          const options = { plugin: true }\n\n          if ((path = this.entities.quoted() || this.entities.url())) {\n            if (!parserInput.$char(';')) {\n              parserInput.i = index\n              error('missing semi-colon on plugin')\n            }\n\n            return new tree.Import(path, null, options, index, fileInfo)\n          } else {\n            parserInput.i = index\n            error('malformed plugin statement')\n          }\n        }\n      },\n\n      //\n      // A CSS Directive\n      //\n      //     @charset \"utf-8\";\n      //\n      directive() {\n        const index = parserInput.i\n        let name\n        let value\n        let rules\n        let nonVendorSpecificName\n        let hasIdentifier\n        let hasExpression\n        let hasUnknown\n        let hasBlock = true\n        let isRooted = true\n\n        if (parserInput.currentChar() !== '@') {\n          return\n        }\n\n        value = this['import']() || this.plugin() || this.media()\n        if (value) {\n          return value\n        }\n\n        parserInput.save()\n\n        name = parserInput.$re(/^@[a-z-]+/)\n\n        if (!name) {\n          return\n        }\n\n        nonVendorSpecificName = name\n        if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n          nonVendorSpecificName = `@${name.slice(name.indexOf('-', 2) + 1)}`\n        }\n\n        switch (nonVendorSpecificName) {\n          case '@charset':\n            hasIdentifier = true\n            hasBlock = false\n            break\n          case '@namespace':\n            hasExpression = true\n            hasBlock = false\n            break\n          case '@keyframes':\n          case '@counter-style':\n            hasIdentifier = true\n            break\n          case '@document':\n          case '@supports':\n            hasUnknown = true\n            isRooted = false\n            break\n          default:\n            hasUnknown = true\n            break\n        }\n\n        parserInput.commentStore.length = 0\n\n        if (hasIdentifier) {\n          value = this.entity()\n          if (!value) {\n            error(`expected ${name} identifier`)\n          }\n        } else if (hasExpression) {\n          value = this.expression()\n          if (!value) {\n            error(`expected ${name} expression`)\n          }\n        } else if (hasUnknown) {\n          value = (parserInput.$re(/^[^{;]+/) || '').trim()\n          hasBlock = parserInput.currentChar() == '{'\n          if (value) {\n            value = new tree.Anonymous(value)\n          }\n        }\n\n        if (hasBlock) {\n          rules = this.blockRuleset()\n        }\n\n        if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n          parserInput.forget()\n          return new tree.Directive(\n            name,\n            value,\n            rules,\n            index,\n            fileInfo,\n            context.dumpLineNumbers ? getDebugInfo(index) : null,\n            isRooted\n          )\n        }\n\n        parserInput.restore('directive options not recognised')\n      },\n\n      //\n      // A Value is a comma-delimited list of Expressions\n      //\n      //     font-family: Baskerville, Georgia, serif;\n      //\n      // In a Rule, a Value represents everything after the `:`,\n      // and before the `;`.\n      //\n      value() {\n        let e\n        const expressions = []\n\n        do {\n          e = this.expression()\n          if (e) {\n            expressions.push(e)\n            if (!parserInput.$char(',')) {\n              break\n            }\n          }\n        } while (e)\n\n        if (expressions.length > 0) {\n          return new tree.Value(expressions)\n        }\n      },\n      important() {\n        if (parserInput.currentChar() === '!') {\n          return parserInput.$re(/^! *important/)\n        }\n      },\n      sub() {\n        let a\n        let e\n\n        parserInput.save()\n        if (parserInput.$char('(')) {\n          a = this.addition()\n          if (a && parserInput.$char(')')) {\n            parserInput.forget()\n            e = new tree.Expression([a])\n            e.parens = true\n            return e\n          }\n          parserInput.restore(\"Expected ')'\")\n          return\n        }\n        parserInput.restore()\n      },\n      multiplication() {\n        let m\n        let a\n        let op\n        let operation\n        let isSpaced\n        m = this.operand()\n        if (m) {\n          isSpaced = parserInput.isWhitespace(-1)\n          while (true) {\n            if (parserInput.peek(/^\\/[*\\/]/)) {\n              break\n            }\n\n            parserInput.save()\n\n            op = parserInput.$char('/') || parserInput.$char('*')\n\n            if (!op) {\n              parserInput.forget()\n              break\n            }\n\n            a = this.operand()\n\n            if (!a) {\n              parserInput.restore()\n              break\n            }\n            parserInput.forget()\n\n            m.parensInOp = true\n            a.parensInOp = true\n            operation = new tree.Operation(op, [operation || m, a], isSpaced)\n            isSpaced = parserInput.isWhitespace(-1)\n          }\n          return operation || m\n        }\n      },\n      addition() {\n        let m\n        let a\n        let op\n        let operation\n        let isSpaced\n        m = this.multiplication()\n        if (m) {\n          isSpaced = parserInput.isWhitespace(-1)\n          while (true) {\n            op =\n              parserInput.$re(/^[-+]\\s+/) ||\n              (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')))\n            if (!op) {\n              break\n            }\n            a = this.multiplication()\n            if (!a) {\n              break\n            }\n\n            m.parensInOp = true\n            a.parensInOp = true\n            operation = new tree.Operation(op, [operation || m, a], isSpaced)\n            isSpaced = parserInput.isWhitespace(-1)\n          }\n          return operation || m\n        }\n      },\n      conditions() {\n        let a\n        let b\n        const index = parserInput.i\n        let condition\n\n        a = this.condition()\n        if (a) {\n          while (true) {\n            if (\n              !parserInput.peek(/^,\\s*(not\\s*)?\\(/) ||\n              !parserInput.$char(',')\n            ) {\n              break\n            }\n            b = this.condition()\n            if (!b) {\n              break\n            }\n            condition = new tree.Condition('or', condition || a, b, index)\n          }\n          return condition || a\n        }\n      },\n      condition() {\n        let result\n        let logical\n        let next\n        function or() {\n          return parserInput.$str('or')\n        }\n\n        result = this.conditionAnd(this)\n        if (!result) {\n          return\n        }\n        logical = or()\n        if (logical) {\n          next = this.condition()\n          if (next) {\n            result = new tree.Condition(logical, result, next)\n          } else {\n            return\n          }\n        }\n        return result\n      },\n      conditionAnd() {\n        let result\n        let logical\n        let next\n        function insideCondition(me) {\n          return me.negatedCondition() || me.parenthesisCondition()\n        }\n        function and() {\n          return parserInput.$str('and')\n        }\n\n        result = insideCondition(this)\n        if (!result) {\n          return\n        }\n        logical = and()\n        if (logical) {\n          next = this.conditionAnd()\n          if (next) {\n            result = new tree.Condition(logical, result, next)\n          } else {\n            return\n          }\n        }\n        return result\n      },\n      negatedCondition() {\n        if (parserInput.$str('not')) {\n          const result = this.parenthesisCondition()\n          if (result) {\n            result.negate = !result.negate\n          }\n          return result\n        }\n      },\n      parenthesisCondition() {\n        function tryConditionFollowedByParenthesis(me) {\n          let body\n          parserInput.save()\n          body = me.condition()\n          if (!body) {\n            parserInput.restore()\n            return\n          }\n          if (!parserInput.$char(')')) {\n            parserInput.restore()\n            return\n          }\n          parserInput.forget()\n          return body\n        }\n\n        let body\n        parserInput.save()\n        if (!parserInput.$str('(')) {\n          parserInput.restore()\n          return\n        }\n        body = tryConditionFollowedByParenthesis(this)\n        if (body) {\n          parserInput.forget()\n          return body\n        }\n\n        body = this.atomicCondition()\n        if (!body) {\n          parserInput.restore()\n          return\n        }\n        if (!parserInput.$char(')')) {\n          parserInput.restore(`expected ')' got '${parserInput.currentChar()}'`)\n          return\n        }\n        parserInput.forget()\n        return body\n      },\n      atomicCondition() {\n        const entities = this.entities\n        const index = parserInput.i\n        let a\n        let b\n        let c\n        let op\n\n        a = this.addition() || entities.keyword() || entities.quoted()\n        if (a) {\n          if (parserInput.$char('>')) {\n            if (parserInput.$char('=')) {\n              op = '>='\n            } else {\n              op = '>'\n            }\n          } else if (parserInput.$char('<')) {\n            if (parserInput.$char('=')) {\n              op = '<='\n            } else {\n              op = '<'\n            }\n          } else if (parserInput.$char('=')) {\n            if (parserInput.$char('>')) {\n              op = '=>'\n            } else if (parserInput.$char('<')) {\n              op = '=<'\n            } else {\n              op = '='\n            }\n          }\n          if (op) {\n            b = this.addition() || entities.keyword() || entities.quoted()\n            if (b) {\n              c = new tree.Condition(op, a, b, index, false)\n            } else {\n              error('expected expression')\n            }\n          } else {\n            c = new tree.Condition(\n              '=',\n              a,\n              new tree.Keyword('true'),\n              index,\n              false\n            )\n          }\n          return c\n        }\n      },\n\n      //\n      // An operand is anything that can be part of an operation,\n      // such as a Color, or a Variable\n      //\n      operand() {\n        const entities = this.entities\n        let negate\n\n        if (parserInput.peek(/^-[@\\(]/)) {\n          negate = parserInput.$char('-')\n        }\n\n        let o =\n          this.sub() ||\n          entities.dimension() ||\n          entities.color() ||\n          entities.variable() ||\n          entities.call() ||\n          entities.colorKeyword()\n\n        if (negate) {\n          o.parensInOp = true\n          o = new tree.Negative(o)\n        }\n\n        return o\n      },\n\n      //\n      // Expressions either represent mathematical operations,\n      // or white-space delimited Entities.\n      //\n      //     1px solid black\n      //     @var * 2\n      //\n      expression() {\n        const entities = []\n        let e\n        let delim\n\n        do {\n          e = this.comment()\n          if (e) {\n            entities.push(e)\n            continue\n          }\n          e = this.addition() || this.entity()\n          if (e) {\n            entities.push(e)\n            // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n            if (!parserInput.peek(/^\\/[\\/*]/)) {\n              delim = parserInput.$char('/')\n              if (delim) {\n                entities.push(new tree.Anonymous(delim))\n              }\n            }\n          }\n        } while (e)\n        if (entities.length > 0) {\n          return new tree.Expression(entities)\n        }\n      },\n      property() {\n        const name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/)\n        if (name) {\n          return name[1]\n        }\n      },\n      ruleProperty() {\n        let name = []\n        const index = []\n        let s\n        let k\n\n        parserInput.save()\n\n        const simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/)\n        if (simpleProperty) {\n          name = [new tree.Keyword(simpleProperty[1])]\n          parserInput.forget()\n          return name\n        }\n\n        function match(re) {\n          const i = parserInput.i\n          const chunk = parserInput.$re(re)\n          if (chunk) {\n            index.push(i)\n            return name.push(chunk[1])\n          }\n        }\n\n        match(/^(\\*?)/)\n        while (true) {\n          if (!match(/^((?:[\\w-]+)|(?:@\\{[\\w-]+\\}))/)) {\n            break\n          }\n        }\n\n        if (name.length > 1 && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n          parserInput.forget()\n\n          // at last, we have the complete match now. move forward,\n          // convert name particles to tree objects and return:\n          if (name[0] === '') {\n            name.shift()\n            index.shift()\n          }\n          for (k = 0; k < name.length; k++) {\n            s = name[k]\n            name[k] =\n              s.charAt(0) !== '@'\n                ? new tree.Keyword(s)\n                : new tree.Variable(`@${s.slice(2, -1)}`, index[k], fileInfo)\n          }\n          return name\n        }\n        parserInput.restore()\n      },\n    }),\n  }\n}\nParser.serializeVars = vars => {\n  let s = ''\n\n  for (const name in vars) {\n    if (Object.hasOwnProperty.call(vars, name)) {\n      const value = vars[name]\n      s += `${(name[0] === '@' ? '' : '@') + name}: ${value}${\n        String(value).slice(-1) === ';' ? '' : ';'\n      }`\n    }\n  }\n\n  return s\n}\n\nmodule.exports = Parser\n","const LessError = require('../less-error')\nconst tree = require('../tree')\n\nconst FunctionImporter = (module.exports = function FunctionImporter(\n  context,\n  fileInfo\n) {\n  this.fileInfo = fileInfo\n})\n\nFunctionImporter.prototype.eval = function(contents, callback) {\n  const loaded = {}\n  let loader\n  let registry\n\n  registry = {\n    add(name, func) {\n      loaded[name] = func\n    },\n    addMultiple(functions) {\n      Object.keys(functions).forEach(name => {\n        loaded[name] = functions[name]\n      })\n    },\n  }\n\n  try {\n    loader = new Function('functions', 'tree', 'fileInfo', contents)\n    loader(registry, tree, this.fileInfo)\n  } catch (e) {\n    callback(\n      new LessError({\n        message: `Plugin evaluation error: '${e.name}: ${e.message.replace(\n          /[\"]/g,\n          \"'\"\n        )}'`,\n        filename: this.fileInfo.filename,\n      }),\n      null\n    )\n  }\n\n  callback(null, { functions: loaded })\n}\n","const contexts = require('./contexts')\nconst Parser = require('./parser/parser')\nconst FunctionImporter = require('./plugins/function-importer')\n\nmodule.exports = environment => {\n  // FileInfo = {\n  //  'relativeUrls' - option - whether to adjust URL's to be relative\n  //  'filename' - full resolved filename of current file\n  //  'rootpath' - path to append to normal URLs for this node\n  //  'currentDirectory' - path to the current file, absolute\n  //  'rootFilename' - filename of the base file\n  //  'entryPath' - absolute path to the entry file\n  //  'reference' - whether the file should not be output and only output parts that are referenced\n\n  class ImportManager {\n    constructor(context, rootFileInfo) {\n      this.rootFilename = rootFileInfo.filename\n      this.paths = context.paths || [] // Search paths, when importing\n      this.contents = {} // map - filename to contents of all the files\n      this.contentsIgnoredChars = {} // map - filename to lines at the beginning of each file to ignore\n      this.mime = context.mime\n      this.error = null\n      this.context = context\n      // Deprecated? Unused outside of here, could be useful.\n      this.queue = [] // Files which haven't been imported yet\n      this.files = {} // Holds the imported parse trees.\n    }\n\n    /**\n     * Add an import to be imported\n     * @param path - the raw path\n     * @param tryAppendLessExtension - whether to try appending the less extension (if the path has no extension)\n     * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n     * @param importOptions - import options\n     * @param callback - callback for when it is imported\n     */\n    push(\n      path,\n      tryAppendLessExtension,\n      currentFileInfo,\n      importOptions,\n      callback\n    ) {\n      const importManager = this\n      this.queue.push(path)\n\n      const fileParsedFunc = (e, root, fullPath) => {\n        importManager.queue.splice(importManager.queue.indexOf(path), 1) // Remove the path from the queue\n\n        const importedEqualsRoot = fullPath === importManager.rootFilename\n        if (importOptions.optional && e) {\n          callback(null, { rules: [] }, false, null)\n        } else {\n          importManager.files[fullPath] = root\n          if (e && !importManager.error) {\n            importManager.error = e\n          }\n          callback(e, root, importedEqualsRoot, fullPath)\n        }\n      }\n\n      const newFileInfo = {\n        relativeUrls: this.context.relativeUrls,\n        entryPath: currentFileInfo.entryPath,\n        rootpath: currentFileInfo.rootpath,\n        rootFilename: currentFileInfo.rootFilename,\n      }\n\n      const fileManager = environment.getFileManager(\n        path,\n        currentFileInfo.currentDirectory,\n        this.context,\n        environment\n      )\n\n      if (!fileManager) {\n        fileParsedFunc({ message: `Could not find a file-manager for ${path}` })\n        return\n      }\n\n      if (tryAppendLessExtension) {\n        path = fileManager.tryAppendExtension(\n          path,\n          importOptions.plugin ? '.js' : '.less'\n        )\n      }\n\n      const loadFileCallback = loadedFile => {\n        const resolvedFilename = loadedFile.filename\n        const contents = loadedFile.contents.replace(/^\\uFEFF/, '')\n\n        // Pass on an updated rootpath if path of imported file is relative and file\n        // is in a (sub|sup) directory\n        //\n        // Examples:\n        // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n        //   then rootpath should become 'less/module/nav/'\n        // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n        //   then rootpath should become 'less/../'\n        newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename)\n        if (newFileInfo.relativeUrls) {\n          newFileInfo.rootpath = fileManager.join(\n            importManager.context.rootpath || '',\n            fileManager.pathDiff(\n              newFileInfo.currentDirectory,\n              newFileInfo.entryPath\n            )\n          )\n\n          if (\n            !fileManager.isPathAbsolute(newFileInfo.rootpath) &&\n            fileManager.alwaysMakePathsAbsolute()\n          ) {\n            newFileInfo.rootpath = fileManager.join(\n              newFileInfo.entryPath,\n              newFileInfo.rootpath\n            )\n          }\n        }\n        newFileInfo.filename = resolvedFilename\n\n        const newEnv = new contexts.Parse(importManager.context)\n\n        newEnv.processImports = false\n        importManager.contents[resolvedFilename] = contents\n\n        if (currentFileInfo.reference || importOptions.reference) {\n          newFileInfo.reference = true\n        }\n\n        if (importOptions.plugin) {\n          new FunctionImporter(newEnv, newFileInfo).eval(\n            contents,\n            (e, root) => {\n              fileParsedFunc(e, root, resolvedFilename)\n            }\n          )\n        } else if (importOptions.inline) {\n          fileParsedFunc(null, contents, resolvedFilename)\n        } else {\n          new Parser(newEnv, importManager, newFileInfo).parse(\n            contents,\n            (e, root) => {\n              fileParsedFunc(e, root, resolvedFilename)\n            }\n          )\n        }\n      }\n\n      const promise = fileManager.loadFile(\n        path,\n        currentFileInfo.currentDirectory,\n        this.context,\n        environment,\n        (err, loadedFile) => {\n          if (err) {\n            fileParsedFunc(err)\n          } else {\n            loadFileCallback(loadedFile)\n          }\n        }\n      )\n      if (promise) {\n        promise.then(loadFileCallback, fileParsedFunc)\n      }\n    }\n  }\n\n  return ImportManager\n}\n","module.exports = {\n  colors: require('./colors'),\n  unitConversions: require('./unit-conversions'),\n}\n","class abstractFileManager {\n  getPath(filename) {\n    let j = filename.lastIndexOf('?')\n    if (j > 0) {\n      filename = filename.slice(0, j)\n    }\n    j = filename.lastIndexOf('/')\n    if (j < 0) {\n      j = filename.lastIndexOf('\\\\')\n    }\n    if (j < 0) {\n      return ''\n    }\n    return filename.slice(0, j + 1)\n  }\n\n  tryAppendExtension(path, ext) {\n    return /(\\.[a-z]*$)|([\\?;].*)$/.test(path) ? path : path + ext\n  }\n\n  tryAppendLessExtension(path) {\n    return this.tryAppendExtension(path, '.less')\n  }\n\n  supportsSync() {\n    return false\n  }\n\n  alwaysMakePathsAbsolute() {\n    return false\n  }\n\n  isPathAbsolute(filename) {\n    return /^(?:[a-z-]+:|\\/|\\\\|#)/i.test(filename)\n  }\n\n  join(basePath, laterPath) {\n    if (!basePath) {\n      return laterPath\n    }\n    return basePath + laterPath\n  }\n\n  pathDiff(url, baseUrl) {\n    // diff between two paths to create a relative path\n\n    const urlParts = this.extractUrlParts(url)\n\n    const baseUrlParts = this.extractUrlParts(baseUrl)\n    let i\n    let max\n    let urlDirectories\n    let baseUrlDirectories\n    let diff = ''\n    if (urlParts.hostPart !== baseUrlParts.hostPart) {\n      return ''\n    }\n    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length)\n    for (i = 0; i < max; i++) {\n      if (baseUrlParts.directories[i] !== urlParts.directories[i]) {\n        break\n      }\n    }\n    baseUrlDirectories = baseUrlParts.directories.slice(i)\n    urlDirectories = urlParts.directories.slice(i)\n    for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n      diff += '../'\n    }\n    for (i = 0; i < urlDirectories.length - 1; i++) {\n      diff += `${urlDirectories[i]}/`\n    }\n    return diff\n  }\n\n  // helper function, not part of API\n  extractUrlParts(url, baseUrl) {\n    // urlParts[1] = protocol://hostname/ OR /\n    // urlParts[2] = / if path relative to host base\n    // urlParts[3] = directories\n    // urlParts[4] = filename\n    // urlParts[5] = parameters\n\n    const urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i\n\n    const urlParts = url.match(urlPartsRegex)\n    const returner = {}\n    let directories = []\n    let i\n    let baseUrlParts\n\n    if (!urlParts) {\n      throw new Error(`Could not parse sheet href - '${url}'`)\n    }\n\n    // Stylesheets in IE don't always return the full path\n    if (baseUrl && (!urlParts[1] || urlParts[2])) {\n      baseUrlParts = baseUrl.match(urlPartsRegex)\n      if (!baseUrlParts) {\n        throw new Error(`Could not parse page url - '${baseUrl}'`)\n      }\n      urlParts[1] = urlParts[1] || baseUrlParts[1] || ''\n      if (!urlParts[2]) {\n        urlParts[3] = baseUrlParts[3] + urlParts[3]\n      }\n    }\n\n    if (urlParts[3]) {\n      directories = urlParts[3].replace(/\\\\/g, '/').split('/')\n\n      // extract out . before .. so .. doesn't absorb a non-directory\n      for (i = 0; i < directories.length; i++) {\n        if (directories[i] === '.') {\n          directories.splice(i, 1)\n          i -= 1\n        }\n      }\n\n      for (i = 0; i < directories.length; i++) {\n        if (directories[i] === '..' && i > 0) {\n          directories.splice(i - 1, 2)\n          i -= 2\n        }\n      }\n    }\n\n    returner.hostPart = urlParts[1]\n    returner.directories = directories\n    returner.path = (urlParts[1] || '') + directories.join('/')\n    returner.fileUrl = returner.path + (urlParts[4] || '')\n    returner.url = returner.fileUrl + (urlParts[5] || '')\n    return returner\n  }\n}\n\nmodule.exports = abstractFileManager\n","const Dimension = require('../tree/dimension')\nconst Color = require('../tree/color')\nconst Quoted = require('../tree/quoted')\nconst Anonymous = require('../tree/anonymous')\nconst functionRegistry = require('./function-registry')\nlet colorFunctions\n\nfunction clamp(val) {\n  return Math.min(1, Math.max(0, val))\n}\nfunction hsla(color) {\n  return colorFunctions.hsla(color.h, color.s, color.l, color.a)\n}\nfunction number(n) {\n  if (n instanceof Dimension) {\n    return parseFloat(n.unit.is('%') ? n.value / 100 : n.value)\n  } else if (typeof n === 'number') {\n    return n\n  } else {\n    throw {\n      type: 'Argument',\n      message: 'color functions take numbers as parameters',\n    }\n  }\n}\nfunction scaled(n, size) {\n  if (n instanceof Dimension && n.unit.is('%')) {\n    return parseFloat(n.value * size / 100)\n  } else {\n    return number(n)\n  }\n}\ncolorFunctions = {\n  rgb(r, g, b) {\n    return colorFunctions.rgba(r, g, b, 1.0)\n  },\n  rgba(r, g, b, a) {\n    const rgb = [r, g, b].map(c => scaled(c, 255))\n    a = number(a)\n    return new Color(rgb, a)\n  },\n  hsl(h, s, l) {\n    return colorFunctions.hsla(h, s, l, 1.0)\n  },\n  hsla(h, s, l, a) {\n    let m1\n    let m2\n\n    function hue(h) {\n      h = h < 0 ? h + 1 : h > 1 ? h - 1 : h\n      if (h * 6 < 1) {\n        return m1 + (m2 - m1) * h * 6\n      } else if (h * 2 < 1) {\n        return m2\n      } else if (h * 3 < 2) {\n        return m1 + (m2 - m1) * (2 / 3 - h) * 6\n      } else {\n        return m1\n      }\n    }\n\n    h = (number(h) % 360) / 360\n    s = clamp(number(s))\n    l = clamp(number(l))\n    a = clamp(number(a))\n\n    m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s\n    m1 = l * 2 - m2\n\n    return colorFunctions.rgba(\n      hue(h + 1 / 3) * 255,\n      hue(h) * 255,\n      hue(h - 1 / 3) * 255,\n      a\n    )\n  },\n\n  hsv(h, s, v) {\n    return colorFunctions.hsva(h, s, v, 1.0)\n  },\n\n  hsva(h, s, v, a) {\n    h = (number(h) % 360) / 360 * 360\n    s = number(s)\n    v = number(v)\n    a = number(a)\n\n    let i\n    let f\n    i = Math.floor((h / 60) % 6)\n    f = h / 60 - i\n\n    const vs = [v, v * (1 - s), v * (1 - f * s), v * (1 - (1 - f) * s)]\n    const perm = [\n      [0, 3, 1],\n      [2, 0, 1],\n      [1, 0, 3],\n      [1, 2, 0],\n      [3, 1, 0],\n      [0, 1, 2],\n    ]\n\n    return colorFunctions.rgba(\n      vs[perm[i][0]] * 255,\n      vs[perm[i][1]] * 255,\n      vs[perm[i][2]] * 255,\n      a\n    )\n  },\n\n  hue(color) {\n    return new Dimension(color.toHSL().h)\n  },\n  saturation(color) {\n    return new Dimension(color.toHSL().s * 100, '%')\n  },\n  lightness(color) {\n    return new Dimension(color.toHSL().l * 100, '%')\n  },\n  hsvhue(color) {\n    return new Dimension(color.toHSV().h)\n  },\n  hsvsaturation(color) {\n    return new Dimension(color.toHSV().s * 100, '%')\n  },\n  hsvvalue(color) {\n    return new Dimension(color.toHSV().v * 100, '%')\n  },\n  red(color) {\n    return new Dimension(color.rgb[0])\n  },\n  green(color) {\n    return new Dimension(color.rgb[1])\n  },\n  blue(color) {\n    return new Dimension(color.rgb[2])\n  },\n  alpha(color) {\n    return new Dimension(color.toHSL().a)\n  },\n  luma(color) {\n    return new Dimension(color.luma() * color.alpha * 100, '%')\n  },\n  luminance(color) {\n    const luminance =\n      0.2126 * color.rgb[0] / 255 +\n      0.7152 * color.rgb[1] / 255 +\n      0.0722 * color.rgb[2] / 255\n\n    return new Dimension(luminance * color.alpha * 100, '%')\n  },\n  saturate(color, amount, method) {\n    // filter: saturate(3.2);\n    // should be kept as is, so check for color\n    if (!color.rgb) {\n      return null\n    }\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.s += hsl.s * amount.value / 100\n    } else {\n      hsl.s += amount.value / 100\n    }\n    hsl.s = clamp(hsl.s)\n    return hsla(hsl)\n  },\n  desaturate(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.s -= hsl.s * amount.value / 100\n    } else {\n      hsl.s -= amount.value / 100\n    }\n    hsl.s = clamp(hsl.s)\n    return hsla(hsl)\n  },\n  lighten(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.l += hsl.l * amount.value / 100\n    } else {\n      hsl.l += amount.value / 100\n    }\n    hsl.l = clamp(hsl.l)\n    return hsla(hsl)\n  },\n  darken(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.l -= hsl.l * amount.value / 100\n    } else {\n      hsl.l -= amount.value / 100\n    }\n    hsl.l = clamp(hsl.l)\n    return hsla(hsl)\n  },\n  fadein(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.a += hsl.a * amount.value / 100\n    } else {\n      hsl.a += amount.value / 100\n    }\n    hsl.a = clamp(hsl.a)\n    return hsla(hsl)\n  },\n  fadeout(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.a -= hsl.a * amount.value / 100\n    } else {\n      hsl.a -= amount.value / 100\n    }\n    hsl.a = clamp(hsl.a)\n    return hsla(hsl)\n  },\n  fade(color, amount) {\n    const hsl = color.toHSL()\n\n    hsl.a = amount.value / 100\n    hsl.a = clamp(hsl.a)\n    return hsla(hsl)\n  },\n  spin(color, amount) {\n    const hsl = color.toHSL()\n    const hue = (hsl.h + amount.value) % 360\n\n    hsl.h = hue < 0 ? 360 + hue : hue\n\n    return hsla(hsl)\n  },\n  //\n  // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n  // http://sass-lang.com\n  //\n  mix(color1, color2, weight) {\n    if (!color1.toHSL || !color2.toHSL) {\n      console.log(color2.type)\n      console.dir(color2)\n    }\n    if (!weight) {\n      weight = new Dimension(50)\n    }\n    const p = weight.value / 100.0\n    const w = p * 2 - 1\n    const a = color1.toHSL().a - color2.toHSL().a\n\n    const w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0\n    const w2 = 1 - w1\n\n    const rgb = [\n      color1.rgb[0] * w1 + color2.rgb[0] * w2,\n      color1.rgb[1] * w1 + color2.rgb[1] * w2,\n      color1.rgb[2] * w1 + color2.rgb[2] * w2,\n    ]\n\n    const alpha = color1.alpha * p + color2.alpha * (1 - p)\n\n    return new Color(rgb, alpha)\n  },\n  greyscale(color) {\n    return colorFunctions.desaturate(color, new Dimension(100))\n  },\n  contrast(color, dark, light, threshold) {\n    // filter: contrast(3.2);\n    // should be kept as is, so check for color\n    if (!color.rgb) {\n      return null\n    }\n    if (typeof light === 'undefined') {\n      light = colorFunctions.rgba(255, 255, 255, 1.0)\n    }\n    if (typeof dark === 'undefined') {\n      dark = colorFunctions.rgba(0, 0, 0, 1.0)\n    }\n    //Figure out which is actually light and dark!\n    if (dark.luma() > light.luma()) {\n      const t = light\n      light = dark\n      dark = t\n    }\n    if (typeof threshold === 'undefined') {\n      threshold = 0.43\n    } else {\n      threshold = number(threshold)\n    }\n    if (color.luma() < threshold) {\n      return light\n    } else {\n      return dark\n    }\n  },\n  argb(color) {\n    return new Anonymous(color.toARGB())\n  },\n  color(c) {\n    if (c instanceof Quoted && /^#([a-f0-9]{6}|[a-f0-9]{3})$/i.test(c.value)) {\n      return new Color(c.value.slice(1))\n    }\n    if (c instanceof Color || (c = Color.fromKeyword(c.value))) {\n      c.value = undefined\n      return c\n    }\n    throw {\n      type: 'Argument',\n      message: 'argument must be a color keyword or 3/6 digit hex e.g. #FFF',\n    }\n  },\n  tint(color, amount) {\n    return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount)\n  },\n  shade(color, amount) {\n    return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount)\n  },\n}\nfunctionRegistry.addMultiple(colorFunctions)\n","const Color = require('../tree/color')\nconst functionRegistry = require('./function-registry')\n\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\n\nfunction colorBlend(mode, color1, color2) {\n  const ab = color1.alpha // result\n\n  let // backdrop\n  cb\n\n  const as = color2.alpha\n\n  let // source\n  cs\n\n  let ar\n  let cr\n  const r = []\n\n  ar = as + ab * (1 - as)\n  for (let i = 0; i < 3; i++) {\n    cb = color1.rgb[i] / 255\n    cs = color2.rgb[i] / 255\n    cr = mode(cb, cs)\n    if (ar) {\n      cr = (as * cs + ab * (cb - as * (cb + cs - cr))) / ar\n    }\n    r[i] = cr * 255\n  }\n\n  return new Color(r, ar)\n}\n\nconst colorBlendModeFunctions = {\n  multiply(cb, cs) {\n    return cb * cs\n  },\n  screen(cb, cs) {\n    return cb + cs - cb * cs\n  },\n  overlay(cb, cs) {\n    cb *= 2\n    return cb <= 1\n      ? colorBlendModeFunctions.multiply(cb, cs)\n      : colorBlendModeFunctions.screen(cb - 1, cs)\n  },\n  softlight(cb, cs) {\n    let d = 1\n    let e = cb\n    if (cs > 0.5) {\n      e = 1\n      d = cb > 0.25 ? Math.sqrt(cb) : ((16 * cb - 12) * cb + 4) * cb\n    }\n    return cb - (1 - 2 * cs) * e * (d - cb)\n  },\n  hardlight(cb, cs) {\n    return colorBlendModeFunctions.overlay(cs, cb)\n  },\n  difference(cb, cs) {\n    return Math.abs(cb - cs)\n  },\n  exclusion(cb, cs) {\n    return cb + cs - 2 * cb * cs\n  },\n\n  // non-w3c functions:\n  average(cb, cs) {\n    return (cb + cs) / 2\n  },\n  negation(cb, cs) {\n    return 1 - Math.abs(cb + cs - 1)\n  },\n}\n\nfor (const f in colorBlendModeFunctions) {\n  if (colorBlendModeFunctions.hasOwnProperty(f)) {\n    colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f])\n  }\n}\n\nfunctionRegistry.addMultiple(colorBlend)\n","module.exports = environment => {\n  const Quoted = require('../tree/quoted')\n  const URL = require('../tree/url')\n  const functionRegistry = require('./function-registry')\n  const fallback = (functionThis, node) =>\n    new URL(node, functionThis.index, functionThis.currentFileInfo).eval(\n      functionThis.context\n    )\n  const logger = require('../logger')\n\n  functionRegistry.add('data-uri', function(mimetypeNode, filePathNode) {\n    if (!filePathNode) {\n      filePathNode = mimetypeNode\n      mimetypeNode = null\n    }\n\n    let mimetype = mimetypeNode && mimetypeNode.value\n    let filePath = filePathNode.value\n    const currentFileInfo = this.currentFileInfo\n    const currentDirectory = currentFileInfo.relativeUrls\n      ? currentFileInfo.currentDirectory\n      : currentFileInfo.entryPath\n\n    const fragmentStart = filePath.indexOf('#')\n    let fragment = ''\n    if (fragmentStart !== -1) {\n      fragment = filePath.slice(fragmentStart)\n      filePath = filePath.slice(0, fragmentStart)\n    }\n\n    const fileManager = environment.getFileManager(\n      filePath,\n      currentDirectory,\n      this.context,\n      environment,\n      true\n    )\n\n    if (!fileManager) {\n      return fallback(this, filePathNode)\n    }\n\n    let useBase64 = false\n\n    // detect the mimetype if not given\n    if (!mimetypeNode) {\n      mimetype = environment.mimeLookup(filePath)\n\n      if (mimetype === 'image/svg+xml') {\n        useBase64 = false\n      } else {\n        // use base 64 unless it's an ASCII or UTF-8 format\n        const charset = environment.charsetLookup(mimetype)\n        useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0\n      }\n      if (useBase64) {\n        mimetype += ';base64'\n      }\n    } else {\n      useBase64 = /;base64$/.test(mimetype)\n    }\n\n    const fileSync = fileManager.loadFileSync(\n      filePath,\n      currentDirectory,\n      this.context,\n      environment\n    )\n    if (!fileSync.contents) {\n      logger.warn(\n        `Skipped data-uri embedding of ${filePath} because file not found`\n      )\n      return fallback(this, filePathNode || mimetypeNode)\n    }\n    let buf = fileSync.contents\n    if (useBase64 && !environment.encodeBase64) {\n      return fallback(this, filePathNode)\n    }\n\n    buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf)\n\n    const uri = `data:${mimetype},${buf}${fragment}`\n\n    // IE8 cannot handle a data-uri larger than 32,768 characters. If this is exceeded\n    // and the --ieCompat flag is enabled, return a normal url() instead.\n    const DATA_URI_MAX = 32768\n    if (uri.length >= DATA_URI_MAX) {\n      if (this.context.ieCompat !== false) {\n        logger.warn(\n          `Skipped data-uri embedding of ${filePath} because its size (${\n            uri.length\n          } characters) exceeds IE8-safe ${DATA_URI_MAX} characters!`\n        )\n\n        return fallback(this, filePathNode || mimetypeNode)\n      }\n    }\n\n    return new URL(\n      new Quoted(`\"${uri}\"`, uri, false, this.index, this.currentFileInfo),\n      this.index,\n      this.currentFileInfo\n    )\n  })\n}\n","const Dimension = require('../tree/dimension')\n\nconst MathHelper = () => {}\nMathHelper._math = (fn, unit, n) => {\n  if (!(n instanceof Dimension)) {\n    throw { type: 'Argument', message: 'argument must be a number' }\n  }\n  if (unit == null) {\n    unit = n.unit\n  } else {\n    n = n.unify()\n  }\n  return new Dimension(fn(parseFloat(n.value)), unit)\n}\nmodule.exports = MathHelper\n","const functionRegistry = require('./function-registry')\nconst mathHelper = require('./math-helper.js')\n\nconst mathFunctions = {\n  // name,  unit\n  ceil: null,\n  floor: null,\n  sqrt: null,\n  abs: null,\n  tan: '',\n  sin: '',\n  cos: '',\n  atan: 'rad',\n  asin: 'rad',\n  acos: 'rad',\n}\n\nfor (const f in mathFunctions) {\n  if (mathFunctions.hasOwnProperty(f)) {\n    mathFunctions[f] = mathHelper._math.bind(null, Math[f], mathFunctions[f])\n  }\n}\n\nmathFunctions.round = (n, f) => {\n  const fraction = typeof f === 'undefined' ? 0 : f.value\n  return mathHelper._math(num => num.toFixed(fraction), null, n)\n}\n\nfunctionRegistry.addMultiple(mathFunctions)\n","const Dimension = require('../tree/dimension')\nconst Anonymous = require('../tree/anonymous')\nconst functionRegistry = require('./function-registry')\nconst mathHelper = require('./math-helper.js')\n\nconst minMax = function(isMin, args) {\n  args = Array.prototype.slice.call(args)\n  switch (args.length) {\n    case 0:\n      throw { type: 'Argument', message: 'one or more arguments required' }\n  }\n  let i // key is the unit.toString() for unified Dimension values,\n  let j\n  let current\n  let currentUnified\n  let referenceUnified\n  let unit\n  let unitStatic\n  let unitClone\n\n  const // elems only contains original argument values.\n  order = []\n\n  const values = {}\n  // value is the index into the order array.\n  for (i = 0; i < args.length; i++) {\n    current = args[i]\n    if (!(current instanceof Dimension)) {\n      if (Array.isArray(args[i].value)) {\n        Array.prototype.push.apply(\n          args,\n          Array.prototype.slice.call(args[i].value)\n        )\n      }\n      continue\n    }\n    currentUnified =\n      current.unit.toString() === '' && unitClone !== undefined\n        ? new Dimension(current.value, unitClone).unify()\n        : current.unify()\n    unit =\n      currentUnified.unit.toString() === '' && unitStatic !== undefined\n        ? unitStatic\n        : currentUnified.unit.toString()\n    unitStatic =\n      (unit !== '' && unitStatic === undefined) ||\n      (unit !== '' && order[0].unify().unit.toString() === '')\n        ? unit\n        : unitStatic\n    unitClone =\n      unit !== '' && unitClone === undefined\n        ? current.unit.toString()\n        : unitClone\n    j =\n      values[''] !== undefined && unit !== '' && unit === unitStatic\n        ? values['']\n        : values[unit]\n    if (j === undefined) {\n      if (unitStatic !== undefined && unit !== unitStatic) {\n        throw { type: 'Argument', message: 'incompatible types' }\n      }\n      values[unit] = order.length\n      order.push(current)\n      continue\n    }\n    referenceUnified =\n      order[j].unit.toString() === '' && unitClone !== undefined\n        ? new Dimension(order[j].value, unitClone).unify()\n        : order[j].unify()\n    if (\n      (isMin && currentUnified.value < referenceUnified.value) ||\n      (!isMin && currentUnified.value > referenceUnified.value)\n    ) {\n      order[j] = current\n    }\n  }\n  if (order.length == 1) {\n    return order[0]\n  }\n  args = order\n    .map(function(a) {\n      return a.toCSS(this.context)\n    })\n    .join(this.context.compress ? ',' : ', ')\n  return new Anonymous(`${isMin ? 'min' : 'max'}(${args})`)\n}\nfunctionRegistry.addMultiple({\n  min(...args) {\n    return minMax(true, args)\n  },\n  max(...args) {\n    return minMax(false, args)\n  },\n  convert(val, unit) {\n    return val.convertTo(unit.value)\n  },\n  pi() {\n    return new Dimension(Math.PI)\n  },\n  mod(a, b) {\n    return new Dimension(a.value % b.value, a.unit)\n  },\n  pow(x, y) {\n    if (typeof x === 'number' && typeof y === 'number') {\n      x = new Dimension(x)\n      y = new Dimension(y)\n    } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n      throw { type: 'Argument', message: 'arguments must be numbers' }\n    }\n\n    return new Dimension(Math.pow(x.value, y.value), x.unit)\n  },\n  percentage(n) {\n    const result = mathHelper._math(num => num * 100, '%', n)\n\n    return result\n  },\n})\n","const Quoted = require('../tree/quoted')\nconst Anonymous = require('../tree/anonymous')\nconst JavaScript = require('../tree/javascript')\nconst functionRegistry = require('./function-registry')\n\nfunctionRegistry.addMultiple({\n  e(str) {\n    return new Anonymous(str instanceof JavaScript ? str.evaluated : str.value)\n  },\n  escape(str) {\n    return new Anonymous(\n      encodeURI(str.value)\n        .replace(/=/g, '%3D')\n        .replace(/:/g, '%3A')\n        .replace(/#/g, '%23')\n        .replace(/;/g, '%3B')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n    )\n  },\n  replace(string, pattern, replacement, flags) {\n    let result = string.value\n    replacement =\n      replacement.type === 'Quoted' ? replacement.value : replacement.toCSS()\n    result = result.replace(\n      new RegExp(pattern.value, flags ? flags.value : ''),\n      replacement\n    )\n    return new Quoted(string.quote || '', result, string.escaped)\n  },\n  '%': function(string /* arg, arg, ...*/) {\n    const args = Array.prototype.slice.call(arguments, 1)\n    let result = string.value\n\n    for (let i = 0; i < args.length; i++) {\n      /*jshint loopfunc:true */\n      result = result.replace(/%[sda]/i, token => {\n        const value =\n          args[i].type === 'Quoted' && token.match(/s/i)\n            ? args[i].value\n            : args[i].toCSS()\n        return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value\n      })\n    }\n    result = result.replace(/%%/g, '%')\n    return new Quoted(string.quote || '', result, string.escaped)\n  },\n})\n","module.exports = environment => {\n  const Dimension = require('../tree/dimension')\n  const Color = require('../tree/color')\n  const Expression = require('../tree/expression')\n  const Quoted = require('../tree/quoted')\n  const URL = require('../tree/url')\n  const functionRegistry = require('./function-registry')\n\n  functionRegistry.add('svg-gradient', function(direction) {\n    let stops\n    let gradientDirectionSvg\n    let gradientType = 'linear'\n    let rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"'\n    const renderEnv = { compress: false }\n    let returner\n    const directionValue = direction.toCSS(renderEnv)\n    let i\n    let color\n    let position\n    let positionValue\n    let alpha\n\n    function throwArgumentDescriptor() {\n      throw {\n        type: 'Argument',\n        message:\n          'svg-gradient expects direction, start_color [start_position], [color position,]...,' +\n          ' end_color [end_position] or direction, color list',\n      }\n    }\n\n    if (arguments.length == 2) {\n      if (arguments[1].value.length < 2) {\n        throwArgumentDescriptor()\n      }\n      stops = arguments[1].value\n    } else if (arguments.length < 3) {\n      throwArgumentDescriptor()\n    } else {\n      stops = Array.prototype.slice.call(arguments, 1)\n    }\n\n    switch (directionValue) {\n      case 'to bottom':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"'\n        break\n      case 'to right':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"'\n        break\n      case 'to bottom right':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"'\n        break\n      case 'to top right':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"'\n        break\n      case 'ellipse':\n      case 'ellipse at center':\n        gradientType = 'radial'\n        gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"'\n        rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"'\n        break\n      default:\n        throw {\n          type: 'Argument',\n          message:\n            \"svg-gradient direction must be 'to bottom', 'to right',\" +\n            \" 'to bottom right', 'to top right' or 'ellipse at center'\",\n        }\n    }\n    returner = `<?xml version=\"1.0\" ?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 1 1\" preserveAspectRatio=\"none\"><${gradientType}Gradient id=\"gradient\" gradientUnits=\"userSpaceOnUse\" ${gradientDirectionSvg}>`\n\n    for (i = 0; i < stops.length; i += 1) {\n      if (stops[i] instanceof Expression) {\n        color = stops[i].value[0]\n        position = stops[i].value[1]\n      } else {\n        color = stops[i]\n        position = undefined\n      }\n\n      if (\n        !(color instanceof Color) ||\n        (!((i === 0 || i + 1 === stops.length) && position === undefined) &&\n          !(position instanceof Dimension))\n      ) {\n        throwArgumentDescriptor()\n      }\n      positionValue = position\n        ? position.toCSS(renderEnv)\n        : i === 0 ? '0%' : '100%'\n      alpha = color.alpha\n      returner += `<stop offset=\"${positionValue}\" stop-color=\"${color.toRGB()}\"${\n        alpha < 1 ? ' stop-opacity=\"' + alpha + '\"' : ''\n      }/>`\n    }\n    returner += `</${gradientType}Gradient><rect ${rectangleDimension} fill=\"url(#gradient)\" /></svg>`\n\n    returner = encodeURIComponent(returner)\n\n    returner = `data:image/svg+xml,${returner}`\n    return new URL(\n      new Quoted(\n        `'${returner}'`,\n        returner,\n        false,\n        this.index,\n        this.currentFileInfo\n      ),\n      this.index,\n      this.currentFileInfo\n    )\n  })\n}\n","const Keyword = require('../tree/keyword')\nconst DetachedRuleset = require('../tree/detached-ruleset')\nconst Dimension = require('../tree/dimension')\nconst Color = require('../tree/color')\nconst Quoted = require('../tree/quoted')\nconst Anonymous = require('../tree/anonymous')\nconst URL = require('../tree/url')\nconst Operation = require('../tree/operation')\nconst functionRegistry = require('./function-registry')\nconst isa = (n, Type) => (n instanceof Type ? Keyword.True : Keyword.False)\n\nconst isunit = (n, unit) => {\n  if (unit === undefined) {\n    throw {\n      type: 'Argument',\n      message: 'missing the required second argument to isunit.',\n    }\n  }\n  unit = typeof unit.value === 'string' ? unit.value : unit\n  if (typeof unit !== 'string') {\n    throw {\n      type: 'Argument',\n      message: 'Second argument to isunit should be a unit or a string.',\n    }\n  }\n  return n instanceof Dimension && n.unit.is(unit)\n    ? Keyword.True\n    : Keyword.False\n}\n\nconst getItemsFromNode = node => {\n  // handle non-array values as an array of length 1\n  // return 'undefined' if index is invalid\n  const items = Array.isArray(node.value) ? node.value : Array(node)\n\n  return items\n}\n\nfunctionRegistry.addMultiple({\n  isruleset(n) {\n    return isa(n, DetachedRuleset)\n  },\n  iscolor(n) {\n    return isa(n, Color)\n  },\n  isnumber(n) {\n    return isa(n, Dimension)\n  },\n  isstring(n) {\n    return isa(n, Quoted)\n  },\n  iskeyword(n) {\n    return isa(n, Keyword)\n  },\n  isurl(n) {\n    return isa(n, URL)\n  },\n  ispixel(n) {\n    return isunit(n, 'px')\n  },\n  ispercentage(n) {\n    return isunit(n, '%')\n  },\n  isem(n) {\n    return isunit(n, 'em')\n  },\n  isunit,\n  unit(val, unit) {\n    if (!(val instanceof Dimension)) {\n      throw {\n        type: 'Argument',\n        message: `the first argument to unit must be a number${\n          val instanceof Operation ? '. Have you forgotten parenthesis?' : ''\n        }`,\n      }\n    }\n    if (unit) {\n      if (unit instanceof Keyword) {\n        unit = unit.value\n      } else {\n        unit = unit.toCSS()\n      }\n    } else {\n      unit = ''\n    }\n    return new Dimension(val.value, unit)\n  },\n  'get-unit': function(n) {\n    return new Anonymous(n.unit)\n  },\n  extract(values, index) {\n    index = index.value - 1 // (1-based index)\n\n    return getItemsFromNode(values)[index]\n  },\n  length(values) {\n    return new Dimension(getItemsFromNode(values).length)\n  },\n})\n","module.exports = environment => {\n  const functions = {\n    functionRegistry: require('./function-registry'),\n    functionCaller: require('./function-caller'),\n  }\n\n  //register functions\n  require('./default')\n  require('./color')\n  require('./color-blending')\n  require('./data-uri')(environment)\n  require('./math')\n  require('./number')\n  require('./string')\n  require('./svg')(environment)\n  require('./types')\n\n  return functions\n}\n","module.exports = (environment, ParseTree) => {\n  const render = function(input, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    if (!callback) {\n      const self = this\n      return new Promise((resolve, reject) => {\n        render.call(self, input, options, (err, output) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve(output)\n          }\n        })\n      })\n    } else {\n      this.parse(input, options, (err, root, imports, options) => {\n        if (err) {\n          return callback(err)\n        }\n\n        let result\n        try {\n          const parseTree = new ParseTree(root, imports)\n          result = parseTree.toCSS(options)\n        } catch (err) {\n          return callback(err)\n        }\n\n        callback(null, result)\n      })\n    }\n  }\n\n  return render\n}\n","/**\n * Plugin Manager\n */\nclass PluginManager {\n  constructor(less) {\n    this.less = less\n    this.visitors = []\n    this.preProcessors = []\n    this.postProcessors = []\n    this.installedPlugins = []\n    this.fileManagers = []\n  }\n\n  /**\n   * Adds all the plugins in the array\n   * @param {Array} plugins\n   */\n  addPlugins(plugins) {\n    if (plugins) {\n      for (let i = 0; i < plugins.length; i++) {\n        this.addPlugin(plugins[i])\n      }\n    }\n  }\n\n  /**\n   *\n   * @param plugin\n   */\n  addPlugin(plugin) {\n    this.installedPlugins.push(plugin)\n    plugin.install(this.less, this)\n  }\n\n  /**\n   * Adds a visitor. The visitor object has options on itself to determine\n   * when it should run.\n   * @param visitor\n   */\n  addVisitor(visitor) {\n    this.visitors.push(visitor)\n  }\n\n  /**\n   * Adds a pre processor object\n   * @param {object} preProcessor\n   * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n   */\n  addPreProcessor(preProcessor, priority) {\n    let indexToInsertAt\n    for (\n      indexToInsertAt = 0;\n      indexToInsertAt < this.preProcessors.length;\n      indexToInsertAt++\n    ) {\n      if (this.preProcessors[indexToInsertAt].priority >= priority) {\n        break\n      }\n    }\n    this.preProcessors.splice(indexToInsertAt, 0, { preProcessor, priority })\n  }\n\n  /**\n   * Adds a post processor object\n   * @param {object} postProcessor\n   * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n   */\n  addPostProcessor(postProcessor, priority) {\n    let indexToInsertAt\n    for (\n      indexToInsertAt = 0;\n      indexToInsertAt < this.postProcessors.length;\n      indexToInsertAt++\n    ) {\n      if (this.postProcessors[indexToInsertAt].priority >= priority) {\n        break\n      }\n    }\n    this.postProcessors.splice(indexToInsertAt, 0, { postProcessor, priority })\n  }\n\n  /**\n   *\n   * @param manager\n   */\n  addFileManager(manager) {\n    this.fileManagers.push(manager)\n  }\n\n  /**\n   *\n   * @returns {Array}\n   * @private\n   */\n  getPreProcessors() {\n    const preProcessors = []\n    for (let i = 0; i < this.preProcessors.length; i++) {\n      preProcessors.push(this.preProcessors[i].preProcessor)\n    }\n    return preProcessors\n  }\n\n  /**\n   *\n   * @returns {Array}\n   * @private\n   */\n  getPostProcessors() {\n    const postProcessors = []\n    for (let i = 0; i < this.postProcessors.length; i++) {\n      postProcessors.push(this.postProcessors[i].postProcessor)\n    }\n    return postProcessors\n  }\n\n  /**\n   *\n   * @returns {Array}\n   * @private\n   */\n  getVisitors() {\n    return this.visitors\n  }\n\n  /**\n   *\n   * @returns {Array}\n   * @private\n   */\n  getFileManagers() {\n    return this.fileManagers\n  }\n}\n\nmodule.exports = PluginManager\n","let PromiseConstructor\nconst contexts = require('./contexts')\nconst Parser = require('./parser/parser')\nconst PluginManager = require('./plugin-manager')\n\nmodule.exports = (environment, ParseTree, ImportManager) => {\n  const parse = function(input, options = {}, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    if (!callback) {\n      const self = this\n      return new Promise((resolve, reject) => {\n        parse.call(self, input, options, (err, output) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve(output)\n          }\n        })\n      })\n    } else {\n      let context\n      let rootFileInfo\n      const pluginManager = new PluginManager(this)\n\n      pluginManager.addPlugins(options.plugins)\n      options.pluginManager = pluginManager\n\n      context = new contexts.Parse(options)\n\n      if (options.rootFileInfo) {\n        rootFileInfo = options.rootFileInfo\n      } else {\n        const filename = options.filename || 'input'\n        const entryPath = filename.replace(/[^\\/\\\\]*$/, '')\n        rootFileInfo = {\n          filename,\n          relativeUrls: context.relativeUrls,\n          rootpath: context.rootpath || '',\n          currentDirectory: entryPath,\n          entryPath,\n          rootFilename: filename,\n        }\n        // add in a missing trailing slash\n        if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {\n          rootFileInfo.rootpath += '/'\n        }\n      }\n\n      const imports = new ImportManager(context, rootFileInfo)\n\n      new Parser(context, imports, rootFileInfo).parse(\n        input,\n        (e, root) => {\n          if (e) {\n            return callback(e)\n          }\n          callback(null, root, imports, options)\n        },\n        options\n      )\n    }\n  }\n  return parse\n}\n","module.exports = (environment, fileManagers) => {\n  const Environment = require('./environment/environment')\n  environment = new Environment(environment, fileManagers)\n\n  const SourceMapOutput = require('./source-map-output')(environment)\n  const SourceMapBuilder = require('./source-map-builder')(\n    SourceMapOutput,\n    environment\n  )\n  const ParseTree = require('./parse-tree')(SourceMapBuilder)\n  const ImportManager = require('./import-manager')(environment)\n\n  return {\n    version: [2, 7, 2],\n    data: require('./data'),\n    tree: require('./tree'),\n    Environment,\n    environment,\n    AbstractFileManager: require('./environment/abstract-file-manager'),\n    visitors: require('./visitors'),\n    Parser: require('./parser/parser'),\n    functions: require('./functions')(environment),\n    contexts: require('./contexts'),\n    SourceMapOutput,\n    SourceMapBuilder,\n    ParseTree,\n    ImportManager: ImportManager,\n    render: require('./render')(environment, ParseTree, ImportManager),\n    parse: require('./parse')(environment, ParseTree, ImportManager),\n    LessError: require('./less-error'),\n    transformTree: require('./transform-tree'),\n    utils: require('./utils'),\n    PluginManager: require('./plugin-manager'),\n    logger: require('./logger'),\n    writeError(ctx, options) {\n      options = options || {}\n      if (options.silent) {\n        return\n      }\n      console.error(this.formatError(ctx, options))\n    },\n    formatError(ctx) {\n      let message = ''\n      let extract = ctx.extract\n      let error = []\n\n      // only output a stack if it isn't a less error\n      if (ctx.stack && !ctx.type) {\n        return ctx.stack\n      }\n\n      if (!ctx.hasOwnProperty('index') || !extract) {\n        return ctx.stack || ctx.message\n      }\n\n      if (typeof extract[0] === 'string') {\n        error.push(`${ctx.line - 1} ${extract[0]}`)\n      }\n\n      if (typeof extract[1] === 'string') {\n        let errorTxt = `${ctx.line} `\n        if (extract[1]) {\n          errorTxt +=\n            extract[1].slice(0, ctx.column) +\n            extract[1].substr(ctx.column, 1) +\n            extract[1].slice(ctx.column + 1)\n        }\n        error.push(errorTxt)\n      }\n\n      if (typeof extract[2] === 'string') {\n        error.push(`${ctx.line + 1} ${extract[2]}`)\n      }\n      error = `${error.join('\\n')}\\n`\n\n      message += `${ctx.type}Error: ${ctx.message}`\n      if (ctx.filename) {\n        message += ` in ${ctx.filename} on line ${\n          ctx.line\n        }, column ${ctx.column + 1}:`\n      }\n\n      message += `\\n${error}`\n\n      if (ctx.callLine) {\n        message += `from ${ctx.filename || ''}/n`\n        message += `${ctx.callLine} ${ctx.callExtract}/n`\n      }\n      return message\n    },\n  }\n}\n","const createFromEnvironment = require('../less')\nconst AbstractFileManager = require('../less/environment/abstract-file-manager.js')\n\nclass NotSupportedFileManager extends AbstractFileManager {\n  supports() {\n    return true\n  }\n\n  supportsSync() {\n    return true\n  }\n\n  loadFile() {\n    return Promise.reject(new Error('loading is not supported'))\n  }\n\n  loadFileSync() {\n    new Error('loading is not supported')\n  }\n}\n\nconst less = createFromEnvironment(\n  {\n    getSourceMapGenerator: function() {\n      return null\n    },\n  },\n  [new NotSupportedFileManager()]\n)\nless.FileManager = NotSupportedFileManager\n\nmodule.exports = less\n"],"names":["msg","_fireEvent","listener","_listeners","push","i","length","splice","type","logFunction","Environment","externalEnvironment","fileManagers","optionalFunctions","requiredFunctions","functions","concat","propName","environmentFunc","bind","warn","getFileManager","filename","currentDirectory","options","environment","isSync","pluginManager","getFileManagers","fileManager","addFileManager","clearFileManagers","SourceMapOutput","_css","_rootNode","rootNode","_contentsMap","contentsMap","_contentsIgnoredCharsMap","contentsIgnoredCharsMap","sourceMapFilename","_sourceMapFilename","replace","_outputFilename","outputFilename","sourceMapURL","sourceMapBasepath","_sourceMapBasepath","sourceMapRootpath","_sourceMapRootpath","charAt","_outputSourceFiles","outputSourceFiles","_sourceMapGeneratorConstructor","getSourceMapGenerator","_lineNumber","_column","normalizeFilename","indexOf","substring","add","chunk","fileInfo","index","mapLines","lines","sourceLines","columns","sourceColumns","inputSource","slice","split","_sourceMapGenerator","addMapping","line","column","isEmpty","toCSS","context","hasOwnProperty","source","setSourceContent","genCSS","sourceMapContent","JSON","stringify","toJSON","sourceMap","join","SourceMapBuilder","imports","sourceMapOutput","contentsIgnoredChars","contents","sourceMapOutputFilename","sourceMapGenerator","sourceMapFileInline","css","sourceMapInputFilename","getCSSAppendage","undefined","encodeBase64","getExternalSourceMap","setExternalSourceMap","isInline","getSourceMapURL","getOutputFilename","getInputFilename","inputStream","n","match","LessError","module","e","importManager","currentFilename","call","input","loc","utils","getLocation","col","callLine","callExtract","extract","message","stack","Object","create","F","prototype","Error","constructor","contexts","copyFromOriginal","original","destination","propertiesToCopy","parseCopyProperties","Parse","paths","evalCopyProperties","Eval","frames","importantScope","inParenthesis","parensStack","outOfParenthesis","pop","isInParens","inCall","callStack","outOfCall","isInCall","isMathOn","disableMath","strictMath","isPathRelative","test","path","normalizePath","segments","reverse","segment","Node","strs","output","value","accept","visitor","visit","eval","_operate","op","a","b","fround","precision","numPrecision","Number","toFixed","blocksVisibility","visibilityBlocks","addVisibilityBlock","removeVisibilityBlock","ensureVisibility","nodeVisible","ensureInvisibility","isVisible","visibilityInfo","copyVisibilityInfo","info","compare","Array","isArray","numericCompare","Alpha","val","Color","rgb","originalForm","map","parseInt","c","alpha","luma","r","g","Math","pow","doNotCompress","compress","color","clamp","round","toRGB","splitcolor","operate","other","toHex","toHSL","max","min","h","s","l","d","toHSV","v","toARGB","x","toString","fromKeyword","key","keyword","toLowerCase","colors","Paren","node","Combinator","emptyOrWhitespace","trim","spaceOrEmpty","_noSpaceCombinators","Element","combinator","currentFileInfo","clone","firstSelector","Selector","elements","extendList","condition","evaldCondition","visitArray","createDerived","newSelector","mediaEmpty","createEmptySelectors","el","sels","len","olen","CacheElements","_elements","shift","isJustParentSelector","extend","element","getIsOutput","Value","Keyword","True","False","Rule","name","important","merge","inline","variable","allowRoot","lastRule","strictMathBypass","evaldValue","evalName","importantResult","makeImportant","makeRegistry","base","func","_data","keys","forEach","get","defaultFunc","value_","error_","functionRegistry","debugInfo","ctx","lineSeparator","result","dumpLineNumbers","asComment","asMediaQuery","lineNumber","fileName","filenameWithProtocol","Ruleset","selectors","rules","strictImports","_lookups","thisSelectors","selCnt","selector","hasOnePassingSelector","error","reset","ruleset","rule","subRule","originalRuleset","root","firstRoot","allowImports","found","globalFunctionRegistry","inherit","ctxFrames","unshift","ctxSelectors","evalImports","rsRules","rsRuleCnt","evalFirst","mediaBlockCount","mediaBlocks","filter","resetCache","j","bubbleSelectors","importRules","matchArgs","args","matchCondition","lastSelector","_rulesets","_variables","variables","reduce","hash","vars","rulesets","filtRules","cnt","isRuleset","prependRule","find","self","foundMixins","apply","charsetRuleNodes","ruleNodes","tabLevel","tabRuleStr","tabSetStr","sep","isRulesetLikeNode","isRulesetLike","charsetNodeIndex","importNodeIndex","isCharset","getDebugInfo","pathCnt","pathSubCnt","currentLastRule","joinSelectors","joinSelector","createParenthesis","elementsToPak","originalElement","replacementParen","insideParent","createSelector","containedElement","addReplacementIntoPath","beginningPath","addPath","replacedElement","originalSelector","newSelectorPath","newJoinedSelector","parentEl","restOfPath","addAllReplacementsIntoPath","addPaths","mergeElementsOnToSelectors","sel","replaceParentSelector","inSelector","k","currentElements","newSelectors","selectorsMultiplied","hadParentSelector","findNestedSelector","maybeSelector","nestedSelector","nestedPaths","replaced","replacedNewSelectors","replacementSelector","deriveSelector","deriveFrom","newPaths","concatenated","Directive","isRooted","outputRuleset","mediaPathBackup","mediaBlocksBackup","mediaPath","ruleCnt","DetachedRuleset","callEval","PI","Unit","numerator","denominator","backupUnit","sort","strictUnits","returnStr","is","unitString","toUpperCase","isLength","Boolean","isSingular","callback","usedUnits","group","mapUnit","groupName","atomicUnit","unitConversions","cancel","counter","count","Dimension","unit","parseFloat","toColor","strValue","String","substr","convertTo","unify","duration","angle","conversions","targetUnit","derivedConversions","applyUnit","Operation","operands","isSpaced","isRootVariable","simplify","cloneOp","parensInOp","Variable","evaluating","current","frame","simplifyFilter","obj","fun","Attribute","JsEvalNode","evaluateJavaScript","expression","that","evalContext","javascriptEnabled","_","jsify","Function","Quoted","str","content","escaped","quote","containsVariables","javascriptReplacement","exp","interpolationReplacement","iterativeReplace","regexp","replacementFnc","evaluatedValue","Comment","isLineComment","isSilent","isCompressed","Expression","returnValue","parens","doubleParen","throwAwayComments","functionCaller","isValid","item","subNodes","Call","funcCaller","FunctionCaller","arg","URL","isEvald","rootpath","urlArgs","delimiter","Anonymous","rulesetLike","Media","features","media","evalTop","evalNested","multiMedia","permute","fragment","arr","rest","Import","less","pathValue","getPath","plugin","reference","isVariableImport","evalForImport","evalPath","doEval","registry","addMultiple","skip","importedFilename","newImport","Definition","params","variadic","arity","optionalParameters","required","p","evalParams","mixinEnv","evaldArguments","varargs","isNamedFound","argIndex","argsLength","evalCall","_arguments","mixinFrames","allArgsCnt","requiredArgsCnt","MixinCall","arguments","mixins","mixin","mixinPath","argValue","m","f","isRecursive","isOneFound","candidates","candidate","conditionResult","defaultResult","defFalseEitherCase","defNone","defTrue","defFalse","noArgumentsFilter","calcDefGroup","namespace","expand","MixinDefinition","format","newRules","_setVisibilityToReplacement","replacement","JavaScript","string","Assignment","Condition","negate","lvalue","rvalue","UnicodeDescriptor","Negative","Extend","option","object_id","next_id","parent_ids","allowBefore","allowAfter","findSelfSelectors","selfElements","selectorElements","selfSelectors","RulesetCall","detachedRuleset","tree","require$$0","require$$1","require$$2","require$$3","require$$4","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","require$$21","require$$22","require$$23","require$$24","require$$25","require$$26","require$$27","require$$28","require$$29","require$$30","require$$31","require$$32","require$$33","require$$34","_visitArgs","visitDeeper","_hasIndexed","_noop","indexNodeTypes","parent","ticker","child","typeIndex","Visitor","implementation","_implementation","_visitFnCache","nodeTypeIndex","visitFnCache","impl","aryIndx","outAryIndex","funcOut","visitArgs","fnName","newNode","isReplacing","nodes","nonReplacing","out","evald","flatten","nestedCnt","nestedItem","ImportSequencer","onSequencerEmpty","variableImports","_onSequencerEmpty","_currentDepth","addImport","importSequencer","importItem","isReady","tryRun","addVariableImport","variableImport","ImportVisitor","importer","finish","_visitor","_importer","_finish","importCount","onceFileDetectionMap","recursionDetector","_sequencer","isFinished","importNode","inlineCSS","importParent","processImportNode","evaldImportNode","multiple","importMultiple","tryAppendLessExtension","onImported","sequencedOnImported","importedAtRoot","fullPath","importVisitor","isPlugin","isOptional","optional","duplicateImport","oldContext","ruleNode","directiveNode","mixinDefinitionNode","rulesetNode","mediaNode","SetTreeVisibilityVisitor","visible","run","ExtendFinderVisitor","allExtendsStack","allExtends","visitRule","visitMixinDefinition","visitRuleset","allSelectorsExtendList","extendOnEveryPath","selectorPath","selExtendList","allSelectorsExtend","foundExtends","firstExtendOnThisSelectorPath","visitRulesetOut","visitMedia","visitMediaOut","visitDirective","visitDirectiveOut","ProcessExtendsVisitor","extendFinder","extendIndices","doExtendChaining","newRoot","checkExtendsForNonMatched","indices","hasFoundMatches","extendsList","extendsListTarget","iterationCount","extendIndex","targetExtendIndex","matches","extendsToAdd","extendVisitor","targetExtend","newExtend","findMatch","extendSelector","selfSelector","extendChainCount","selectorOne","selectorTwo","visitSelector","selectorNode","pathIndex","selectorsToAdd","extendedSelectors","haystackSelectorPath","haystackSelectorIndex","hackstackSelector","hackstackElementIndex","haystackElement","targetCombinator","needleElements","potentialMatches","potentialMatch","isElementValuesEqual","matched","finished","endPathIndex","endPathElementIndex","elementValue1","elementValue2","currentSelectorPathIndex","currentSelectorPathElementIndex","matchIndex","firstElement","newElements","initialCombinator","derived","currentValue","newAllExtends","lastIndex","JoinSelectorVisitor","CSSVisitorUtils","_context","containsSilentNonBlockedChild","bodyRules","keepOnlyVisibleChilds","owner","thing","hasVisibleSelector","resolveVisibility","originalRules","compiledRulesBody","isVisibleRuleset","ToCSSVisitor","_level","simplifyLevel","mixinNode","extendNode","commentNode","visitDirectiveWithBody","visitDirectiveWithoutBody","hasFakeRuleset","getBodyRules","nodeRules","_mergeRules","charset","comment","isRoot","checkValidNodes","_compileRulesetPaths","nodeRuleCnt","_removeDuplicateRules","ruleCache","ruleList","ruleCSS","groups","parts","toExpression","values","toValue","spacedGroups","lastSpacedGroup","anonymousNode","visitors","evaldRoot","evalEnv","preEvalVisitors","MarkVisibleSelectorsVisitor","ExtendVisitor","pluginVisitors","getVisitors","pluginVisitor","isPreEvalVisitor","isPreVisitor","ParseTree","sourceMapBuilder","transformTree","toCSSOptions","postProcessors","getPostProcessors","process","file","files","rootFilename","fail","level","parenLevel","lastOpening","lastOpeningParen","lastMultiComment","lastMultiCommentEndBrace","chunks","emitFrom","chunkerCurrentIndex","currentChunkStartIndex","cc","cc2","emitChunk","force","charCodeAt","fromCharCode","parserInput","CHARCODE_SPACE","CHARCODE_TAB","CHARCODE_LF","CHARCODE_CR","CHARCODE_PLUS","CHARCODE_COMMA","CHARCODE_FORWARD_SLASH","CHARCODE_9","skipWhitespace","oldi","oldj","curr","currentPos","endIndex","mem","inp","nextChar","autoCommentAbsorb","nextNewLine","text","commentStore","nextStarSlash","save","restore","furthest","possibleErrorMessage","furthestPossibleErrorMessage","state","saveStack","forget","isWhitespace","pos","offset","code","$re","tok","exec","$char","$str","tokLength","$quoted","startChar","currentPosition","peek","peekChar","currentChar","getInput","peekNotNumeric","start","chunkInput","failFunction","chunker","end","Parser","parsers","getParserInput","expect","expectChar","additionalData","globalVars","modifyVars","ignored","preText","serializeVars","preProcessors","getPreProcessors","banner","primary","endInfo","furthestChar","furthestReachedEnd","processImports","extendRule","definition","rulesetCall","entities","directive","foundSemiColon","isEscaped","nameLC","argsSemiColon","argsComma","expressions","isSemiColonSeparated","assignment","dimension","quoted","unicodeDescriptor","entity","curly","colorCandidateString","ud","js","escape","jsQuote","isRule","elemIndex","elem","isCall","returner","expressionContainsNamed","nameLoop","literal","cond","argInfo","conditions","block","url","javascript","attribute","variableCurly","slashedCombinator","isLess","when","blockRuleset","lessSelector","tryAnonymous","startOfRule","isVariable","ruleProperty","tryValueFirst","anonymousValue","dir","importOptions","mediaFeatures","o","optionName","importOption","opt","property","mediaFeature","nonVendorSpecificName","hasIdentifier","hasExpression","hasUnknown","hasBlock","addition","operation","operand","multiplication","logical","next","or","conditionAnd","insideCondition","me","negatedCondition","parenthesisCondition","and","tryConditionFollowedByParenthesis","body","atomicCondition","sub","colorKeyword","delim","simpleProperty","re","FunctionImporter","loaded","loader","ImportManager","rootFileInfo","mime","queue","fileParsedFunc","importedEqualsRoot","newFileInfo","relativeUrls","entryPath","tryAppendExtension","loadFileCallback","resolvedFilename","loadedFile","pathDiff","isPathAbsolute","alwaysMakePathsAbsolute","newEnv","parse","promise","loadFile","err","then","abstractFileManager","lastIndexOf","ext","supportsSync","basePath","laterPath","baseUrl","urlParts","extractUrlParts","baseUrlParts","urlDirectories","baseUrlDirectories","diff","hostPart","directories","urlPartsRegex","fileUrl","colorFunctions","hsla","number","scaled","size","rgba","m1","m2","hue","hsva","floor","vs","perm","luminance","amount","method","hsl","color1","color2","weight","log","w","w1","w2","desaturate","dark","light","threshold","t","mix","colorBlend","mode","ab","as","ar","cr","cb","cs","colorBlendModeFunctions","multiply","screen","sqrt","overlay","abs","fallback","functionThis","logger","mimetypeNode","filePathNode","mimetype","filePath","fragmentStart","useBase64","mimeLookup","charsetLookup","fileSync","loadFileSync","buf","encodeURIComponent","uri","DATA_URI_MAX","ieCompat","MathHelper","_math","fn","mathFunctions","mathHelper","fraction","num","minMax","isMin","currentUnified","referenceUnified","unitStatic","unitClone","order","y","evaluated","encodeURI","pattern","flags","RegExp","token","direction","stops","gradientDirectionSvg","gradientType","rectangleDimension","renderEnv","directionValue","position","positionValue","throwArgumentDescriptor","isa","Type","isunit","getItemsFromNode","items","render","Promise","resolve","reject","parseTree","PluginManager","installedPlugins","addPlugins","plugins","addPlugin","install","addVisitor","addPreProcessor","preProcessor","priority","indexToInsertAt","addPostProcessor","postProcessor","manager","silent","formatError","errorTxt","NotSupportedFileManager","supports","AbstractFileManager","createFromEnvironment","FileManager"],"mappings":"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"}