{"version":3,"sources":["../lib/less/tree/rule.js","../lib/less/functions/function-registry.js","../lib/less/visitors/visitor.js","../lib/less/functions/color.js","../lib/less/functions/color-blending.js","../lib/less/logger.js","../lib/less/environment/environment.js","../lib/less/source-map-output.js","../lib/less/source-map-builder.js","../lib/less/utils.js","../lib/less/less-error.js","../lib/less/contexts.js","../lib/less/tree/node.js","../lib/less/tree/alpha.js","../lib/less/data/colors.js","../lib/less/tree/color.js","../lib/less/tree/paren.js","../lib/less/tree/combinator.js","../lib/less/tree/element.js","../lib/less/tree/selector.js","../lib/less/tree/value.js","../lib/less/tree/keyword.js","../lib/less/functions/default.js","../lib/less/tree/debug-info.js","../lib/less/tree/ruleset.js","../lib/less/tree/directive.js","../lib/less/tree/detached-ruleset.js","../lib/less/data/unit-conversions.js","../lib/less/tree/unit.js","../lib/less/tree/dimension.js","../lib/less/tree/operation.js","../lib/less/tree/variable.js","../lib/less/tree/attribute.js","../lib/less/tree/js-eval-node.js","../lib/less/tree/quoted.js","../lib/less/tree/comment.js","../lib/less/tree/expression.js","../lib/less/functions/function-caller.js","../lib/less/tree/call.js","../lib/less/tree/url.js","../lib/less/tree/anonymous.js","../lib/less/tree/media.js","../lib/less/tree/import.js","../lib/less/tree/mixin-definition.js","../lib/less/tree/mixin-call.js","../lib/less/tree/javascript.js","../lib/less/tree/assignment.js","../lib/less/tree/condition.js","../lib/less/tree/unicode-descriptor.js","../lib/less/tree/negative.js","../lib/less/tree/extend.js","../lib/less/tree/ruleset-call.js","../lib/less/tree/index.js","../lib/less/visitors/import-sequencer.js","../lib/less/visitors/import-visitor.js","../lib/less/visitors/set-tree-visibility-visitor.js","../lib/less/visitors/extend-visitor.js","../lib/less/visitors/join-selector-visitor.js","../lib/less/visitors/to-css-visitor.js","../lib/less/visitors/index.js","../lib/less/transform-tree.js","../lib/less/parse-tree.js","../lib/less/parser/chunker.js","../lib/less/parser/parser-input.js","../lib/less/parser/parser.js","../lib/less/plugins/function-importer.js","../lib/less/import-manager.js","../lib/less/data/index.js","../lib/less/environment/abstract-file-manager.js","../lib/less/functions/data-uri.js","../lib/less/functions/math-helper.js","../lib/less/functions/number.js","../lib/less/functions/math.js","../lib/less/functions/string.js","../lib/less/functions/svg.js","../lib/less/functions/types.js","../lib/less/functions/index.js","../lib/less/render.js","../lib/less/plugin-manager.js","../lib/less/parse.js","../lib/less/index.js","../lib/less-browser/index.js"],"names":["evalName","context","name","value","i","n","length","output","s","eval","genCSS","makeRegistry","base","func","toLowerCase","this","_data","hasOwnProperty","functions","keys","forEach","add","get","_noop","node","indexNodeTypes","parent","ticker","key","child","_typeof","prototype","type","typeIndex","clamp","val","Math","min","max","hsla","color","colorFunctions","h","l","a","number","Dimension","parseFloat","unit","is","scaled","size","colorBlend","mode","color1","color2","ab","alpha","as","ar","cr","r","rgb","cb","cs","Color","logger","msg","_fireEvent","listener","_listeners","push","splice","logFunction","Environment","externalEnvironment","fileManagers","optionalFunctions","requiredFunctions","concat","propName","environmentFunc","bind","warn","getFileManager","filename","currentDirectory","options","environment","isSync","pluginManager","getFileManagers","fileManager","addFileManager","clearFileManagers","_css","_rootNode","rootNode","_contentsMap","contentsMap","_contentsIgnoredCharsMap","contentsIgnoredCharsMap","sourceMapFilename","_sourceMapFilename","replace","_outputFilename","outputFilename","sourceMapURL","sourceMapBasepath","_sourceMapBasepath","sourceMapRootpath","_sourceMapRootpath","charAt","_outputSourceFiles","outputSourceFiles","_sourceMapGeneratorConstructor","getSourceMapGenerator","_lineNumber","_column","normalizeFilename","indexOf","substring","chunk","fileInfo","index","mapLines","lines","sourceLines","columns","sourceColumns","inputSource","slice","split","_sourceMapGenerator","addMapping","line","column","isEmpty","toCSS","source","setSourceContent","sourceMapContent","JSON","stringify","toJSON","sourceMap","join","SourceMapOutput","imports","sourceMapOutput","contentsIgnoredChars","contents","sourceMapOutputFilename","sourceMapGenerator","sourceMapFileInline","css","sourceMapInputFilename","getCSSAppendage","undefined","encodeBase64","getExternalSourceMap","setExternalSourceMap","isInline","getSourceMapURL","getOutputFilename","getInputFilename","utils","inputStream","match","LessError","module","e","importManager","currentFilename","call","input","loc","getLocation","col","callLine","callExtract","extract","message","stack","Object","create","F","Error","constructor","contexts","copyFromOriginal","original","destination","propertiesToCopy","parseCopyProperties","Parse","paths","evalCopyProperties","Eval","frames","importantScope","inParenthesis","parensStack","outOfParenthesis","pop","isInParens","inCall","callStack","outOfCall","isInCall","isMathOn","disableMath","strictMath","isPathRelative","path","test","normalizePath","segments","reverse","segment","Node","strs","accept","visitor","visit","_operate","op","b","fround","precision","numPrecision","toFixed","blocksVisibility","visibilityBlocks","addVisibilityBlock","removeVisibilityBlock","ensureVisibility","nodeVisible","ensureInvisibility","isVisible","visibilityInfo","copyVisibilityInfo","info","compare","Array","isArray","numericCompare","Alpha","_Node","colors","v","toHex","map","c","round","toString","originalForm","parseInt","luma","g","pow","doNotCompress","compress","toRGB","splitcolor","operate","other","toHSL","d","toHSV","toARGB","x","fromKeyword","keyword","Paren","paren","Combinator","emptyOrWhitespace","trim","_this","spaceOrEmpty","_noSpaceCombinators","combinator","Element","currentFileInfo","clone","arguments","firstSelector","element","Selector","elements","extendList","condition","evaldCondition","visitArray","createDerived","newSelector","mediaEmpty","createEmptySelectors","el","sels","len","olen","CacheElements","_elements","shift","isJustParentSelector","extend","getIsOutput","selector","Value","Keyword","True","False","Rule","important","merge","inline","variable","allowRoot","lastRule","strictMathBypass","evaldValue","importantResult","makeImportant","rule","functionRegistry","defaultFunc","value_","error_","_default","debugInfo","ctx","lineSeparator","result","dumpLineNumbers","asComment","asMediaQuery","lineNumber","fileName","filenameWithProtocol","Ruleset","selectors","rules","strictImports","_lookups","thisSelectors","selCnt","hasOnePassingSelector","error","reset","ruleset","subRule","originalRuleset","root","firstRoot","allowImports","found","globalFunctionRegistry","inherit","ctxFrames","unshift","ctxSelectors","evalImports","rsRules","rsRuleCnt","evalFirst","mediaBlockCount","mediaBlocks","filter","apply","resetCache","j","bubbleSelectors","importRules","matchArgs","args","matchCondition","lastSelector","_rulesets","_variables","variables","reduce","hash","vars","rulesets","filtRules","cnt","isRuleset","prependRule","find","self","foundMixins","rule$$1","charsetRuleNodes","ruleNodes","tabLevel","tabRuleStr","tabSetStr","sep","charsetNodeIndex","importNodeIndex","isCharset","getDebugInfo","pathCnt","pathSubCnt","currentLastRule","isRulesetLike","joinSelectors","joinSelector","createParenthesis","elementsToPak","originalElement","replacementParen","insideParent","createSelector","containedElement","addReplacementIntoPath","beginningPath","addPath","replacedElement","originalSelector","newSelectorPath","newJoinedSelector","parentEl","restOfPath","selector$$1","addAllReplacementsIntoPath","addPaths","mergeElementsOnToSelectors","sel","replaceParentSelector","inSelector","k","currentElements","newSelectors","selectorsMultiplied","hadParentSelector","nestedSelector","maybeSelector","nestedPaths","replaced","replacedNewSelectors","replacementSelector","deriveSelector","deriveFrom","newPaths","concatenated","Directive","isRooted","outputRuleset","mediaPathBackup","mediaBlocksBackup","mediaPath","_len","_key","ruleCnt","directive","DetachedRuleset","callEval","detachedRuleset","unitConversions","PI","Unit","numerator","denominator","backupUnit","sort","strictUnits","returnStr","unitString","toUpperCase","isLength","isSingular","callback","usedUnits","group","mapUnit","groupName","atomicUnit","cancel","counter","count","toColor","strValue","String","substr","convertTo","unify","duration","angle","conversions","targetUnit","derivedConversions","applyUnit","dimension","Operation","operands","isSpaced","isRootVariable","simplify","cloneOp","parensInOp","operation","Variable","evaluating","current","frame","simplifyFilter","obj","fun","Attribute","attribute","JsEvalNode","evaluateJavaScript","expression","that","evalContext","javascriptEnabled","_","jsify","Function","jsEvalNode","Quoted","str","content","escaped","_JsEvalNode","quote","containsVariables","iterativeReplace","regexp","replacementFnc","evaluatedValue","javascriptReplacement","exp","interpolationReplacement","quoted","Comment","isLineComment","isSilent","isCompressed","comment","Expression","returnValue","parens","doubleParen","throwAwayComments","functionCaller","isValid","item","subNodes","functionCaller_1","Call","funcCaller","FunctionCaller","_isArray","_iterator","_i","Symbol","iterator","_ref","URL","isEvald","rootpath","urlArgs","delimiter","url","Anonymous","rulesetLike","anonymous","Media","features","_Directive","media","evalTop","evalNested","multiMedia","permute","fragment","arr","rest","Import","less","pathValue","getPath","plugin","reference","isVariableImport","evalForImport","evalPath","doEval","node$$2","registry","addMultiple","skip","importedFilename","newImport","_import","Definition","params","variadic","_Ruleset","arity","optionalParameters","required","p","evalParams","mixinEnv","evaldArguments","varargs","arg","isNamedFound","argIndex","argsLength","evalCall","_arguments","mixinFrames","allArgsCnt","requiredArgsCnt","mixinDefinition","MixinCall","mixins","mixin","mixinPath","argValue","m","f","isRecursive","isOneFound","candidates","candidate","conditionResult","defaultResult","defFalseEitherCase","defNone","defTrue","defFalse","noArgumentsFilter","expand","MixinDefinition","namespace","format","newRules","_setVisibilityToReplacement","replacement","mixinCall","JavaScript","string","javascript","Assignment","assignment","Condition","negate","lvalue","rvalue","UnicodeDescriptor","unicodeDescriptor","Negative","negative","Extend","option","object_id","next_id","parent_ids","allowBefore","allowAfter","findSelfSelectors","selfElements","selectorElements","selfSelectors","RulesetCall","rulesetCall","tree","require$$0","require$$1","require$$2","require$$3","require$$4","require$$5","require$$6","require$$7","require$$8","require$$9","require$$10","require$$11","require$$12","require$$13","require$$14","require$$15","require$$16","require$$17","require$$18","require$$19","require$$20","require$$21","require$$22","require$$23","require$$24","require$$25","require$$26","require$$27","require$$28","require$$29","require$$30","require$$31","require$$32","require$$33","require$$34","tree_1","_visitArgs","visitDeeper","_hasIndexed","Visitor","implementation","_implementation","_visitFnCache","nodeTypeIndex","visitFnCache","impl","aryIndx","outAryIndex","funcOut","visitArgs","fnName","newNode","isReplacing","nodes","nonReplacing","out","evald","flatten","nestedCnt","nestedItem","ImportSequencer","onSequencerEmpty","variableImports","_onSequencerEmpty","_currentDepth","addImport","importSequencer","importItem","isReady","tryRun","addVariableImport","variableImport","ImportVisitor","importer","finish","_visitor","_importer","_finish","importCount","onceFileDetectionMap","recursionDetector","_sequencer","isFinished","importNode","inlineCSS","importParent","processImportNode","evaldImportNode","multiple","importMultiple","tryAppendLessExtension","onImported","sequencedOnImported","importedAtRoot","fullPath","importVisitor","isPlugin","isOptional","optional","duplicateImport","oldContext","ruleNode","directiveNode","mixinDefinitionNode","rulesetNode","mediaNode","SetTreeVisibilityVisitor","visible","run","setTreeVisibilityVisitor","ExtendFinderVisitor","allExtendsStack","allExtends","visitRule","visitMixinDefinition","visitRuleset","allSelectorsExtendList","extendOnEveryPath","selectorPath","selExtendList","allSelectorsExtend","foundExtends","firstExtendOnThisSelectorPath","visitRulesetOut","visitMedia","visitMediaOut","visitDirective","visitDirectiveOut","ProcessExtendsVisitor","extendFinder","extendIndices","doExtendChaining","newRoot","checkExtendsForNonMatched","indices","hasFoundMatches","extendsList","extendsListTarget","iterationCount","extendIndex","targetExtendIndex","matches","extendsToAdd","extendVisitor","targetExtend","newExtend","findMatch","selfSelector","extendSelector","extendChainCount","selectorOne","selectorTwo","visitSelector","selectorNode","pathIndex","selectorsToAdd","extendedSelectors","haystackSelectorPath","haystackSelectorIndex","hackstackSelector","hackstackElementIndex","haystackElement","targetCombinator","needleElements","potentialMatches","potentialMatch","isElementValuesEqual","matched","finished","endPathIndex","endPathElementIndex","elementValue1","elementValue2","currentSelectorPathIndex","currentSelectorPathElementIndex","matchIndex","firstElement","newElements","initialCombinator","currentValue","derived","newAllExtends","JoinSelectorVisitor","joinSelectorVisitor","CSSVisitorUtils","_context","containsSilentNonBlockedChild","bodyRules","keepOnlyVisibleChilds","owner","thing","hasVisibleSelector","resolveVisibility","originalRules","compiledRulesBody","isVisibleRuleset","ToCSSVisitor","_level","simplifyLevel","mixinNode","commentNode","visitDirectiveWithBody","visitDirectiveWithoutBody","hasFakeRuleset","nodeRules","_mergeRules","charset","isRoot","checkValidNodes","_compileRulesetPaths","nodeRuleCnt","_removeDuplicateRules","ruleCache","ruleList","ruleCSS","groups","parts","toExpression","values","spacedGroups","lastSpacedGroup","anonymousNode","toCssVisitor","visitors","visitors_1","evaldRoot","evalEnv","preEvalVisitors","MarkVisibleSelectorsVisitor","ExtendVisitor","pluginVisitors","getVisitors","pluginVisitor","isPreEvalVisitor","isPreVisitor","SourceMapBuilder","sourceMapBuilder","transformTree","toCSSOptions","postProcessors","getPostProcessors","process","file","files","rootFilename","fail","emitChunk","force","chunkerCurrentIndex","emitFrom","level","parenLevel","lastOpening","lastOpeningParen","lastMultiComment","lastMultiCommentEndBrace","chunks","currentChunkStartIndex","cc","cc2","charCodeAt","fromCharCode","skipWhitespace","oldi","parserInput","oldj","curr","currentPos","endIndex","mem","inp","nextChar","autoCommentAbsorb","CHARCODE_FORWARD_SLASH","nextNewLine","text","commentStore","nextStarSlash","CHARCODE_SPACE","CHARCODE_LF","CHARCODE_TAB","CHARCODE_CR","save","restore","possibleErrorMessage","furthest","furthestPossibleErrorMessage","state","saveStack","forget","isWhitespace","offset","pos","code","$re","tok","exec","$char","$str","tokLength","$quoted","startChar","currentPosition","peek","peekChar","currentChar","getInput","peekNotNumeric","start","chunkInput","failFunction","chunker","end","Parser","expect","parsers","expectChar","getParserInput","additionalData","globalVars","modifyVars","ignored","preText","serializeVars","preProcessors","getPreProcessors","banner","primary","endInfo","furthestChar","furthestReachedEnd","processImports","extendRule","definition","entities","foundSemiColon","isEscaped","argsSemiColon","argsComma","expressions","isSemiColonSeparated","entity","curly","colorCandidateString","ud","js","escape","isRule","elemIndex","elem","isCall","returner","expressionContainsNamed","nameLoop","literal","cond","argInfo","conditions","block","variableCurly","slashedCombinator","isLess","when","blockRuleset","lessSelector","tryAnonymous","startOfRule","isVariable","ruleProperty","tryValueFirst","anonymousValue","dir","importOptions","mediaFeatures","o","optionName","importOption","opt","property","mediaFeature","nonVendorSpecificName","hasIdentifier","hasExpression","hasUnknown","hasBlock","addition","operand","multiplication","logical","next","conditionAnd","me","negatedCondition","parenthesisCondition","body","atomicCondition","sub","colorKeyword","delim","re","simpleProperty","loaded","rootFileInfo","mime","queue","fileParsedFunc","importedEqualsRoot","newFileInfo","relativeUrls","entryPath","tryAppendExtension","loadFileCallback","loadedFile","resolvedFilename","pathDiff","isPathAbsolute","alwaysMakePathsAbsolute","newEnv","FunctionImporter","parse","promise","loadFile","err","then","data","abstractFileManager","lastIndexOf","ext","supportsSync","basePath","laterPath","baseUrl","urlParts","extractUrlParts","baseUrlParts","urlDirectories","baseUrlDirectories","diff","hostPart","directories","urlPartsRegex","fileUrl","abstractFileManager_1","rgba","hue","m1","m2","hsva","floor","vs","perm","amount","method","hsl","weight","log","w","w1","w2","desaturate","dark","light","threshold","t","mix","colorBlendModeFunctions","multiply","screen","sqrt","overlay","abs","dataUri","fallback","functionThis","mimetypeNode","filePathNode","mimetype","filePath","fragmentStart","useBase64","mimeLookup","charsetLookup","fileSync","loadFileSync","buf","encodeURIComponent","uri","ieCompat","MathHelper","_math","fn","minMax","mathFunctions","mathHelper","fraction","num","isMin","currentUnified","referenceUnified","unitStatic","unitClone","order","_len2","_key2","y","evaluated","encodeURI","pattern","flags","RegExp","token","svg","direction","throwArgumentDescriptor","stops","gradientDirectionSvg","gradientType","rectangleDimension","renderEnv","directionValue","position","positionValue","isa","Type","isunit","getItemsFromNode","ParseTree","render","Promise","resolve","reject","PluginManager","installedPlugins","addPlugins","plugins","addPlugin","install","addVisitor","addPreProcessor","preProcessor","priority","indexToInsertAt","addPostProcessor","postProcessor","manager","ImportManager","silent","formatError","errorTxt","NotSupportedFileManager","supports","AbstractFileManager","createFromEnvironment","FileManager"],"mappings":"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","file":"less.min.js","sourcesContent":["const Node = require('./node')\nconst Value = require('./value')\nconst Keyword = require('./keyword')\n\nclass Rule extends Node {\n  constructor(\n    name,\n    value,\n    important,\n    merge,\n    index,\n    currentFileInfo,\n    inline,\n    variable\n  ) {\n    super()\n    this.name = name\n    this.value = value instanceof Node ? value : new Value([value]) //value instanceof tree.Value || value instanceof tree.Ruleset ??\n    this.important = important ? ` ${important.trim()}` : ''\n    this.merge = merge\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.inline = inline || false\n    this.variable =\n      variable !== undefined ? variable : name.charAt && name.charAt(0) === '@'\n    this.allowRoot = true\n  }\n\n  genCSS(context, output) {\n    output.add(\n      this.name + (context.compress ? ':' : ': '),\n      this.currentFileInfo,\n      this.index\n    )\n    try {\n      this.value.genCSS(context, output)\n    } catch (e) {\n      e.index = this.index\n      e.filename = this.currentFileInfo.filename\n      throw e\n    }\n    output.add(\n      this.important +\n        (this.inline || (context.lastRule && context.compress) ? '' : ';'),\n      this.currentFileInfo,\n      this.index\n    )\n  }\n\n  eval(context) {\n    let strictMathBypass = false\n    let name = this.name\n    let evaldValue\n    let variable = this.variable\n    if (typeof name !== 'string') {\n      // expand 'primitive' name directly to get\n      // things faster (~10% for benchmark.less):\n      name =\n        name.length === 1 && name[0] instanceof Keyword\n          ? name[0].value\n          : evalName(context, name)\n      variable = false // never treat expanded interpolation as new variable name\n    }\n    if (name === 'font' && !context.strictMath) {\n      strictMathBypass = true\n      context.strictMath = true\n    }\n    try {\n      context.importantScope.push({})\n      evaldValue = this.value.eval(context)\n\n      if (!this.variable && evaldValue.type === 'DetachedRuleset') {\n        throw {\n          message: 'Rulesets cannot be evaluated on a property.',\n          index: this.index,\n          filename: this.currentFileInfo.filename,\n        }\n      }\n      let important = this.important\n      const importantResult = context.importantScope.pop()\n      if (!important && importantResult.important) {\n        important = importantResult.important\n      }\n\n      return new Rule(\n        name,\n        evaldValue,\n        important,\n        this.merge,\n        this.index,\n        this.currentFileInfo,\n        this.inline,\n        variable\n      )\n    } catch (e) {\n      if (typeof e.index !== 'number') {\n        e.index = this.index\n        e.filename = this.currentFileInfo.filename\n      }\n      throw e\n    } finally {\n      if (strictMathBypass) {\n        context.strictMath = false\n      }\n    }\n  }\n\n  makeImportant() {\n    return new Rule(\n      this.name,\n      this.value,\n      '!important',\n      this.merge,\n      this.index,\n      this.currentFileInfo,\n      this.inline\n    )\n  }\n}\n\nfunction evalName(context, name) {\n  let value = ''\n  let i\n  const n = name.length\n  const output = {\n    add(s) {\n      value += s\n    },\n  }\n  for (i = 0; i < n; i++) {\n    name[i].eval(context).genCSS(context, output)\n  }\n  return value\n}\n\nRule.prototype.type = 'Rule'\n\nmodule.exports = Rule\n","function makeRegistry(base) {\n  return {\n    _data: {},\n    add(name, func) {\n      // precautionary case conversion, as later querying of\n      // the registry by function-caller uses lower case as well.\n      name = name.toLowerCase()\n\n      if (this._data.hasOwnProperty(name)) {\n        //TODO warn\n      }\n      this._data[name] = func\n    },\n    addMultiple(functions) {\n      Object.keys(functions).forEach(name => {\n        this.add(name, functions[name])\n      })\n    },\n    get(name) {\n      return this._data[name] || (base && base.get(name))\n    },\n    inherit() {\n      return makeRegistry(this)\n    },\n  }\n}\n\nmodule.exports = makeRegistry(null)\n","const tree = require('../tree')\n\nconst _visitArgs = { visitDeeper: true }\nlet _hasIndexed = false\n\nfunction _noop(node) {\n  return node\n}\n\nfunction indexNodeTypes(parent, ticker) {\n  // add .typeIndex to tree node types for lookup table\n  let key\n\n  let child\n  for (key in parent) {\n    if (parent.hasOwnProperty(key)) {\n      child = parent[key]\n      switch (typeof child) {\n        case 'function':\n          // ignore bound functions directly on tree which do not have a prototype\n          // or aren't nodes\n          if (child.prototype && child.prototype.type) {\n            child.prototype.typeIndex = ticker++\n          }\n          break\n        case 'object':\n          ticker = indexNodeTypes(child, ticker)\n          break\n      }\n    }\n  }\n  return ticker\n}\n\nclass Visitor {\n  constructor(implementation) {\n    this._implementation = implementation\n    this._visitFnCache = []\n\n    if (!_hasIndexed) {\n      indexNodeTypes(tree, 1)\n      _hasIndexed = true\n    }\n  }\n\n  visit(node) {\n    if (!node) {\n      return node\n    }\n\n    const nodeTypeIndex = node.typeIndex\n    if (!nodeTypeIndex) {\n      return node\n    }\n\n    const visitFnCache = this._visitFnCache\n    const impl = this._implementation\n    const aryIndx = nodeTypeIndex << 1\n    const outAryIndex = aryIndx | 1\n    let func = visitFnCache[aryIndx]\n    let funcOut = visitFnCache[outAryIndex]\n    const visitArgs = _visitArgs\n    let fnName\n\n    visitArgs.visitDeeper = true\n\n    if (!func) {\n      fnName = `visit${node.type}`\n      func = impl[fnName] || _noop\n      funcOut = impl[`${fnName}Out`] || _noop\n      visitFnCache[aryIndx] = func\n      visitFnCache[outAryIndex] = funcOut\n    }\n\n    if (func !== _noop) {\n      const newNode = func.call(impl, node, visitArgs)\n      if (impl.isReplacing) {\n        node = newNode\n      }\n    }\n\n    if (visitArgs.visitDeeper && node && node.accept) {\n      node.accept(this)\n    }\n\n    if (funcOut != _noop) {\n      funcOut.call(impl, node)\n    }\n\n    return node\n  }\n\n  visitArray(nodes, nonReplacing) {\n    if (!nodes) {\n      return nodes\n    }\n\n    const cnt = nodes.length\n    let i\n\n    // Non-replacing\n    if (nonReplacing || !this._implementation.isReplacing) {\n      for (i = 0; i < cnt; i++) {\n        this.visit(nodes[i])\n      }\n      return nodes\n    }\n\n    // Replacing\n    const out = []\n    for (i = 0; i < cnt; i++) {\n      const evald = this.visit(nodes[i])\n      if (evald === undefined) {\n        continue\n      }\n      if (!evald.splice) {\n        out.push(evald)\n      } else if (evald.length) {\n        this.flatten(evald, out)\n      }\n    }\n    return out\n  }\n\n  flatten(arr, out) {\n    if (!out) {\n      out = []\n    }\n\n    let cnt\n    let i\n    let item\n    let nestedCnt\n    let j\n    let nestedItem\n\n    for (i = 0, cnt = arr.length; i < cnt; i++) {\n      item = arr[i]\n      if (item === undefined) {\n        continue\n      }\n      if (!item.splice) {\n        out.push(item)\n        continue\n      }\n\n      for (j = 0, nestedCnt = item.length; j < nestedCnt; j++) {\n        nestedItem = item[j]\n        if (nestedItem === undefined) {\n          continue\n        }\n        if (!nestedItem.splice) {\n          out.push(nestedItem)\n        } else if (nestedItem.length) {\n          this.flatten(nestedItem, out)\n        }\n      }\n    }\n\n    return out\n  }\n}\n\nmodule.exports = Visitor\n","const Dimension = require('../tree/dimension')\nconst Color = require('../tree/color')\nconst Quoted = require('../tree/quoted')\nconst Anonymous = require('../tree/anonymous')\nconst functionRegistry = require('./function-registry')\nlet colorFunctions\n\nfunction clamp(val) {\n  return Math.min(1, Math.max(0, val))\n}\nfunction hsla(color) {\n  return colorFunctions.hsla(color.h, color.s, color.l, color.a)\n}\nfunction number(n) {\n  if (n instanceof Dimension) {\n    return parseFloat(n.unit.is('%') ? n.value / 100 : n.value)\n  } else if (typeof n === 'number') {\n    return n\n  } else {\n    throw {\n      type: 'Argument',\n      message: 'color functions take numbers as parameters',\n    }\n  }\n}\nfunction scaled(n, size) {\n  if (n instanceof Dimension && n.unit.is('%')) {\n    return parseFloat(n.value * size / 100)\n  } else {\n    return number(n)\n  }\n}\ncolorFunctions = {\n  rgb(r, g, b) {\n    return colorFunctions.rgba(r, g, b, 1.0)\n  },\n  rgba(r, g, b, a) {\n    const rgb = [r, g, b].map(c => scaled(c, 255))\n    a = number(a)\n    return new Color(rgb, a)\n  },\n  hsl(h, s, l) {\n    return colorFunctions.hsla(h, s, l, 1.0)\n  },\n  hsla(h, s, l, a) {\n    let m1\n    let m2\n\n    function hue(h) {\n      h = h < 0 ? h + 1 : h > 1 ? h - 1 : h\n      if (h * 6 < 1) {\n        return m1 + (m2 - m1) * h * 6\n      } else if (h * 2 < 1) {\n        return m2\n      } else if (h * 3 < 2) {\n        return m1 + (m2 - m1) * (2 / 3 - h) * 6\n      } else {\n        return m1\n      }\n    }\n\n    h = number(h) % 360 / 360\n    s = clamp(number(s))\n    l = clamp(number(l))\n    a = clamp(number(a))\n\n    m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s\n    m1 = l * 2 - m2\n\n    return colorFunctions.rgba(\n      hue(h + 1 / 3) * 255,\n      hue(h) * 255,\n      hue(h - 1 / 3) * 255,\n      a\n    )\n  },\n\n  hsv(h, s, v) {\n    return colorFunctions.hsva(h, s, v, 1.0)\n  },\n\n  hsva(h, s, v, a) {\n    h = number(h) % 360 / 360 * 360\n    s = number(s)\n    v = number(v)\n    a = number(a)\n\n    let i\n    let f\n    i = Math.floor(h / 60 % 6)\n    f = h / 60 - i\n\n    const vs = [v, v * (1 - s), v * (1 - f * s), v * (1 - (1 - f) * s)]\n    const perm = [\n      [0, 3, 1],\n      [2, 0, 1],\n      [1, 0, 3],\n      [1, 2, 0],\n      [3, 1, 0],\n      [0, 1, 2],\n    ]\n\n    return colorFunctions.rgba(\n      vs[perm[i][0]] * 255,\n      vs[perm[i][1]] * 255,\n      vs[perm[i][2]] * 255,\n      a\n    )\n  },\n\n  hue(color) {\n    return new Dimension(color.toHSL().h)\n  },\n  saturation(color) {\n    return new Dimension(color.toHSL().s * 100, '%')\n  },\n  lightness(color) {\n    return new Dimension(color.toHSL().l * 100, '%')\n  },\n  hsvhue(color) {\n    return new Dimension(color.toHSV().h)\n  },\n  hsvsaturation(color) {\n    return new Dimension(color.toHSV().s * 100, '%')\n  },\n  hsvvalue(color) {\n    return new Dimension(color.toHSV().v * 100, '%')\n  },\n  red(color) {\n    return new Dimension(color.rgb[0])\n  },\n  green(color) {\n    return new Dimension(color.rgb[1])\n  },\n  blue(color) {\n    return new Dimension(color.rgb[2])\n  },\n  alpha(color) {\n    return new Dimension(color.toHSL().a)\n  },\n  luma(color) {\n    return new Dimension(color.luma() * color.alpha * 100, '%')\n  },\n  luminance(color) {\n    const luminance =\n      0.2126 * color.rgb[0] / 255 +\n      0.7152 * color.rgb[1] / 255 +\n      0.0722 * color.rgb[2] / 255\n\n    return new Dimension(luminance * color.alpha * 100, '%')\n  },\n  saturate(color, amount, method) {\n    // filter: saturate(3.2);\n    // should be kept as is, so check for color\n    if (!color.rgb) {\n      return null\n    }\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.s += hsl.s * amount.value / 100\n    } else {\n      hsl.s += amount.value / 100\n    }\n    hsl.s = clamp(hsl.s)\n    return hsla(hsl)\n  },\n  desaturate(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.s -= hsl.s * amount.value / 100\n    } else {\n      hsl.s -= amount.value / 100\n    }\n    hsl.s = clamp(hsl.s)\n    return hsla(hsl)\n  },\n  lighten(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.l += hsl.l * amount.value / 100\n    } else {\n      hsl.l += amount.value / 100\n    }\n    hsl.l = clamp(hsl.l)\n    return hsla(hsl)\n  },\n  darken(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.l -= hsl.l * amount.value / 100\n    } else {\n      hsl.l -= amount.value / 100\n    }\n    hsl.l = clamp(hsl.l)\n    return hsla(hsl)\n  },\n  fadein(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.a += hsl.a * amount.value / 100\n    } else {\n      hsl.a += amount.value / 100\n    }\n    hsl.a = clamp(hsl.a)\n    return hsla(hsl)\n  },\n  fadeout(color, amount, method) {\n    const hsl = color.toHSL()\n\n    if (typeof method !== 'undefined' && method.value === 'relative') {\n      hsl.a -= hsl.a * amount.value / 100\n    } else {\n      hsl.a -= amount.value / 100\n    }\n    hsl.a = clamp(hsl.a)\n    return hsla(hsl)\n  },\n  fade(color, amount) {\n    const hsl = color.toHSL()\n\n    hsl.a = amount.value / 100\n    hsl.a = clamp(hsl.a)\n    return hsla(hsl)\n  },\n  spin(color, amount) {\n    const hsl = color.toHSL()\n    const hue = (hsl.h + amount.value) % 360\n\n    hsl.h = hue < 0 ? 360 + hue : hue\n\n    return hsla(hsl)\n  },\n  //\n  // Copyright (c) 2006-2009 Hampton Catlin, Natalie Weizenbaum, and Chris Eppstein\n  // http://sass-lang.com\n  //\n  mix(color1, color2, weight) {\n    if (!color1.toHSL || !color2.toHSL) {\n      console.log(color2.type)\n      console.dir(color2)\n    }\n    if (!weight) {\n      weight = new Dimension(50)\n    }\n    const p = weight.value / 100.0\n    const w = p * 2 - 1\n    const a = color1.toHSL().a - color2.toHSL().a\n\n    const w1 = ((w * a == -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0\n    const w2 = 1 - w1\n\n    const rgb = [\n      color1.rgb[0] * w1 + color2.rgb[0] * w2,\n      color1.rgb[1] * w1 + color2.rgb[1] * w2,\n      color1.rgb[2] * w1 + color2.rgb[2] * w2,\n    ]\n\n    const alpha = color1.alpha * p + color2.alpha * (1 - p)\n\n    return new Color(rgb, alpha)\n  },\n  greyscale(color) {\n    return colorFunctions.desaturate(color, new Dimension(100))\n  },\n  contrast(color, dark, light, threshold) {\n    // filter: contrast(3.2);\n    // should be kept as is, so check for color\n    if (!color.rgb) {\n      return null\n    }\n    if (typeof light === 'undefined') {\n      light = colorFunctions.rgba(255, 255, 255, 1.0)\n    }\n    if (typeof dark === 'undefined') {\n      dark = colorFunctions.rgba(0, 0, 0, 1.0)\n    }\n    //Figure out which is actually light and dark!\n    if (dark.luma() > light.luma()) {\n      const t = light\n      light = dark\n      dark = t\n    }\n    if (typeof threshold === 'undefined') {\n      threshold = 0.43\n    } else {\n      threshold = number(threshold)\n    }\n    if (color.luma() < threshold) {\n      return light\n    } else {\n      return dark\n    }\n  },\n  argb(color) {\n    return new Anonymous(color.toARGB())\n  },\n  color(c) {\n    if (c instanceof Quoted && /^#([a-f0-9]{6}|[a-f0-9]{3})$/i.test(c.value)) {\n      return new Color(c.value.slice(1))\n    }\n    if (c instanceof Color || (c = Color.fromKeyword(c.value))) {\n      c.value = undefined\n      return c\n    }\n    throw {\n      type: 'Argument',\n      message: 'argument must be a color keyword or 3/6 digit hex e.g. #FFF',\n    }\n  },\n  tint(color, amount) {\n    return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color, amount)\n  },\n  shade(color, amount) {\n    return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color, amount)\n  },\n}\nfunctionRegistry.addMultiple(colorFunctions)\n","const Color = require('../tree/color')\nconst functionRegistry = require('./function-registry')\n\n// Color Blending\n// ref: http://www.w3.org/TR/compositing-1\n\nfunction colorBlend(mode, color1, color2) {\n  const ab = color1.alpha // result\n\n  let // backdrop\n  cb\n\n  const as = color2.alpha\n\n  let // source\n  cs\n\n  let ar\n  let cr\n  const r = []\n\n  ar = as + ab * (1 - as)\n  for (let i = 0; i < 3; i++) {\n    cb = color1.rgb[i] / 255\n    cs = color2.rgb[i] / 255\n    cr = mode(cb, cs)\n    if (ar) {\n      cr = (as * cs + ab * (cb - as * (cb + cs - cr))) / ar\n    }\n    r[i] = cr * 255\n  }\n\n  return new Color(r, ar)\n}\n\nconst colorBlendModeFunctions = {\n  multiply(cb, cs) {\n    return cb * cs\n  },\n  screen(cb, cs) {\n    return cb + cs - cb * cs\n  },\n  overlay(cb, cs) {\n    cb *= 2\n    return cb <= 1\n      ? colorBlendModeFunctions.multiply(cb, cs)\n      : colorBlendModeFunctions.screen(cb - 1, cs)\n  },\n  softlight(cb, cs) {\n    let d = 1\n    let e = cb\n    if (cs > 0.5) {\n      e = 1\n      d = cb > 0.25 ? Math.sqrt(cb) : ((16 * cb - 12) * cb + 4) * cb\n    }\n    return cb - (1 - 2 * cs) * e * (d - cb)\n  },\n  hardlight(cb, cs) {\n    return colorBlendModeFunctions.overlay(cs, cb)\n  },\n  difference(cb, cs) {\n    return Math.abs(cb - cs)\n  },\n  exclusion(cb, cs) {\n    return cb + cs - 2 * cb * cs\n  },\n\n  // non-w3c functions:\n  average(cb, cs) {\n    return (cb + cs) / 2\n  },\n  negation(cb, cs) {\n    return 1 - Math.abs(cb + cs - 1)\n  },\n}\n\nfor (const f in colorBlendModeFunctions) {\n  if (colorBlendModeFunctions.hasOwnProperty(f)) {\n    colorBlend[f] = colorBlend.bind(null, colorBlendModeFunctions[f])\n  }\n}\n\nfunctionRegistry.addMultiple(colorBlend)\n","module.exports = {\n  error(msg) {\n    this._fireEvent('error', msg)\n  },\n  warn(msg) {\n    this._fireEvent('warn', msg)\n  },\n  info(msg) {\n    this._fireEvent('info', msg)\n  },\n  debug(msg) {\n    this._fireEvent('debug', msg)\n  },\n  addListener(listener) {\n    this._listeners.push(listener)\n  },\n  removeListener(listener) {\n    for (let i = 0; i < this._listeners.length; i++) {\n      if (this._listeners[i] === listener) {\n        this._listeners.splice(i, 1)\n        return\n      }\n    }\n  },\n  _fireEvent(type, msg) {\n    for (let i = 0; i < this._listeners.length; i++) {\n      const logFunction = this._listeners[i][type]\n      if (logFunction) {\n        logFunction(msg)\n      }\n    }\n  },\n  _listeners: [],\n}\n","const logger = require('../logger')\n\nclass Environment {\n  constructor(externalEnvironment, fileManagers) {\n    this.fileManagers = fileManagers || []\n    externalEnvironment = externalEnvironment || {}\n\n    const optionalFunctions = [\n      'encodeBase64',\n      'mimeLookup',\n      'charsetLookup',\n      'getSourceMapGenerator',\n    ]\n    const requiredFunctions = []\n    const functions = requiredFunctions.concat(optionalFunctions)\n\n    for (let i = 0; i < functions.length; i++) {\n      const propName = functions[i]\n      const environmentFunc = externalEnvironment[propName]\n      if (environmentFunc) {\n        this[propName] = environmentFunc.bind(externalEnvironment)\n      } else if (i < requiredFunctions.length) {\n        this.warn(`missing required function in environment - ${propName}`)\n      }\n    }\n  }\n\n  getFileManager(filename, currentDirectory, options, environment, isSync) {\n    if (!filename) {\n      logger.warn(\n        'getFileManager called with no filename.. Please report this issue. continuing.'\n      )\n    }\n    if (!currentDirectory) {\n      logger.warn(\n        'getFileManager called with null directory.. Please report this issue. continuing.'\n      )\n    }\n\n    let fileManagers = this.fileManagers\n    if (options.pluginManager) {\n      fileManagers = []\n        .concat(fileManagers)\n        .concat(options.pluginManager.getFileManagers())\n    }\n    for (let i = fileManagers.length - 1; i >= 0; i--) {\n      const fileManager = fileManagers[i]\n      if (\n        fileManager[isSync ? 'supportsSync' : 'supports'](\n          filename,\n          currentDirectory,\n          options,\n          environment\n        )\n      ) {\n        return fileManager\n      }\n    }\n    return null\n  }\n\n  addFileManager(fileManager) {\n    this.fileManagers.push(fileManager)\n  }\n\n  clearFileManagers() {\n    this.fileManagers = []\n  }\n}\n\nmodule.exports = Environment\n","module.exports = environment => {\n  class SourceMapOutput {\n    constructor(options) {\n      this._css = []\n      this._rootNode = options.rootNode\n      this._contentsMap = options.contentsMap\n      this._contentsIgnoredCharsMap = options.contentsIgnoredCharsMap\n      if (options.sourceMapFilename) {\n        this._sourceMapFilename = options.sourceMapFilename.replace(/\\\\/g, '/')\n      }\n      this._outputFilename = options.outputFilename\n      this.sourceMapURL = options.sourceMapURL\n      if (options.sourceMapBasepath) {\n        this._sourceMapBasepath = options.sourceMapBasepath.replace(/\\\\/g, '/')\n      }\n      if (options.sourceMapRootpath) {\n        this._sourceMapRootpath = options.sourceMapRootpath.replace(/\\\\/g, '/')\n        if (\n          this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !==\n          '/'\n        ) {\n          this._sourceMapRootpath += '/'\n        }\n      } else {\n        this._sourceMapRootpath = ''\n      }\n      this._outputSourceFiles = options.outputSourceFiles\n      this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator()\n\n      this._lineNumber = 0\n      this._column = 0\n    }\n\n    normalizeFilename(filename) {\n      filename = filename.replace(/\\\\/g, '/')\n\n      if (\n        this._sourceMapBasepath &&\n        filename.indexOf(this._sourceMapBasepath) === 0\n      ) {\n        filename = filename.substring(this._sourceMapBasepath.length)\n        if (filename.charAt(0) === '\\\\' || filename.charAt(0) === '/') {\n          filename = filename.substring(1)\n        }\n      }\n      return (this._sourceMapRootpath || '') + filename\n    }\n\n    add(chunk, fileInfo, index, mapLines) {\n      //ignore adding empty strings\n      if (!chunk) {\n        return\n      }\n\n      let lines\n      let sourceLines\n      let columns\n      let sourceColumns\n      let i\n\n      if (fileInfo) {\n        let inputSource = this._contentsMap[fileInfo.filename]\n\n        // remove vars/banner added to the top of the file\n        if (this._contentsIgnoredCharsMap[fileInfo.filename]) {\n          // adjust the index\n          index -= this._contentsIgnoredCharsMap[fileInfo.filename]\n          if (index < 0) {\n            index = 0\n          }\n          // adjust the source\n          inputSource = inputSource.slice(\n            this._contentsIgnoredCharsMap[fileInfo.filename]\n          )\n        }\n        inputSource = inputSource.substring(0, index)\n        sourceLines = inputSource.split('\\n')\n        sourceColumns = sourceLines[sourceLines.length - 1]\n      }\n\n      lines = chunk.split('\\n')\n      columns = lines[lines.length - 1]\n\n      if (fileInfo) {\n        if (!mapLines) {\n          this._sourceMapGenerator.addMapping({\n            generated: { line: this._lineNumber + 1, column: this._column },\n            original: {\n              line: sourceLines.length,\n              column: sourceColumns.length,\n            },\n            source: this.normalizeFilename(fileInfo.filename),\n          })\n        } else {\n          for (i = 0; i < lines.length; i++) {\n            this._sourceMapGenerator.addMapping({\n              generated: {\n                line: this._lineNumber + i + 1,\n                column: i === 0 ? this._column : 0,\n              },\n              original: {\n                line: sourceLines.length + i,\n                column: i === 0 ? sourceColumns.length : 0,\n              },\n              source: this.normalizeFilename(fileInfo.filename),\n            })\n          }\n        }\n      }\n\n      if (lines.length === 1) {\n        this._column += columns.length\n      } else {\n        this._lineNumber += lines.length - 1\n        this._column = columns.length\n      }\n\n      this._css.push(chunk)\n    }\n\n    isEmpty() {\n      return this._css.length === 0\n    }\n\n    toCSS(context) {\n      this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({\n        file: this._outputFilename,\n        sourceRoot: null,\n      })\n\n      if (this._outputSourceFiles) {\n        for (const filename in this._contentsMap) {\n          if (this._contentsMap.hasOwnProperty(filename)) {\n            let source = this._contentsMap[filename]\n            if (this._contentsIgnoredCharsMap[filename]) {\n              source = source.slice(this._contentsIgnoredCharsMap[filename])\n            }\n            this._sourceMapGenerator.setSourceContent(\n              this.normalizeFilename(filename),\n              source\n            )\n          }\n        }\n      }\n\n      this._rootNode.genCSS(context, this)\n\n      if (this._css.length > 0) {\n        let sourceMapURL\n        const sourceMapContent = JSON.stringify(\n          this._sourceMapGenerator.toJSON()\n        )\n\n        if (this.sourceMapURL) {\n          sourceMapURL = this.sourceMapURL\n        } else if (this._sourceMapFilename) {\n          sourceMapURL = this._sourceMapFilename\n        }\n        this.sourceMapURL = sourceMapURL\n\n        this.sourceMap = sourceMapContent\n      }\n\n      return this._css.join('')\n    }\n  }\n\n  return SourceMapOutput\n}\n","module.exports = (SourceMapOutput, environment) => {\n  class SourceMapBuilder {\n    constructor(options) {\n      this.options = options\n    }\n\n    toCSS(rootNode, options, imports) {\n      const sourceMapOutput = new SourceMapOutput({\n        contentsIgnoredCharsMap: imports.contentsIgnoredChars,\n        rootNode,\n        contentsMap: imports.contents,\n        sourceMapFilename: this.options.sourceMapFilename,\n        sourceMapURL: this.options.sourceMapURL,\n        outputFilename: this.options.sourceMapOutputFilename,\n        sourceMapBasepath: this.options.sourceMapBasepath,\n        sourceMapRootpath: this.options.sourceMapRootpath,\n        outputSourceFiles: this.options.outputSourceFiles,\n        sourceMapGenerator: this.options.sourceMapGenerator,\n        sourceMapFileInline: this.options.sourceMapFileInline,\n      })\n\n      const css = sourceMapOutput.toCSS(options)\n      this.sourceMap = sourceMapOutput.sourceMap\n      this.sourceMapURL = sourceMapOutput.sourceMapURL\n      if (this.options.sourceMapInputFilename) {\n        this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(\n          this.options.sourceMapInputFilename\n        )\n      }\n      return css + this.getCSSAppendage()\n    }\n\n    getCSSAppendage() {\n      let sourceMapURL = this.sourceMapURL\n      if (this.options.sourceMapFileInline) {\n        if (this.sourceMap === undefined) {\n          return ''\n        }\n        sourceMapURL = `data:application/json;base64,${environment.encodeBase64(\n          this.sourceMap\n        )}`\n      }\n\n      if (sourceMapURL) {\n        return `/*# sourceMappingURL=${sourceMapURL} */`\n      }\n      return ''\n    }\n\n    getExternalSourceMap() {\n      return this.sourceMap\n    }\n\n    setExternalSourceMap(sourceMap) {\n      this.sourceMap = sourceMap\n    }\n\n    isInline() {\n      return this.options.sourceMapFileInline\n    }\n\n    getSourceMapURL() {\n      return this.sourceMapURL\n    }\n\n    getOutputFilename() {\n      return this.options.sourceMapOutputFilename\n    }\n\n    getInputFilename() {\n      return this.sourceMapInputFilename\n    }\n  }\n\n  return SourceMapBuilder\n}\n","module.exports = {\n  getLocation(index, inputStream) {\n    let n = index + 1\n    let line = null\n    let column = -1\n\n    while (--n >= 0 && inputStream.charAt(n) !== '\\n') {\n      column++\n    }\n\n    if (typeof index === 'number') {\n      line = (inputStream.slice(0, index).match(/\\n/g) || '').length\n    }\n\n    return {\n      line,\n      column,\n    }\n  },\n}\n","const utils = require('./utils')\n\nconst LessError = (module.exports = function LessError(\n  e,\n  importManager,\n  currentFilename\n) {\n  Error.call(this)\n\n  const filename = e.filename || currentFilename\n\n  if (importManager && filename) {\n    const input = importManager.contents[filename]\n    const loc = utils.getLocation(e.index, input)\n    const line = loc.line\n    const col = loc.column\n    const callLine = e.call && utils.getLocation(e.call, input).line\n    const lines = input.split('\\n')\n\n    this.type = e.type || 'Syntax'\n    this.filename = filename\n    this.index = e.index\n    this.line = typeof line === 'number' ? line + 1 : null\n    this.callLine = callLine + 1\n    this.callExtract = lines[callLine]\n    this.column = col\n    this.extract = [lines[line - 1], lines[line], lines[line + 1]]\n  }\n  this.message = e.message\n  this.stack = e.stack\n})\n\nif (typeof Object.create === 'undefined') {\n  const F = () => {}\n  F.prototype = Error.prototype\n  LessError.prototype = new F()\n} else {\n  LessError.prototype = Object.create(Error.prototype)\n}\n\nLessError.prototype.constructor = LessError\n","const contexts = {}\nmodule.exports = contexts\n\nconst copyFromOriginal = function copyFromOriginal(\n  original,\n  destination,\n  propertiesToCopy\n) {\n  if (!original) {\n    return\n  }\n\n  for (let i = 0; i < propertiesToCopy.length; i++) {\n    if (original.hasOwnProperty(propertiesToCopy[i])) {\n      destination[propertiesToCopy[i]] = original[propertiesToCopy[i]]\n    }\n  }\n}\n\n/*\n parse is used whilst parsing\n */\nconst parseCopyProperties = [\n  // options\n  'paths', // option - unmodified - paths to search for imports on\n  'relativeUrls', // option - whether to adjust URL's to be relative\n  'rootpath', // option - rootpath to append to URL's\n  'strictImports', // option -\n  'insecure', // option - whether to allow imports from insecure ssl hosts\n  'dumpLineNumbers', // option - whether to dump line numbers\n  'compress', // option - whether to compress\n  'syncImport', // option - whether to import synchronously\n  'chunkInput', // option - whether to chunk input. more performant but causes parse issues.\n  'mime', // browser only - mime type for sheet import\n  'useFileCache', // browser only - whether to use the per file session cache\n  // context\n  'processImports', // option & context - whether to process imports. if false then imports will not be imported.\n  // Used by the import manager to stop multiple import visitors being created.\n  'pluginManager', // Used as the plugin manager for the session\n]\n\ncontexts.Parse = function(options) {\n  copyFromOriginal(options, this, parseCopyProperties)\n\n  if (typeof this.paths === 'string') {\n    this.paths = [this.paths]\n  }\n}\n\nconst evalCopyProperties = [\n  'paths', // additional include paths\n  'compress', // whether to compress\n  'ieCompat', // whether to enforce IE compatibility (IE8 data-uri)\n  'disableMath', // whether math enabled\n  'strictMath', // whether math has to be within parenthesis\n  'strictUnits', // whether units need to evaluate correctly\n  'sourceMap', // whether to output a source map\n  'importMultiple', // whether we are currently importing multiple copies\n  'urlArgs', // whether to add args into url tokens\n  'javascriptEnabled', // option - whether JavaScript is enabled. if undefined, defaults to true\n  'pluginManager', // Used as the plugin manager for the session\n  'importantScope', // used to bubble up !important statements,\n  'simplify', //Simplify less\n  'simplifyFilter', //Simplify variable filter\n]\n\ncontexts.Eval = function(options, frames) {\n  copyFromOriginal(options, this, evalCopyProperties)\n\n  if (typeof this.paths === 'string') {\n    this.paths = [this.paths]\n  }\n\n  this.frames = frames || []\n  this.importantScope = this.importantScope || []\n}\n\ncontexts.Eval.prototype.inParenthesis = function() {\n  if (!this.parensStack) {\n    this.parensStack = []\n  }\n  this.parensStack.push(true)\n}\n\ncontexts.Eval.prototype.outOfParenthesis = function() {\n  this.parensStack.pop()\n}\ncontexts.Eval.prototype.isInParens = function() {\n  return !!(this.parensStack && this.parensStack.length > 0)\n}\n\ncontexts.Eval.prototype.inCall = function() {\n  if (!this.callStack) {\n    this.callStack = []\n  }\n  this.callStack.push(true)\n}\n\ncontexts.Eval.prototype.outOfCall = function() {\n  this.callStack.pop()\n}\n\ncontexts.Eval.prototype.isInCall = function() {\n  return !!(this.callStack && this.callStack.length > 0)\n}\n\ncontexts.Eval.prototype.isMathOn = function() {\n  return !this.disableMath && (this.strictMath ? this.isInParens() : true)\n}\n\ncontexts.Eval.prototype.isPathRelative = path =>\n  !/^(?:[a-z-]+:|\\/|#)/i.test(path)\n\ncontexts.Eval.prototype.normalizePath = path => {\n  const segments = path.split('/').reverse()\n  let segment\n\n  path = []\n  while (segments.length !== 0) {\n    segment = segments.pop()\n    switch (segment) {\n      case '.':\n        break\n      case '..':\n        if (path.length === 0 || path[path.length - 1] === '..') {\n          path.push(segment)\n        } else {\n          path.pop()\n        }\n        break\n      default:\n        path.push(segment)\n        break\n    }\n  }\n\n  return path.join('/')\n}\n\n//todo - do the same for the toCSS ?\n","class Node {\n  toCSS(context) {\n    const strs = []\n    this.genCSS(context, {\n      add(chunk, fileInfo, index) {\n        strs.push(chunk)\n      },\n      isEmpty() {\n        return strs.length === 0\n      },\n    })\n    return strs.join('')\n  }\n\n  genCSS(context, output) {\n    output.add(this.value)\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  eval() {\n    return this\n  }\n\n  _operate(context, op, a, b) {\n    switch (op) {\n      case '+':\n        return a + b\n      case '-':\n        return a - b\n      case '*':\n        return a * b\n      case '/':\n        return a / b\n    }\n  }\n\n  fround(context, value) {\n    const precision = context && context.numPrecision\n    //add \"epsilon\" to ensure numbers like 1.000000005 (represented as 1.000000004999....) are properly rounded...\n    return precision == null\n      ? value\n      : Number((value + 2e-16).toFixed(precision))\n  }\n\n  // Returns true if this node represents root of ast imported by reference\n  blocksVisibility() {\n    if (this.visibilityBlocks == null) {\n      this.visibilityBlocks = 0\n    }\n    return this.visibilityBlocks !== 0\n  }\n\n  addVisibilityBlock() {\n    if (this.visibilityBlocks == null) {\n      this.visibilityBlocks = 0\n    }\n    this.visibilityBlocks = this.visibilityBlocks + 1\n  }\n\n  removeVisibilityBlock() {\n    if (this.visibilityBlocks == null) {\n      this.visibilityBlocks = 0\n    }\n    this.visibilityBlocks = this.visibilityBlocks - 1\n  }\n\n  //Turns on node visibility - if called node will be shown in output regardless\n  //of whether it comes from import by reference or not\n  ensureVisibility() {\n    this.nodeVisible = true\n  }\n\n  //Turns off node visibility - if called node will NOT be shown in output regardless\n  //of whether it comes from import by reference or not\n  ensureInvisibility() {\n    this.nodeVisible = false\n  }\n\n  // return values:\n  // false - the node must not be visible\n  // true - the node must be visible\n  // undefined or null - the node has the same visibility as its parent\n  isVisible() {\n    return this.nodeVisible\n  }\n\n  visibilityInfo() {\n    return {\n      visibilityBlocks: this.visibilityBlocks,\n      nodeVisible: this.nodeVisible,\n    }\n  }\n\n  copyVisibilityInfo(info) {\n    if (!info) {\n      return\n    }\n    this.visibilityBlocks = info.visibilityBlocks\n    this.nodeVisible = info.nodeVisible\n  }\n}\n\nNode.compare = (a, b) => {\n  /* returns:\n     -1: a < b\n     0: a = b\n     1: a > b\n     and *any* other value for a != b (e.g. undefined, NaN, -2 etc.) */\n\n  if (\n    a.compare &&\n    // for \"symmetric results\" force toCSS-based comparison\n    // of Quoted or Anonymous if either value is one of those\n    !(b.type === 'Quoted' || b.type === 'Anonymous')\n  ) {\n    return a.compare(b)\n  } else if (b.compare) {\n    return -b.compare(a)\n  } else if (a.type !== b.type) {\n    return undefined\n  }\n\n  a = a.value\n  b = b.value\n  if (!Array.isArray(a)) {\n    return a === b ? 0 : undefined\n  }\n  if (a.length !== b.length) {\n    return undefined\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Node.compare(a[i], b[i]) !== 0) {\n      return undefined\n    }\n  }\n  return 0\n}\n\nNode.numericCompare = (a, b) =>\n  a < b ? -1 : a === b ? 0 : a > b ? 1 : undefined\nmodule.exports = Node\n","const Node = require('./node')\n\nclass Alpha extends Node {\n  constructor(val) {\n    super()\n    this.value = val\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  eval(context) {\n    if (this.value.eval) {\n      return new Alpha(this.value.eval(context))\n    }\n    return this\n  }\n\n  genCSS(context, output) {\n    output.add('alpha(opacity=')\n\n    if (this.value.genCSS) {\n      this.value.genCSS(context, output)\n    } else {\n      output.add(this.value)\n    }\n\n    output.add(')')\n  }\n}\n\nAlpha.prototype.type = 'Alpha'\n\nmodule.exports = Alpha\n","module.exports = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#00ffff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000000',\n  blanchedalmond: '#ffebcd',\n  blue: '#0000ff',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#00ffff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgrey: '#a9a9a9',\n  darkgreen: '#006400',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkslategrey: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dimgrey: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#ff00ff',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  grey: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  indianred: '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgray: '#d3d3d3',\n  lightgrey: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightslategrey: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#00ff00',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370d8',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#d87093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#ff0000',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  slategrey: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#ffffff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ffff00',\n  yellowgreen: '#9acd32',\n}\n","const Node = require('./node')\nconst colors = require('../data/colors')\n\n//\n// RGB Colors - #ff0014, #eee\n//\nclass Color extends Node {\n  constructor(rgb, a, originalForm) {\n    super()\n    //\n    // The end goal here, is to parse the arguments\n    // into an integer triplet, such as `128, 255, 0`\n    //\n    // This facilitates operations and conversions.\n    //\n    if (Array.isArray(rgb)) {\n      this.rgb = rgb\n    } else if (rgb.length == 6) {\n      this.rgb = rgb.match(/.{2}/g).map(c => parseInt(c, 16))\n    } else {\n      this.rgb = rgb.split('').map(c => parseInt(c + c, 16))\n    }\n    this.alpha = typeof a === 'number' ? a : 1\n    if (typeof originalForm !== 'undefined') {\n      this.value = originalForm\n    }\n  }\n\n  luma() {\n    let r = this.rgb[0] / 255\n    let g = this.rgb[1] / 255\n    let b = this.rgb[2] / 255\n\n    r = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4)\n    g = g <= 0.03928 ? g / 12.92 : Math.pow((g + 0.055) / 1.055, 2.4)\n    b = b <= 0.03928 ? b / 12.92 : Math.pow((b + 0.055) / 1.055, 2.4)\n\n    return 0.2126 * r + 0.7152 * g + 0.0722 * b\n  }\n\n  genCSS(context, output) {\n    output.add(this.toCSS(context))\n  }\n\n  toCSS(context, doNotCompress) {\n    const compress = context && context.compress && !doNotCompress\n    let color\n    let alpha\n\n    // `value` is set if this color was originally\n    // converted from a named color string so we need\n    // to respect this and try to output named color too.\n    if (this.value) {\n      return this.value\n    }\n\n    // If we have some transparency, the only way to represent it\n    // is via `rgba`. Otherwise, we use the hex representation,\n    // which has better compatibility with older browsers.\n    // Values are capped between `0` and `255`, rounded and zero-padded.\n    alpha = this.fround(context, this.alpha)\n    if (alpha < 1) {\n      return `rgba(${this.rgb\n        .map(c => clamp(Math.round(c), 255))\n        .concat(clamp(alpha, 1))\n        .join(',' + (compress ? '' : ' '))})`\n    }\n\n    color = this.toRGB()\n\n    if (compress) {\n      const splitcolor = color.split('')\n\n      // Convert color to short format\n      if (\n        splitcolor[1] === splitcolor[2] &&\n        splitcolor[3] === splitcolor[4] &&\n        splitcolor[5] === splitcolor[6]\n      ) {\n        color = `#${splitcolor[1]}${splitcolor[3]}${splitcolor[5]}`\n      }\n    }\n\n    return color\n  }\n\n  //\n  // Operations have to be done per-channel, if not,\n  // channels will spill onto each other. Once we have\n  // our result, in the form of an integer triplet,\n  // we create a new Color node to hold the result.\n  //\n  operate(context, op, other) {\n    const rgb = []\n    const alpha = this.alpha * (1 - other.alpha) + other.alpha\n    for (let c = 0; c < 3; c++) {\n      rgb[c] = this._operate(context, op, this.rgb[c], other.rgb[c])\n    }\n    return new Color(rgb, alpha)\n  }\n\n  toRGB() {\n    return toHex(this.rgb)\n  }\n\n  toHSL() {\n    const r = this.rgb[0] / 255\n    const g = this.rgb[1] / 255\n    const b = this.rgb[2] / 255\n    const a = this.alpha\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    let h\n    let s\n    const l = (max + min) / 2\n    const d = max - min\n\n    if (max === min) {\n      h = s = 0\n    } else {\n      s = l > 0.5 ? d / (2 - max - min) : d / (max + min)\n\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0)\n          break\n        case g:\n          h = (b - r) / d + 2\n          break\n        case b:\n          h = (r - g) / d + 4\n          break\n      }\n      h /= 6\n    }\n    return { h: h * 360, s, l, a }\n  }\n\n  //Adapted from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n  toHSV() {\n    const r = this.rgb[0] / 255\n    const g = this.rgb[1] / 255\n    const b = this.rgb[2] / 255\n    const a = this.alpha\n    const max = Math.max(r, g, b)\n    const min = Math.min(r, g, b)\n    let h\n    let s\n    const v = max\n\n    const d = max - min\n    if (max === 0) {\n      s = 0\n    } else {\n      s = d / max\n    }\n\n    if (max === min) {\n      h = 0\n    } else {\n      switch (max) {\n        case r:\n          h = (g - b) / d + (g < b ? 6 : 0)\n          break\n        case g:\n          h = (b - r) / d + 2\n          break\n        case b:\n          h = (r - g) / d + 4\n          break\n      }\n      h /= 6\n    }\n    return { h: h * 360, s, v, a }\n  }\n\n  toARGB() {\n    return toHex([this.alpha * 255].concat(this.rgb))\n  }\n\n  compare(x) {\n    return x.rgb &&\n    x.rgb[0] === this.rgb[0] &&\n    x.rgb[1] === this.rgb[1] &&\n    x.rgb[2] === this.rgb[2] &&\n    x.alpha === this.alpha\n      ? 0\n      : undefined\n  }\n}\n\nColor.prototype.type = 'Color'\n\nfunction clamp(v, max) {\n  return Math.min(Math.max(v, 0), max)\n}\n\nfunction toHex(v) {\n  return `#${v\n    .map(c => {\n      c = clamp(Math.round(c), 255)\n      return (c < 16 ? '0' : '') + c.toString(16)\n    })\n    .join('')}`\n}\n\nColor.fromKeyword = keyword => {\n  let c\n  const key = keyword.toLowerCase()\n  if (colors.hasOwnProperty(key)) {\n    c = new Color(colors[key].slice(1))\n  } else if (key === 'transparent') {\n    c = new Color([0, 0, 0], 0)\n  }\n\n  if (c) {\n    c.value = keyword\n    return c\n  }\n}\nmodule.exports = Color\n","const Node = require('./node')\n\nclass Paren extends Node {\n  constructor(node) {\n    super()\n    this.value = node\n  }\n\n  genCSS(context, output) {\n    output.add('(')\n    this.value.genCSS(context, output)\n    output.add(')')\n  }\n\n  eval(context) {\n    return new Paren(this.value.eval(context))\n  }\n}\n\nParen.prototype.type = 'Paren'\nmodule.exports = Paren\n","const Node = require('./node')\n\nclass Combinator extends Node {\n  constructor(value) {\n    super()\n    if (value === ' ') {\n      this.value = ' '\n      this.emptyOrWhitespace = true\n    } else {\n      this.value = value ? value.trim() : ''\n      this.emptyOrWhitespace = this.value === ''\n    }\n  }\n\n  genCSS(context, output) {\n    const spaceOrEmpty =\n      context.compress || _noSpaceCombinators[this.value] ? '' : ' '\n    output.add(spaceOrEmpty + this.value + spaceOrEmpty)\n  }\n}\n\nCombinator.prototype.type = 'Combinator'\nconst _noSpaceCombinators = {\n  '': true,\n  ' ': true,\n  '|': true,\n}\nmodule.exports = Combinator\n","const Node = require('./node')\nconst Paren = require('./paren')\nconst Combinator = require('./combinator')\n\nclass Element extends Node {\n  constructor(combinator, value, index, currentFileInfo, info) {\n    super()\n    this.combinator =\n      combinator instanceof Combinator ? combinator : new Combinator(combinator)\n\n    if (typeof value === 'string') {\n      this.value = value.trim()\n    } else if (value) {\n      this.value = value\n    } else {\n      this.value = ''\n    }\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.copyVisibilityInfo(info)\n  }\n\n  accept(visitor) {\n    const value = this.value\n    this.combinator = visitor.visit(this.combinator)\n    if (typeof value === 'object') {\n      this.value = visitor.visit(value)\n    }\n  }\n\n  eval(context) {\n    return new Element(\n      this.combinator,\n      this.value.eval ? this.value.eval(context) : this.value,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  clone() {\n    return new Element(\n      this.combinator,\n      this.value,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  genCSS(context, output) {\n    output.add(this.toCSS(context), this.currentFileInfo, this.index)\n  }\n\n  toCSS(context = {}) {\n    let value = this.value\n    const firstSelector = context.firstSelector\n    if (value instanceof Paren) {\n      // selector in parens should not be affected by outer selector\n      // flags (breaks only interpolated selectors - see #1973)\n      context.firstSelector = true\n    }\n    value = value.toCSS ? value.toCSS(context) : value\n    context.firstSelector = firstSelector\n    if (value === '' && this.combinator.value.charAt(0) === '&') {\n      return ''\n    } else {\n      return this.combinator.toCSS(context) + value\n    }\n  }\n}\n\nElement.prototype.type = 'Element'\nmodule.exports = Element\n","const Node = require('./node')\nconst Element = require('./element')\n\nclass Selector extends Node {\n  constructor(\n    elements,\n    extendList,\n    condition,\n    index,\n    currentFileInfo,\n    visibilityInfo\n  ) {\n    super()\n    this.elements = elements\n    this.extendList = extendList\n    this.condition = condition\n    this.currentFileInfo = currentFileInfo || {}\n    if (!condition) {\n      this.evaldCondition = true\n    }\n    this.copyVisibilityInfo(visibilityInfo)\n  }\n\n  accept(visitor) {\n    if (this.elements) {\n      this.elements = visitor.visitArray(this.elements)\n    }\n    if (this.extendList) {\n      this.extendList = visitor.visitArray(this.extendList)\n    }\n    if (this.condition) {\n      this.condition = visitor.visit(this.condition)\n    }\n  }\n\n  createDerived(elements, extendList, evaldCondition) {\n    const info = this.visibilityInfo()\n    evaldCondition =\n      evaldCondition != null ? evaldCondition : this.evaldCondition\n    const newSelector = new Selector(\n      elements,\n      extendList || this.extendList,\n      null,\n      this.index,\n      this.currentFileInfo,\n      info\n    )\n    newSelector.evaldCondition = evaldCondition\n    newSelector.mediaEmpty = this.mediaEmpty\n    return newSelector\n  }\n\n  createEmptySelectors() {\n    const el = new Element('', '&', this.index, this.currentFileInfo)\n    const sels = [\n      new Selector([el], null, null, this.index, this.currentFileInfo),\n    ]\n    sels[0].mediaEmpty = true\n    return sels\n  }\n\n  match(other) {\n    const elements = this.elements\n    const len = elements.length\n    let olen\n    let i\n\n    other.CacheElements()\n\n    olen = other._elements.length\n    if (olen === 0 || len < olen) {\n      return 0\n    } else {\n      for (i = 0; i < olen; i++) {\n        if (elements[i].value !== other._elements[i]) {\n          return 0\n        }\n      }\n    }\n\n    return olen // return number of matched elements\n  }\n\n  CacheElements() {\n    if (this._elements) {\n      return\n    }\n\n    let elements = this.elements\n      .map(v => v.combinator.value + (v.value.value || v.value))\n      .join('')\n      .match(/[,&#\\*\\.\\w-]([\\w-]|(\\\\.))*/g)\n\n    if (elements) {\n      if (elements[0] === '&') {\n        elements.shift()\n      }\n    } else {\n      elements = []\n    }\n\n    this._elements = elements\n  }\n\n  isJustParentSelector() {\n    return (\n      !this.mediaEmpty &&\n      this.elements.length === 1 &&\n      this.elements[0].value === '&' &&\n      (this.elements[0].combinator.value === ' ' ||\n        this.elements[0].combinator.value === '')\n    )\n  }\n\n  eval(context) {\n    const evaldCondition = this.condition && this.condition.eval(context)\n    let elements = this.elements\n    let extendList = this.extendList\n\n    elements = elements && elements.map(e => e.eval(context))\n    extendList = extendList && extendList.map(extend => extend.eval(context))\n\n    return this.createDerived(elements, extendList, evaldCondition)\n  }\n\n  genCSS(context, output) {\n    let i\n    let element\n    if (\n      (!context || !context.firstSelector) &&\n      this.elements[0].combinator.value === ''\n    ) {\n      output.add(' ', this.currentFileInfo, this.index)\n    }\n    if (!this._css) {\n      //TODO caching? speed comparison?\n      for (i = 0; i < this.elements.length; i++) {\n        element = this.elements[i]\n        element.genCSS(context, output)\n      }\n    }\n  }\n\n  getIsOutput() {\n    return this.evaldCondition\n  }\n}\n\nSelector.prototype.type = 'Selector'\nmodule.exports = Selector\n","const Node = require('./node')\n\nclass Value extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n    if (!value) {\n      throw new Error('Value requires an array argument')\n    }\n  }\n\n  accept(visitor) {\n    if (this.value) {\n      this.value = visitor.visitArray(this.value)\n    }\n  }\n\n  eval(context) {\n    if (this.value.length === 1) {\n      return this.value[0].eval(context)\n    } else {\n      return new Value(this.value.map(v => v.eval(context)))\n    }\n  }\n\n  genCSS(context, output) {\n    let i\n    for (i = 0; i < this.value.length; i++) {\n      this.value[i].genCSS(context, output)\n      if (i + 1 < this.value.length) {\n        output.add(context && context.compress ? ',' : ', ')\n      }\n    }\n  }\n}\n\nValue.prototype.type = 'Value'\nmodule.exports = Value\n","const Node = require('./node')\n\nclass Keyword extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n  }\n\n  genCSS(context, output) {\n    if (this.value === '%') {\n      throw { type: 'Syntax', message: 'Invalid % without number' }\n    }\n    output.add(this.value)\n  }\n}\n\nKeyword.prototype.type = 'Keyword'\n\nKeyword.True = new Keyword('true')\nKeyword.False = new Keyword('false')\n\nmodule.exports = Keyword\n","const Keyword = require('../tree/keyword')\nconst functionRegistry = require('./function-registry')\n\nconst defaultFunc = {\n  eval() {\n    const v = this.value_\n    const e = this.error_\n    if (e) {\n      throw e\n    }\n    if (v != null) {\n      return v ? Keyword.True : Keyword.False\n    }\n  },\n  value(v) {\n    this.value_ = v\n  },\n  error(e) {\n    this.error_ = e\n  },\n  reset() {\n    this.value_ = this.error_ = null\n  },\n}\n\nfunctionRegistry.add('default', defaultFunc.eval.bind(defaultFunc))\n\nmodule.exports = defaultFunc\n","const debugInfo = (context, ctx, lineSeparator) => {\n  let result = ''\n  if (context.dumpLineNumbers && !context.compress) {\n    switch (context.dumpLineNumbers) {\n      case 'comments':\n        result = debugInfo.asComment(ctx)\n        break\n      case 'mediaquery':\n        result = debugInfo.asMediaQuery(ctx)\n        break\n      case 'all':\n        result =\n          debugInfo.asComment(ctx) +\n          (lineSeparator || '') +\n          debugInfo.asMediaQuery(ctx)\n        break\n    }\n  }\n  return result\n}\n\ndebugInfo.asComment = ctx =>\n  `/* line ${ctx.debugInfo.lineNumber}, ${ctx.debugInfo.fileName} */\\n`\n\ndebugInfo.asMediaQuery = ctx => {\n  let filenameWithProtocol = ctx.debugInfo.fileName\n  if (!/^[a-z]+:\\/\\//i.test(filenameWithProtocol)) {\n    filenameWithProtocol = `file://${filenameWithProtocol}`\n  }\n  return `@media -sass-debug-info{filename{font-family:${filenameWithProtocol.replace(\n    /([.:\\/\\\\])/g,\n    a => {\n      if (a == '\\\\') {\n        a = '/'\n      }\n      return '\\\\' + a\n    }\n  )}}line{font-family:\\\\00003${ctx.debugInfo.lineNumber}}}\\n`\n}\n\nmodule.exports = debugInfo\n","const Node = require('./node')\nconst Rule = require('./rule')\nconst Selector = require('./selector')\nconst Element = require('./element')\nconst Paren = require('./paren')\nconst contexts = require('../contexts')\nconst globalFunctionRegistry = require('../functions/function-registry')\nconst defaultFunc = require('../functions/default')\nconst getDebugInfo = require('./debug-info')\n\nclass Ruleset extends Node {\n  constructor(selectors, rules, strictImports, visibilityInfo) {\n    super()\n    this.selectors = selectors\n    this.rules = rules\n    this._lookups = {}\n    this.strictImports = strictImports\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.paths) {\n      this.paths = visitor.visitArray(this.paths, true)\n    } else if (this.selectors) {\n      this.selectors = visitor.visitArray(this.selectors)\n    }\n    if (this.rules && this.rules.length) {\n      this.rules = visitor.visitArray(this.rules)\n    }\n  }\n\n  eval(context) {\n    const thisSelectors = this.selectors\n    let selectors\n    let selCnt\n    let selector\n    let i\n    let hasOnePassingSelector = false\n\n    if (thisSelectors && (selCnt = thisSelectors.length)) {\n      selectors = []\n      defaultFunc.error({\n        type: 'Syntax',\n        message: 'it is currently only allowed in parametric mixin guards,',\n      })\n      for (i = 0; i < selCnt; i++) {\n        selector = thisSelectors[i].eval(context)\n        selectors.push(selector)\n        if (selector.evaldCondition) {\n          hasOnePassingSelector = true\n        }\n      }\n      defaultFunc.reset()\n    } else {\n      hasOnePassingSelector = true\n    }\n\n    let rules = this.rules ? this.rules.slice(0) : null\n    const ruleset = new Ruleset(\n      selectors,\n      rules,\n      this.strictImports,\n      this.visibilityInfo()\n    )\n    let rule\n    let subRule\n\n    ruleset.originalRuleset = this\n    ruleset.root = this.root\n    ruleset.firstRoot = this.firstRoot\n    ruleset.allowImports = this.allowImports\n\n    if (this.debugInfo) {\n      ruleset.debugInfo = this.debugInfo\n    }\n\n    if (!hasOnePassingSelector) {\n      rules.length = 0\n    }\n\n    // inherit a function registry from the frames stack when possible;\n    // otherwise from the global registry\n    ruleset.functionRegistry = (frames => {\n      let i = 0\n      const n = frames.length\n      let found\n      for (; i !== n; ++i) {\n        found = frames[i].functionRegistry\n        if (found) {\n          return found\n        }\n      }\n      return globalFunctionRegistry\n    })(context.frames).inherit()\n\n    // push the current ruleset to the frames stack\n    const ctxFrames = context.frames\n    ctxFrames.unshift(ruleset)\n\n    // currrent selectors\n    let ctxSelectors = context.selectors\n    if (!ctxSelectors) {\n      context.selectors = ctxSelectors = []\n    }\n    ctxSelectors.unshift(this.selectors)\n\n    // Evaluate imports\n    if (ruleset.root || ruleset.allowImports || !ruleset.strictImports) {\n      ruleset.evalImports(context)\n    }\n\n    // Store the frames around mixin definitions,\n    // so they can be evaluated like closures when the time comes.\n    const rsRules = ruleset.rules\n\n    let rsRuleCnt = rsRules ? rsRules.length : 0\n    for (i = 0; i < rsRuleCnt; i++) {\n      if (rsRules[i].evalFirst) {\n        rsRules[i] = rsRules[i].eval(context)\n      }\n    }\n\n    const mediaBlockCount =\n      (context.mediaBlocks && context.mediaBlocks.length) || 0\n\n    // Evaluate mixin calls.\n    for (i = 0; i < rsRuleCnt; i++) {\n      if (rsRules[i].type === 'MixinCall') {\n        /*jshint loopfunc:true */\n        rules = rsRules[i].eval(context).filter(r => {\n          if (r instanceof Rule && r.variable) {\n            // do not pollute the scope if the variable is\n            // already there. consider returning false here\n            // but we need a way to \"return\" variable from mixins\n            return !ruleset.variable(r.name)\n          }\n          return true\n        })\n        rsRules.splice(...[i, 1].concat(rules))\n        rsRuleCnt += rules.length - 1\n        i += rules.length - 1\n        ruleset.resetCache()\n      } else if (rsRules[i].type === 'RulesetCall') {\n        /*jshint loopfunc:true */\n        rules = rsRules[i].eval(context).rules.filter(r => {\n          if (r instanceof Rule && r.variable) {\n            // do not pollute the scope at all\n            return false\n          }\n          return true\n        })\n        rsRules.splice(...[i, 1].concat(rules))\n        rsRuleCnt += rules.length - 1\n        i += rules.length - 1\n        ruleset.resetCache()\n      }\n    }\n\n    // Evaluate everything else\n    for (i = 0; i < rsRules.length; i++) {\n      rule = rsRules[i]\n      if (!rule.evalFirst) {\n        rsRules[i] = rule = rule.eval ? rule.eval(context) : rule\n      }\n    }\n\n    // Evaluate everything else\n    for (i = 0; i < rsRules.length; i++) {\n      rule = rsRules[i]\n      // for rulesets, check if it is a css guard and can be removed\n      if (\n        rule instanceof Ruleset &&\n        rule.selectors &&\n        rule.selectors.length === 1\n      ) {\n        // check if it can be folded in (e.g. & where)\n        if (rule.selectors[0].isJustParentSelector()) {\n          rsRules.splice(i--, 1)\n\n          for (let j = 0; j < rule.rules.length; j++) {\n            subRule = rule.rules[j]\n            subRule.copyVisibilityInfo(rule.visibilityInfo())\n            if (!(subRule instanceof Rule) || !subRule.variable) {\n              rsRules.splice(++i, 0, subRule)\n            }\n          }\n        }\n      }\n    }\n\n    // Pop the stack\n    ctxFrames.shift()\n    ctxSelectors.shift()\n\n    if (context.mediaBlocks) {\n      for (i = mediaBlockCount; i < context.mediaBlocks.length; i++) {\n        context.mediaBlocks[i].bubbleSelectors(selectors)\n      }\n    }\n\n    return ruleset\n  }\n\n  evalImports(context) {\n    const rules = this.rules\n    let i\n    let importRules\n    if (!rules) {\n      return\n    }\n\n    for (i = 0; i < rules.length; i++) {\n      if (rules[i].type === 'Import') {\n        importRules = rules[i].eval(context)\n        if (importRules && (importRules.length || importRules.length === 0)) {\n          rules.splice(...[i, 1].concat(importRules))\n          i += importRules.length - 1\n        } else {\n          rules.splice(i, 1, importRules)\n        }\n        this.resetCache()\n      }\n    }\n  }\n\n  makeImportant() {\n    const result = new Ruleset(\n      this.selectors,\n      this.rules.map(r => {\n        if (r.makeImportant) {\n          return r.makeImportant()\n        } else {\n          return r\n        }\n      }),\n      this.strictImports,\n      this.visibilityInfo()\n    )\n\n    return result\n  }\n\n  matchArgs(args) {\n    return !args || args.length === 0\n  }\n\n  // lets you call a css selector with a guard\n  matchCondition(args, context) {\n    const lastSelector = this.selectors[this.selectors.length - 1]\n    if (!lastSelector.evaldCondition) {\n      return false\n    }\n    if (\n      lastSelector.condition &&\n      !lastSelector.condition.eval(new contexts.Eval(context, context.frames))\n    ) {\n      return false\n    }\n    return true\n  }\n\n  resetCache() {\n    this._rulesets = null\n    this._variables = null\n    this._lookups = {}\n  }\n\n  variables() {\n    if (!this._variables) {\n      this._variables = !this.rules\n        ? {}\n        : this.rules.reduce((hash, r) => {\n            if (r instanceof Rule && r.variable === true) {\n              hash[r.name] = r\n            }\n            // when evaluating variables in an import statement, imports have not been eval'd\n            // so we need to go inside import statements.\n            // guard against root being a string (in the case of inlined less)\n            if (r.type === 'Import' && r.root && r.root.variables) {\n              const vars = r.root.variables()\n              for (const name in vars) {\n                if (vars.hasOwnProperty(name)) {\n                  hash[name] = vars[name]\n                }\n              }\n            }\n            return hash\n          }, {})\n    }\n    return this._variables\n  }\n\n  variable(name) {\n    return this.variables()[name]\n  }\n\n  rulesets() {\n    if (!this.rules) {\n      return []\n    }\n\n    const filtRules = []\n    const rules = this.rules\n    const cnt = rules.length\n    let i\n    let rule\n\n    for (i = 0; i < cnt; i++) {\n      rule = rules[i]\n      if (rule.isRuleset) {\n        filtRules.push(rule)\n      }\n    }\n\n    return filtRules\n  }\n\n  prependRule(rule) {\n    const rules = this.rules\n    if (rules) {\n      rules.unshift(rule)\n    } else {\n      this.rules = [rule]\n    }\n  }\n\n  find(selector, self = this, filter) {\n    const rules = []\n    let match\n    let foundMixins\n    const key = selector.toCSS()\n\n    if (key in this._lookups) {\n      return this._lookups[key]\n    }\n\n    this.rulesets().forEach(rule => {\n      if (rule !== self) {\n        for (let j = 0; j < rule.selectors.length; j++) {\n          match = selector.match(rule.selectors[j])\n          if (match) {\n            if (selector.elements.length > match) {\n              if (!filter || filter(rule)) {\n                foundMixins = rule.find(\n                  new Selector(selector.elements.slice(match)),\n                  self,\n                  filter\n                )\n                for (let i = 0; i < foundMixins.length; ++i) {\n                  foundMixins[i].path.push(rule)\n                }\n                Array.prototype.push.apply(rules, foundMixins)\n              }\n            } else {\n              rules.push({ rule, path: [] })\n            }\n            break\n          }\n        }\n      }\n    })\n    this._lookups[key] = rules\n    return rules\n  }\n\n  genCSS(context, output) {\n    let i\n    let j\n    const charsetRuleNodes = []\n    let ruleNodes = []\n\n    let // Line number debugging\n    debugInfo\n\n    let rule\n    let path\n\n    context.tabLevel = context.tabLevel || 0\n\n    if (!this.root) {\n      context.tabLevel++\n    }\n\n    const tabRuleStr = context.compress\n      ? ''\n      : Array(context.tabLevel + 1).join('  ')\n    const tabSetStr = context.compress ? '' : Array(context.tabLevel).join('  ')\n    let sep\n\n    function isRulesetLikeNode(rule) {\n      // if it has nested rules, then it should be treated like a ruleset\n      // medias and comments do not have nested rules, but should be treated like rulesets anyway\n      // some directives and anonymous nodes are ruleset like, others are not\n      if (typeof rule.isRulesetLike === 'boolean') {\n        return rule.isRulesetLike\n      } else if (typeof rule.isRulesetLike === 'function') {\n        return rule.isRulesetLike()\n      }\n\n      //anything else is assumed to be a rule\n      return false\n    }\n\n    let charsetNodeIndex = 0\n    let importNodeIndex = 0\n    for (i = 0; i < this.rules.length; i++) {\n      rule = this.rules[i]\n      if (rule.type === 'Comment') {\n        if (importNodeIndex === i) {\n          importNodeIndex++\n        }\n        ruleNodes.push(rule)\n      } else if (rule.isCharset && rule.isCharset()) {\n        ruleNodes.splice(charsetNodeIndex, 0, rule)\n        charsetNodeIndex++\n        importNodeIndex++\n      } else if (rule.type === 'Import') {\n        ruleNodes.splice(importNodeIndex, 0, rule)\n        importNodeIndex++\n      } else {\n        ruleNodes.push(rule)\n      }\n    }\n    ruleNodes = charsetRuleNodes.concat(ruleNodes)\n\n    // If this is the root node, we don't render\n    // a selector, or {}.\n    if (!this.root) {\n      debugInfo = getDebugInfo(context, this, tabSetStr)\n\n      if (debugInfo) {\n        output.add(debugInfo)\n        output.add(tabSetStr)\n      }\n\n      const paths = this.paths\n      const pathCnt = paths.length\n      let pathSubCnt\n\n      sep = context.compress ? ',' : `,\\n${tabSetStr}`\n\n      for (i = 0; i < pathCnt; i++) {\n        path = paths[i]\n        if (!(pathSubCnt = path.length)) {\n          continue\n        }\n        if (i > 0) {\n          output.add(sep)\n        }\n\n        context.firstSelector = true\n        path[0].genCSS(context, output)\n\n        context.firstSelector = false\n        for (j = 1; j < pathSubCnt; j++) {\n          path[j].genCSS(context, output)\n        }\n      }\n\n      output.add((context.compress ? '{' : ' {\\n') + tabRuleStr)\n    }\n\n    // Compile rules and rulesets\n    for (i = 0; i < ruleNodes.length; i++) {\n      rule = ruleNodes[i]\n\n      if (i + 1 === ruleNodes.length) {\n        context.lastRule = true\n      }\n\n      const currentLastRule = context.lastRule\n      if (isRulesetLikeNode(rule)) {\n        context.lastRule = false\n      }\n\n      if (rule.genCSS) {\n        rule.genCSS(context, output)\n      } else if (rule.value) {\n        output.add(rule.value.toString())\n      }\n\n      context.lastRule = currentLastRule\n\n      if (!context.lastRule) {\n        output.add(context.compress ? '' : `\\n${tabRuleStr}`)\n      } else {\n        context.lastRule = false\n      }\n    }\n\n    if (!this.root) {\n      output.add(context.compress ? '}' : `\\n${tabSetStr}}`)\n      context.tabLevel--\n    }\n\n    if (!output.isEmpty() && !context.compress && this.firstRoot) {\n      output.add('\\n')\n    }\n  }\n\n  joinSelectors(paths, context, selectors) {\n    for (let s = 0; s < selectors.length; s++) {\n      this.joinSelector(paths, context, selectors[s])\n    }\n  }\n\n  joinSelector(paths, context, selector) {\n    function createParenthesis(elementsToPak, originalElement) {\n      let replacementParen\n      let j\n      if (elementsToPak.length === 0) {\n        replacementParen = new Paren(elementsToPak[0])\n      } else {\n        const insideParent = []\n        for (j = 0; j < elementsToPak.length; j++) {\n          insideParent.push(\n            new Element(\n              null,\n              elementsToPak[j],\n              originalElement.index,\n              originalElement.currentFileInfo\n            )\n          )\n        }\n        replacementParen = new Paren(new Selector(insideParent))\n      }\n      return replacementParen\n    }\n\n    function createSelector(containedElement, originalElement) {\n      let element\n      let selector\n      element = new Element(\n        null,\n        containedElement,\n        originalElement.index,\n        originalElement.currentFileInfo\n      )\n      selector = new Selector([element])\n      return selector\n    }\n\n    // joins selector path from `beginningPath` with selector path in `addPath`\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns concatenated path\n    function addReplacementIntoPath(\n      beginningPath,\n      addPath,\n      replacedElement,\n      originalSelector\n    ) {\n      let newSelectorPath\n      let lastSelector\n      let newJoinedSelector\n      // our new selector path\n      newSelectorPath = []\n\n      //construct the joined selector - if & is the first thing this will be empty,\n      // if not newJoinedSelector will be the last set of elements in the selector\n      if (beginningPath.length > 0) {\n        newSelectorPath = beginningPath.slice(0)\n        lastSelector = newSelectorPath.pop()\n        newJoinedSelector = originalSelector.createDerived(\n          lastSelector.elements.slice(0)\n        )\n      } else {\n        newJoinedSelector = originalSelector.createDerived([])\n      }\n\n      if (addPath.length > 0) {\n        // /deep/ is a combinator that is valid without anything in front of it\n        // so if the & does not have a combinator that is \"\" or \" \" then\n        // and there is a combinator on the parent, then grab that.\n        // this also allows + a { & .b { .a & { ... though not sure why you would want to do that\n        let combinator = replacedElement.combinator\n\n        const parentEl = addPath[0].elements[0]\n        if (\n          combinator.emptyOrWhitespace &&\n          !parentEl.combinator.emptyOrWhitespace\n        ) {\n          combinator = parentEl.combinator\n        }\n        // join the elements so far with the first part of the parent\n        newJoinedSelector.elements.push(\n          new Element(\n            combinator,\n            parentEl.value,\n            replacedElement.index,\n            replacedElement.currentFileInfo\n          )\n        )\n        newJoinedSelector.elements = newJoinedSelector.elements.concat(\n          addPath[0].elements.slice(1)\n        )\n      }\n\n      // now add the joined selector - but only if it is not empty\n      if (newJoinedSelector.elements.length !== 0) {\n        newSelectorPath.push(newJoinedSelector)\n      }\n\n      //put together the parent selectors after the join (e.g. the rest of the parent)\n      if (addPath.length > 1) {\n        let restOfPath = addPath.slice(1)\n        restOfPath = restOfPath.map(selector =>\n          selector.createDerived(selector.elements, [])\n        )\n        newSelectorPath = newSelectorPath.concat(restOfPath)\n      }\n      return newSelectorPath\n    }\n\n    // joins selector path from `beginningPath` with every selector path in `addPaths` array\n    // `replacedElement` contains element that is being replaced by `addPath`\n    // returns array with all concatenated paths\n    function addAllReplacementsIntoPath(\n      beginningPath,\n      addPaths,\n      replacedElement,\n      originalSelector,\n      result\n    ) {\n      let j\n      for (j = 0; j < beginningPath.length; j++) {\n        const newSelectorPath = addReplacementIntoPath(\n          beginningPath[j],\n          addPaths,\n          replacedElement,\n          originalSelector\n        )\n        result.push(newSelectorPath)\n      }\n      return result\n    }\n\n    function mergeElementsOnToSelectors(elements, selectors) {\n      let i\n      let sel\n\n      if (elements.length === 0) {\n        return\n      }\n      if (selectors.length === 0) {\n        selectors.push([new Selector(elements)])\n        return\n      }\n\n      for (i = 0; i < selectors.length; i++) {\n        sel = selectors[i]\n\n        // if the previous thing in sel is a parent this needs to join on to it\n        if (sel.length > 0) {\n          sel[sel.length - 1] = sel[sel.length - 1].createDerived(\n            sel[sel.length - 1].elements.concat(elements)\n          )\n        } else {\n          sel.push(new Selector(elements))\n        }\n      }\n    }\n\n    // replace all parent selectors inside `inSelector` by content of `context` array\n    // resulting selectors are returned inside `paths` array\n    // returns true if `inSelector` contained at least one parent selector\n    function replaceParentSelector(paths, context, inSelector) {\n      // The paths are [[Selector]]\n      // The first list is a list of comma separated selectors\n      // The inner list is a list of inheritance separated selectors\n      // e.g.\n      // .a, .b {\n      //   .c {\n      //   }\n      // }\n      // == [[.a] [.c]] [[.b] [.c]]\n      //\n      let i\n\n      let j\n      let k\n      let currentElements\n      let newSelectors\n      let selectorsMultiplied\n      let sel\n      let el\n      let hadParentSelector = false\n      let length\n      let lastSelector\n      function findNestedSelector(element) {\n        let maybeSelector\n        if (element.value.type !== 'Paren') {\n          return null\n        }\n\n        maybeSelector = element.value.value\n        if (maybeSelector.type !== 'Selector') {\n          return null\n        }\n\n        return maybeSelector\n      }\n\n      // the elements from the current selector so far\n      currentElements = []\n      // the current list of new selectors to add to the path.\n      // We will build it up. We initiate it with one empty selector as we \"multiply\" the new selectors\n      // by the parents\n      newSelectors = [[]]\n\n      for (i = 0; i < inSelector.elements.length; i++) {\n        el = inSelector.elements[i]\n        // non parent reference elements just get added\n        if (el.value !== '&') {\n          const nestedSelector = findNestedSelector(el)\n          if (nestedSelector != null) {\n            // merge the current list of non parent selector elements\n            // on to the current list of selectors to add\n            mergeElementsOnToSelectors(currentElements, newSelectors)\n\n            const nestedPaths = []\n            let replaced\n            const replacedNewSelectors = []\n            replaced = replaceParentSelector(\n              nestedPaths,\n              context,\n              nestedSelector\n            )\n            hadParentSelector = hadParentSelector || replaced\n            //the nestedPaths array should have only one member - replaceParentSelector does not multiply selectors\n            for (k = 0; k < nestedPaths.length; k++) {\n              const replacementSelector = createSelector(\n                createParenthesis(nestedPaths[k], el),\n                el\n              )\n              addAllReplacementsIntoPath(\n                newSelectors,\n                [replacementSelector],\n                el,\n                inSelector,\n                replacedNewSelectors\n              )\n            }\n            newSelectors = replacedNewSelectors\n            currentElements = []\n          } else {\n            currentElements.push(el)\n          }\n        } else {\n          hadParentSelector = true\n          // the new list of selectors to add\n          selectorsMultiplied = []\n\n          // merge the current list of non parent selector elements\n          // on to the current list of selectors to add\n          mergeElementsOnToSelectors(currentElements, newSelectors)\n\n          // loop through our current selectors\n          for (j = 0; j < newSelectors.length; j++) {\n            sel = newSelectors[j]\n            // if we don't have any parent paths, the & might be in a mixin so that it can be used\n            // whether there are parents or not\n            if (context.length === 0) {\n              // the combinator used on el should now be applied to the next element instead so that\n              // it is not lost\n              if (sel.length > 0) {\n                sel[0].elements.push(\n                  new Element(el.combinator, '', el.index, el.currentFileInfo)\n                )\n              }\n              selectorsMultiplied.push(sel)\n            } else {\n              // and the parent selectors\n              for (k = 0; k < context.length; k++) {\n                // We need to put the current selectors\n                // then join the last selector's elements on to the parents selectors\n                const newSelectorPath = addReplacementIntoPath(\n                  sel,\n                  context[k],\n                  el,\n                  inSelector\n                )\n                // add that to our new set of selectors\n                selectorsMultiplied.push(newSelectorPath)\n              }\n            }\n          }\n\n          // our new selectors has been multiplied, so reset the state\n          newSelectors = selectorsMultiplied\n          currentElements = []\n        }\n      }\n\n      // if we have any elements left over (e.g. .a& .b == .b)\n      // add them on to all the current selectors\n      mergeElementsOnToSelectors(currentElements, newSelectors)\n\n      for (i = 0; i < newSelectors.length; i++) {\n        length = newSelectors[i].length\n        if (length > 0) {\n          paths.push(newSelectors[i])\n          lastSelector = newSelectors[i][length - 1]\n          newSelectors[i][length - 1] = lastSelector.createDerived(\n            lastSelector.elements,\n            inSelector.extendList\n          )\n          //newSelectors[i][length - 1].copyVisibilityInfo(inSelector.visibilityInfo());\n        }\n      }\n\n      return hadParentSelector\n    }\n\n    function deriveSelector(visibilityInfo, deriveFrom) {\n      const newSelector = deriveFrom.createDerived(\n        deriveFrom.elements,\n        deriveFrom.extendList,\n        deriveFrom.evaldCondition\n      )\n      newSelector.copyVisibilityInfo(visibilityInfo)\n      return newSelector\n    }\n\n    // joinSelector code follows\n    let i\n\n    let newPaths\n    let hadParentSelector\n\n    newPaths = []\n    hadParentSelector = replaceParentSelector(newPaths, context, selector)\n\n    if (!hadParentSelector) {\n      if (context.length > 0) {\n        newPaths = []\n        for (i = 0; i < context.length; i++) {\n          //var concatenated = [];\n          //context[i].forEach(function(entry) {\n          //    var newEntry = entry.createDerived(entry.elements, entry.extendList, entry.evaldCondition);\n          //    newEntry.copyVisibilityInfo(selector.visibilityInfo());\n          //    concatenated.push(newEntry);\n          //}, this);\n          const concatenated = context[i].map(\n            deriveSelector.bind(this, selector.visibilityInfo())\n          )\n\n          concatenated.push(selector)\n          newPaths.push(concatenated)\n        }\n      } else {\n        newPaths = [[selector]]\n      }\n    }\n\n    for (i = 0; i < newPaths.length; i++) {\n      paths.push(newPaths[i])\n    }\n  }\n}\n\nRuleset.prototype.type = 'Ruleset'\nRuleset.prototype.isRuleset = true\nRuleset.prototype.isRulesetLike = true\nmodule.exports = Ruleset\n","const Node = require('./node')\nconst Selector = require('./selector')\nconst Ruleset = require('./ruleset')\n\nclass Directive extends Node {\n  constructor(\n    name,\n    value,\n    rules,\n    index,\n    currentFileInfo,\n    debugInfo,\n    isRooted,\n    visibilityInfo\n  ) {\n    super()\n    let i\n\n    this.name = name\n    this.value = value\n    if (rules) {\n      if (Array.isArray(rules)) {\n        this.rules = rules\n      } else {\n        this.rules = [rules]\n        this.rules[0].selectors = new Selector(\n          [],\n          null,\n          null,\n          this.index,\n          currentFileInfo\n        ).createEmptySelectors()\n      }\n      for (i = 0; i < this.rules.length; i++) {\n        this.rules[i].allowImports = true\n      }\n    }\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.debugInfo = debugInfo\n    this.isRooted = isRooted || false\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    const value = this.value\n    const rules = this.rules\n    if (rules) {\n      this.rules = visitor.visitArray(rules)\n    }\n    if (value) {\n      this.value = visitor.visit(value)\n    }\n  }\n\n  isRulesetLike() {\n    return this.rules || !this.isCharset()\n  }\n\n  isCharset() {\n    return '@charset' === this.name\n  }\n\n  genCSS(context, output) {\n    const value = this.value\n    const rules = this.rules\n    output.add(this.name, this.currentFileInfo, this.index)\n    if (value) {\n      output.add(' ')\n      value.genCSS(context, output)\n    }\n    if (rules) {\n      this.outputRuleset(context, output, rules)\n    } else {\n      output.add(';')\n    }\n  }\n\n  eval(context) {\n    let mediaPathBackup\n    let mediaBlocksBackup\n    let value = this.value\n    let rules = this.rules\n\n    //media stored inside other directive should not bubble over it\n    //backpup media bubbling information\n    mediaPathBackup = context.mediaPath\n    mediaBlocksBackup = context.mediaBlocks\n    //deleted media bubbling information\n    context.mediaPath = []\n    context.mediaBlocks = []\n\n    if (value) {\n      value = value.eval(context)\n    }\n    if (rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      rules = [rules[0].eval(context)]\n      rules[0].root = true\n    }\n    //restore media bubbling information\n    context.mediaPath = mediaPathBackup\n    context.mediaBlocks = mediaBlocksBackup\n\n    return new Directive(\n      this.name,\n      value,\n      rules,\n      this.index,\n      this.currentFileInfo,\n      this.debugInfo,\n      this.isRooted,\n      this.visibilityInfo()\n    )\n  }\n\n  variable(name) {\n    if (this.rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      return Ruleset.prototype.variable.call(this.rules[0], name)\n    }\n  }\n\n  find(...args) {\n    if (this.rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      return Ruleset.prototype.find.apply(this.rules[0], args)\n    }\n  }\n\n  rulesets() {\n    if (this.rules) {\n      // assuming that there is only one rule at this point - that is how parser constructs the rule\n      return Ruleset.prototype.rulesets.apply(this.rules[0])\n    }\n  }\n\n  outputRuleset(context, output, rules) {\n    const ruleCnt = rules.length\n    let i\n    context.tabLevel = (context.tabLevel | 0) + 1\n\n    // Compressed\n    if (context.compress) {\n      output.add('{')\n      for (i = 0; i < ruleCnt; i++) {\n        rules[i].genCSS(context, output)\n      }\n      output.add('}')\n      context.tabLevel--\n      return\n    }\n\n    // Non-compressed\n    const tabSetStr = `\\n${Array(context.tabLevel).join('  ')}`\n\n    const tabRuleStr = `${tabSetStr}  `\n    if (!ruleCnt) {\n      output.add(` {${tabSetStr}}`)\n    } else {\n      output.add(` {${tabRuleStr}`)\n      rules[0].genCSS(context, output)\n      for (i = 1; i < ruleCnt; i++) {\n        output.add(tabRuleStr)\n        rules[i].genCSS(context, output)\n      }\n      output.add(`${tabSetStr}}`)\n    }\n\n    context.tabLevel--\n  }\n}\n\nDirective.prototype.type = 'Directive'\nmodule.exports = Directive\n","const Node = require('./node')\nconst contexts = require('../contexts')\n\nclass DetachedRuleset extends Node {\n  constructor(ruleset, frames) {\n    super()\n    this.ruleset = ruleset\n    this.frames = frames\n  }\n\n  accept(visitor) {\n    this.ruleset = visitor.visit(this.ruleset)\n  }\n\n  eval(context) {\n    const frames = this.frames || context.frames.slice(0)\n    return new DetachedRuleset(this.ruleset, frames)\n  }\n\n  callEval(context) {\n    return this.ruleset.eval(\n      this.frames\n        ? new contexts.Eval(context, this.frames.concat(context.frames))\n        : context\n    )\n  }\n}\n\nDetachedRuleset.prototype.type = 'DetachedRuleset'\nDetachedRuleset.prototype.evalFirst = true\nmodule.exports = DetachedRuleset\n","module.exports = {\n  length: {\n    m: 1,\n    cm: 0.01,\n    mm: 0.001,\n    in: 0.0254,\n    px: 0.0254 / 96,\n    pt: 0.0254 / 72,\n    pc: 0.0254 / 72 * 12,\n  },\n  duration: {\n    s: 1,\n    ms: 0.001,\n  },\n  angle: {\n    rad: 1 / (2 * Math.PI),\n    deg: 1 / 360,\n    grad: 1 / 400,\n    turn: 1,\n  },\n}\n","const Node = require('./node')\nconst unitConversions = require('../data/unit-conversions')\n\nclass Unit extends Node {\n  constructor(numerator, denominator, backupUnit) {\n    super()\n    this.numerator = numerator ? numerator.slice(0).sort() : []\n    this.denominator = denominator ? denominator.slice(0).sort() : []\n    if (backupUnit) {\n      this.backupUnit = backupUnit\n    } else if (numerator && numerator.length) {\n      this.backupUnit = numerator[0]\n    }\n  }\n\n  clone() {\n    return new Unit(\n      this.numerator.slice(0),\n      this.denominator.slice(0),\n      this.backupUnit\n    )\n  }\n\n  genCSS(context, output) {\n    // Dimension checks the unit is singular and throws an error if in strict math mode.\n    const strictUnits = context && context.strictUnits\n    if (this.numerator.length === 1) {\n      output.add(this.numerator[0]) // the ideal situation\n    } else if (!strictUnits && this.backupUnit) {\n      output.add(this.backupUnit)\n    } else if (!strictUnits && this.denominator.length) {\n      output.add(this.denominator[0])\n    }\n  }\n\n  toString() {\n    let i\n    let returnStr = this.numerator.join('*')\n    for (i = 0; i < this.denominator.length; i++) {\n      returnStr += `/${this.denominator[i]}`\n    }\n    return returnStr\n  }\n\n  compare(other) {\n    return this.is(other.toString()) ? 0 : undefined\n  }\n\n  is(unitString) {\n    return this.toString().toUpperCase() === unitString.toUpperCase()\n  }\n\n  isLength() {\n    return Boolean(this.toCSS().match(/px|em|%|in|cm|mm|pc|pt|ex/))\n  }\n\n  isEmpty() {\n    return this.numerator.length === 0 && this.denominator.length === 0\n  }\n\n  isSingular() {\n    return this.numerator.length <= 1 && this.denominator.length === 0\n  }\n\n  map(callback) {\n    let i\n\n    for (i = 0; i < this.numerator.length; i++) {\n      this.numerator[i] = callback(this.numerator[i], false)\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n      this.denominator[i] = callback(this.denominator[i], true)\n    }\n  }\n\n  usedUnits() {\n    let group\n    const result = {}\n    let mapUnit\n    let groupName\n\n    mapUnit = atomicUnit => {\n      /*jshint loopfunc:true */\n      if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {\n        result[groupName] = atomicUnit\n      }\n\n      return atomicUnit\n    }\n\n    for (groupName in unitConversions) {\n      if (unitConversions.hasOwnProperty(groupName)) {\n        group = unitConversions[groupName]\n\n        this.map(mapUnit)\n      }\n    }\n\n    return result\n  }\n\n  cancel() {\n    const counter = {}\n    let atomicUnit\n    let i\n\n    for (i = 0; i < this.numerator.length; i++) {\n      atomicUnit = this.numerator[i]\n      counter[atomicUnit] = (counter[atomicUnit] || 0) + 1\n    }\n\n    for (i = 0; i < this.denominator.length; i++) {\n      atomicUnit = this.denominator[i]\n      counter[atomicUnit] = (counter[atomicUnit] || 0) - 1\n    }\n\n    this.numerator = []\n    this.denominator = []\n\n    for (atomicUnit in counter) {\n      if (counter.hasOwnProperty(atomicUnit)) {\n        const count = counter[atomicUnit]\n\n        if (count > 0) {\n          for (i = 0; i < count; i++) {\n            this.numerator.push(atomicUnit)\n          }\n        } else if (count < 0) {\n          for (i = 0; i < -count; i++) {\n            this.denominator.push(atomicUnit)\n          }\n        }\n      }\n    }\n\n    this.numerator.sort()\n    this.denominator.sort()\n  }\n}\n\nUnit.prototype.type = 'Unit'\nmodule.exports = Unit\n","const Node = require('./node')\nconst unitConversions = require('../data/unit-conversions')\nconst Unit = require('./unit')\nconst Color = require('./color')\n\n//\n// A number with a unit\n//\nclass Dimension extends Node {\n  constructor(value, unit) {\n    super()\n    this.value = parseFloat(value)\n    this.unit =\n      unit && unit instanceof Unit ? unit : new Unit(unit ? [unit] : undefined)\n  }\n\n  accept(visitor) {\n    this.unit = visitor.visit(this.unit)\n  }\n\n  eval(context) {\n    return this\n  }\n\n  toColor() {\n    return new Color([this.value, this.value, this.value])\n  }\n\n  genCSS(context, output) {\n    if (context && context.strictUnits && !this.unit.isSingular()) {\n      throw new Error(\n        `Multiple units in dimension. Correct the units or use the unit function. Bad unit: ${this.unit.toString()}`\n      )\n    }\n\n    const value = this.fround(context, this.value)\n    let strValue = String(value)\n\n    if (value !== 0 && value < 0.000001 && value > -0.000001) {\n      // would be output 1e-6 etc.\n      strValue = value.toFixed(20).replace(/0+$/, '')\n    }\n\n    if (context && context.compress) {\n      // Zero values doesn't need a unit\n      if (value === 0 && this.unit.isLength()) {\n        output.add(strValue)\n        return\n      }\n\n      // Float values doesn't need a leading zero\n      if (value > 0 && value < 1) {\n        strValue = strValue.substr(1)\n      }\n    }\n\n    output.add(strValue)\n    this.unit.genCSS(context, output)\n  }\n\n  // In an operation between two Dimensions,\n  // we default to the first Dimension's unit,\n  // so `1px + 2` will yield `3px`.\n  operate(context, op, other) {\n    /*jshint noempty:false */\n    let value = this._operate(context, op, this.value, other.value)\n\n    let unit = this.unit.clone()\n\n    if (op === '+' || op === '-') {\n      if (unit.numerator.length === 0 && unit.denominator.length === 0) {\n        unit = other.unit.clone()\n        if (this.unit.backupUnit) {\n          unit.backupUnit = this.unit.backupUnit\n        }\n      } else if (\n        other.unit.numerator.length === 0 &&\n        unit.denominator.length === 0\n      ) {\n        // do nothing\n      } else {\n        other = other.convertTo(this.unit.usedUnits())\n\n        if (context.strictUnits && other.unit.toString() !== unit.toString()) {\n          throw new Error(\n            `Incompatible units. Change the units or use the unit function. Bad units: '${unit.toString()}' and '${other.unit.toString()}'.`\n          )\n        }\n\n        value = this._operate(context, op, this.value, other.value)\n      }\n    } else if (op === '*') {\n      unit.numerator = unit.numerator.concat(other.unit.numerator).sort()\n      unit.denominator = unit.denominator.concat(other.unit.denominator).sort()\n      unit.cancel()\n    } else if (op === '/') {\n      unit.numerator = unit.numerator.concat(other.unit.denominator).sort()\n      unit.denominator = unit.denominator.concat(other.unit.numerator).sort()\n      unit.cancel()\n    }\n    return new Dimension(value, unit)\n  }\n\n  compare(other) {\n    let a\n    let b\n\n    if (!(other instanceof Dimension)) {\n      return undefined\n    }\n\n    if (this.unit.isEmpty() || other.unit.isEmpty()) {\n      a = this\n      b = other\n    } else {\n      a = this.unify()\n      b = other.unify()\n      if (a.unit.compare(b.unit) !== 0) {\n        return undefined\n      }\n    }\n\n    return Node.numericCompare(a.value, b.value)\n  }\n\n  unify() {\n    return this.convertTo({ length: 'px', duration: 's', angle: 'rad' })\n  }\n\n  convertTo(conversions) {\n    let value = this.value\n    const unit = this.unit.clone()\n    let i\n    let groupName\n    let group\n    let targetUnit\n    let derivedConversions = {}\n    let applyUnit\n\n    if (typeof conversions === 'string') {\n      for (i in unitConversions) {\n        if (unitConversions[i].hasOwnProperty(conversions)) {\n          derivedConversions = {}\n          derivedConversions[i] = conversions\n        }\n      }\n      conversions = derivedConversions\n    }\n    applyUnit = (atomicUnit, denominator) => {\n      /* jshint loopfunc:true */\n      if (group.hasOwnProperty(atomicUnit)) {\n        if (denominator) {\n          value = value / (group[atomicUnit] / group[targetUnit])\n        } else {\n          value = value * (group[atomicUnit] / group[targetUnit])\n        }\n\n        return targetUnit\n      }\n\n      return atomicUnit\n    }\n\n    for (groupName in conversions) {\n      if (conversions.hasOwnProperty(groupName)) {\n        targetUnit = conversions[groupName]\n        group = unitConversions[groupName]\n\n        unit.map(applyUnit)\n      }\n    }\n\n    unit.cancel()\n\n    return new Dimension(value, unit)\n  }\n}\n\nDimension.prototype.type = 'Dimension'\nmodule.exports = Dimension\n","const Node = require('./node')\nconst Color = require('./color')\nconst Dimension = require('./dimension')\nconst Paren = require('./paren')\n\nclass Operation extends Node {\n  constructor(op, operands, isSpaced, isRootVariable = false) {\n    super()\n    this.op = op.trim()\n    this.operands = operands\n    this.isSpaced = isSpaced\n    this.isRootVariable = isRootVariable\n  }\n\n  accept(visitor) {\n    this.operands = visitor.visit(this.operands)\n  }\n\n  eval(context) {\n    let a = this.operands[0].eval(context)\n    let b = this.operands[1].eval(context)\n    const isRootVariable = !!(a.isRootVariable || b.isRootVariable)\n    if (context.isMathOn() && !isRootVariable) {\n      if (a instanceof Dimension && b instanceof Color) {\n        a = a.toColor()\n      }\n      if (b instanceof Dimension && a instanceof Color) {\n        b = b.toColor()\n      }\n      if (!a.operate) {\n        if (context.simplify) {\n          return new Operation(this.op, [a, b], this.isSpaced, isRootVariable)\n        } else {\n          throw {\n            type: 'Operation',\n            message: 'Operation on an invalid type',\n          }\n        }\n      }\n\n      return a.operate(context, this.op, b)\n    } else {\n      const cloneOp = new Operation(\n        this.op,\n        [a, b],\n        this.isSpaced,\n        isRootVariable\n      )\n      if (\n        !context.isInCall() &&\n        ((a.parensInOp && b.parensInOp) || context.isInParens())\n      ) {\n        return new Paren(cloneOp)\n      }\n      return cloneOp\n    }\n  }\n\n  genCSS(context, output) {\n    this.operands[0].genCSS(context, output)\n    if (this.isSpaced) {\n      output.add(' ')\n    }\n    output.add(this.op)\n    if (this.isSpaced) {\n      output.add(' ')\n    }\n    this.operands[1].genCSS(context, output)\n  }\n}\n\nOperation.prototype.type = 'Operation'\n\nmodule.exports = Operation\n","const Node = require('./node')\n\nclass Variable extends Node {\n  constructor(name, index, currentFileInfo) {\n    super()\n    this.name = name\n    this.index = index\n    this.currentFileInfo = currentFileInfo || {}\n  }\n\n  eval(context) {\n    let variable\n    let name = this.name\n\n    if (name.indexOf('@@') === 0) {\n      name = `@${new Variable(\n        name.slice(1),\n        this.index,\n        this.currentFileInfo\n      ).eval(context).value}`\n    }\n\n    if (this.evaluating) {\n      throw {\n        type: 'Name',\n        message: `Recursive variable definition for ${name}`,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n\n    this.evaluating = true\n    const current = this\n    variable = this.find(context.frames, frame => {\n      const v = frame.variable(name)\n      if (v) {\n        if (v.important) {\n          const importantScope =\n            context.importantScope[context.importantScope.length - 1]\n          importantScope.important = v.important\n        }\n        if (\n          frame.root &&\n          context.simplify &&\n          (!context.simplifyFilter || context.simplifyFilter.test(name))\n        ) {\n          // Wrap root\n          current.isRootVariable = true\n\n          //Add genCSS and toCSS\n          current.genCSS = function(context, output) {\n            if (context && context.frames) {\n              //In eval context\n              output.add(this.toCSS(context))\n            } else {\n              output.add(this.name)\n            }\n          }.bind(current)\n\n          current.toCSS = function() {\n            return `@{${this.name.slice(1)}}`\n          }.bind(current)\n\n          return current //don't eval root variables in simple mode\n        }\n        return v.value.eval(context)\n      }\n    })\n    if (variable) {\n      this.evaluating = false\n      return variable\n    } else {\n      throw {\n        type: 'Name',\n        message: `variable ${name} is undefined`,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n  }\n\n  find(obj, fun) {\n    for (let i = 0, r; i < obj.length; i++) {\n      r = fun.call(obj, obj[i])\n      if (r) {\n        return r\n      }\n    }\n    return null\n  }\n}\n\nVariable.prototype.type = 'Variable'\nmodule.exports = Variable\n","const Node = require('./node')\n\nclass Attribute extends Node {\n  constructor(key, op, value) {\n    super()\n    this.key = key\n    this.op = op\n    this.value = value\n  }\n\n  eval(context) {\n    return new Attribute(\n      this.key.eval ? this.key.eval(context) : this.key,\n      this.op,\n      this.value && this.value.eval ? this.value.eval(context) : this.value\n    )\n  }\n\n  genCSS(context, output) {\n    output.add(this.toCSS(context))\n  }\n\n  toCSS(context) {\n    let value = this.key.toCSS ? this.key.toCSS(context) : this.key\n\n    if (this.op) {\n      value += this.op\n      value += this.value.toCSS ? this.value.toCSS(context) : this.value\n    }\n\n    return `[${value}]`\n  }\n}\n\nAttribute.prototype.type = 'Attribute'\nmodule.exports = Attribute\n","const Node = require('./node')\nconst Variable = require('./variable')\n\nclass JsEvalNode extends Node {\n  evaluateJavaScript(expression, context) {\n    let result\n    const that = this\n    const evalContext = {}\n\n    if (context.javascriptEnabled !== undefined && !context.javascriptEnabled) {\n      throw {\n        message: 'You are using JavaScript, which has been disabled.',\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n\n    expression = expression.replace(/@\\{([\\w-]+)\\}/g, (_, name) =>\n      that.jsify(\n        new Variable(`@${name}`, that.index, that.currentFileInfo).eval(context)\n      )\n    )\n\n    try {\n      expression = new Function(`return (${expression})`)\n    } catch (e) {\n      throw {\n        message: `JavaScript evaluation error: ${e.message} from \\`${expression}\\``,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n\n    const variables = context.frames[0].variables()\n    for (const k in variables) {\n      if (variables.hasOwnProperty(k)) {\n        /*jshint loopfunc:true */\n        evalContext[k.slice(1)] = {\n          value: variables[k].value,\n          toJS() {\n            return this.value.eval(context).toCSS()\n          },\n        }\n      }\n    }\n\n    try {\n      result = expression.call(evalContext)\n    } catch (e) {\n      throw {\n        message: `JavaScript evaluation error: '${e.name}: ${e.message.replace(\n          /[\"]/g,\n          \"'\"\n        )}'`,\n        filename: this.currentFileInfo.filename,\n        index: this.index,\n      }\n    }\n    return result\n  }\n\n  jsify(obj) {\n    if (Array.isArray(obj.value) && obj.value.length > 1) {\n      return `[${obj.value.map(v => v.toCSS()).join(', ')}]`\n    } else {\n      return obj.toCSS()\n    }\n  }\n}\n\nmodule.exports = JsEvalNode\n","const Node = require('./node')\nconst JsEvalNode = require('./js-eval-node')\nconst Variable = require('./variable')\n\nclass Quoted extends JsEvalNode {\n  constructor(str, content, escaped, index, currentFileInfo) {\n    super()\n    this.escaped = escaped == null ? true : escaped\n    this.value = content || ''\n    this.quote = str.charAt(0)\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n  }\n\n  genCSS(context, output) {\n    if (!this.escaped) {\n      output.add(this.quote, this.currentFileInfo, this.index)\n    }\n    output.add(this.value)\n    if (!this.escaped) {\n      output.add(this.quote)\n    }\n  }\n\n  containsVariables() {\n    return this.value.match(/(`([^`]+)`)|@\\{([\\w-]+)\\}/)\n  }\n\n  eval(context) {\n    const that = this\n    let value = this.value\n    const javascriptReplacement = (_, exp) =>\n      String(that.evaluateJavaScript(exp, context))\n    const interpolationReplacement = (_, name) => {\n      const v = new Variable(`@${name}`, that.index, that.currentFileInfo).eval(\n        context,\n        true\n      )\n      return v instanceof Quoted ? v.value : v.toCSS()\n    }\n    function iterativeReplace(value, regexp, replacementFnc) {\n      let evaluatedValue = value\n      do {\n        value = evaluatedValue\n        evaluatedValue = value.replace(regexp, replacementFnc)\n      } while (value !== evaluatedValue)\n      return evaluatedValue\n    }\n    value = iterativeReplace(value, /`([^`]+)`/g, javascriptReplacement)\n    value = iterativeReplace(value, /@\\{([\\w-]+)\\}/g, interpolationReplacement)\n    return new Quoted(\n      this.quote + value + this.quote,\n      value,\n      this.escaped,\n      this.index,\n      this.currentFileInfo\n    )\n  }\n\n  compare(other) {\n    // when comparing quoted strings allow the quote to differ\n    if (other.type === 'Quoted' && !this.escaped && !other.escaped) {\n      return Node.numericCompare(this.value, other.value)\n    } else {\n      return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined\n    }\n  }\n}\n\nQuoted.prototype.type = 'Quoted'\nmodule.exports = Quoted\n","const Node = require('./node')\nconst getDebugInfo = require('./debug-info')\n\nclass Comment extends Node {\n  constructor(value, isLineComment, index, currentFileInfo) {\n    super()\n    this.value = value\n    this.isLineComment = isLineComment\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.allowRoot = true\n  }\n\n  genCSS(context, output) {\n    if (this.debugInfo) {\n      output.add(getDebugInfo(context, this), this.currentFileInfo, this.index)\n    }\n    output.add(this.value)\n  }\n\n  isSilent(context) {\n    const isCompressed = context.compress && this.value[2] !== '!'\n    return this.isLineComment || isCompressed\n  }\n}\n\nComment.prototype.type = 'Comment'\nmodule.exports = Comment\n","const Node = require('./node')\nconst Paren = require('./paren')\nconst Comment = require('./comment')\n\nclass Expression extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n    if (!value) {\n      throw new Error('Expression requires an array parameter')\n    }\n  }\n\n  accept(visitor) {\n    this.value = visitor.visitArray(this.value)\n  }\n\n  eval(context) {\n    let returnValue\n    const inParenthesis = this.parens && !this.parensInOp\n    let doubleParen = false\n    if (inParenthesis) {\n      context.inParenthesis()\n    }\n    if (this.value.length > 1) {\n      returnValue = new Expression(this.value.map(e => e.eval(context)))\n    } else if (this.value.length === 1) {\n      if (this.value[0].parens && !this.value[0].parensInOp) {\n        doubleParen = true\n      }\n      returnValue = this.value[0].eval(context)\n    } else {\n      returnValue = this\n    }\n    if (inParenthesis) {\n      context.outOfParenthesis()\n    }\n    if (this.parens && this.parensInOp && !context.isMathOn() && !doubleParen) {\n      returnValue = new Paren(returnValue)\n    }\n    return returnValue\n  }\n\n  genCSS(context, output) {\n    for (let i = 0; i < this.value.length; i++) {\n      this.value[i].genCSS(context, output)\n      if (i + 1 < this.value.length) {\n        output.add(' ')\n      }\n    }\n  }\n\n  throwAwayComments() {\n    this.value = this.value.filter(v => !(v instanceof Comment))\n  }\n}\n\nExpression.prototype.type = 'Expression'\nmodule.exports = Expression\n","const Expression = require('../tree/expression')\n\nclass functionCaller {\n  constructor(name, context, index, currentFileInfo) {\n    this.name = name.toLowerCase()\n    this.index = index\n    this.context = context\n    this.currentFileInfo = currentFileInfo\n\n    this.func = context.frames[0].functionRegistry.get(this.name)\n  }\n\n  isValid() {\n    return Boolean(this.func)\n  }\n\n  call(args) {\n    // This code is terrible and should be replaced as per this issue...\n    // https://github.com/less/less.js/issues/2477\n    if (Array.isArray(args)) {\n      args = args\n        .filter(item => {\n          if (item.type === 'Comment') {\n            return false\n          }\n          return true\n        })\n        .map(item => {\n          if (item.type === 'Expression') {\n            const subNodes = item.value.filter(item => {\n              if (item.type === 'Comment') {\n                return false\n              }\n              return true\n            })\n            if (subNodes.length === 1) {\n              return subNodes[0]\n            } else {\n              return new Expression(subNodes)\n            }\n          }\n          return item\n        })\n    }\n\n    return this.func(...args)\n  }\n}\n\nmodule.exports = functionCaller\n","const Node = require('./node')\nconst FunctionCaller = require('../functions/function-caller')\n\n//\n// A function call node.\n//\nclass Call extends Node {\n  constructor(name, args, index, currentFileInfo) {\n    super()\n    this.name = name\n    this.args = args\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n  }\n\n  accept(visitor) {\n    if (this.args) {\n      this.args = visitor.visitArray(this.args)\n    }\n  }\n\n  //\n  // When evaluating a function call,\n  // we either find the function in the functionRegistry,\n  // in which case we call it, passing the  evaluated arguments,\n  // if this returns null or we cannot find the function, we\n  // simply print it out as it appeared originally [2].\n  //\n  // The reason why we evaluate the arguments, is in the case where\n  // we try to pass a variable to a function, like: `saturate(@color)`.\n  // The function should receive the value, not the variable.\n  //\n  eval(context) {\n    context.inCall()\n    const args = this.args.map(a => a.eval(context))\n    context.outOfCall()\n    let result\n    const funcCaller = new FunctionCaller(\n      this.name,\n      context,\n      this.index,\n      this.currentFileInfo\n    )\n    //Check if any of root vars take place\n    for (const arg of args) {\n      if (arg.isRootVariable)\n        return new Call(this.name, args, this.index, this.currentFileInfo)\n    }\n\n    if (funcCaller.isValid()) {\n      try {\n        result = funcCaller.call(args)\n      } catch (e) {\n        throw {\n          type: e.type || 'Runtime',\n          message: `error evaluating function \\`${this.name}\\`${\n            e.message ? ': ' + e.message : ''\n          }`,\n          index: this.index,\n          filename: this.currentFileInfo.filename,\n        }\n      }\n\n      if (result != null) {\n        result.index = this.index\n        result.currentFileInfo = this.currentFileInfo\n        return result\n      }\n    }\n\n    return new Call(this.name, args, this.index, this.currentFileInfo)\n  }\n\n  genCSS(context, output) {\n    output.add(`${this.name}(`, this.currentFileInfo, this.index)\n\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i].genCSS(context, output)\n      if (i + 1 < this.args.length) {\n        output.add(', ')\n      }\n    }\n\n    output.add(')')\n  }\n}\n\nCall.prototype.type = 'Call'\nmodule.exports = Call\n","const Node = require('./node')\n\nclass URL extends Node {\n  constructor(val, index, currentFileInfo, isEvald) {\n    super()\n    this.value = val\n    this.currentFileInfo = currentFileInfo\n    this.index = index\n    this.isEvald = isEvald\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  genCSS(context, output) {\n    output.add('url(')\n    this.value.genCSS(context, output)\n    output.add(')')\n  }\n\n  eval(context) {\n    const val = this.value.eval(context)\n    let rootpath\n\n    if (!this.isEvald) {\n      // Add the base path if the URL is relative\n      rootpath = this.currentFileInfo && this.currentFileInfo.rootpath\n      if (\n        rootpath &&\n        typeof val.value === 'string' &&\n        context.isPathRelative(val.value)\n      ) {\n        if (!val.quote) {\n          rootpath = rootpath.replace(/[\\(\\)'\"\\s]/g, match => `\\\\${match}`)\n        }\n        val.value = rootpath + val.value\n      }\n\n      val.value = context.normalizePath(val.value)\n\n      // Add url args if enabled\n      if (context.urlArgs) {\n        if (!val.value.match(/^\\s*data:/)) {\n          const delimiter = val.value.indexOf('?') === -1 ? '?' : '&'\n          const urlArgs = delimiter + context.urlArgs\n          if (val.value.indexOf('#') !== -1) {\n            val.value = val.value.replace('#', `${urlArgs}#`)\n          } else {\n            val.value += urlArgs\n          }\n        }\n      }\n    }\n\n    return new URL(val, this.index, this.currentFileInfo, true)\n  }\n}\n\nURL.prototype.type = 'Url'\nmodule.exports = URL\n","const Node = require('./node')\n\nclass Anonymous extends Node {\n  constructor(\n    value,\n    index,\n    currentFileInfo,\n    mapLines,\n    rulesetLike,\n    visibilityInfo\n  ) {\n    super()\n    this.value = value\n    this.index = index\n    this.mapLines = mapLines\n    this.currentFileInfo = currentFileInfo\n    this.rulesetLike = typeof rulesetLike === 'undefined' ? false : rulesetLike\n    this.allowRoot = true\n    this.copyVisibilityInfo(visibilityInfo)\n  }\n\n  eval() {\n    return new Anonymous(\n      this.value,\n      this.index,\n      this.currentFileInfo,\n      this.mapLines,\n      this.rulesetLike,\n      this.visibilityInfo()\n    )\n  }\n\n  compare(other) {\n    return other.toCSS && this.toCSS() === other.toCSS() ? 0 : undefined\n  }\n\n  isRulesetLike() {\n    return this.rulesetLike\n  }\n\n  genCSS(context, output) {\n    output.add(this.value, this.currentFileInfo, this.index, this.mapLines)\n  }\n}\n\nAnonymous.prototype.type = 'Anonymous'\nmodule.exports = Anonymous\n","const Ruleset = require('./ruleset')\nconst Value = require('./value')\nconst Selector = require('./selector')\nconst Anonymous = require('./anonymous')\nconst Expression = require('./expression')\nconst Directive = require('./directive')\n\nclass Media extends Directive {\n  constructor(value, features, index, currentFileInfo, visibilityInfo) {\n    super()\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n\n    const selectors = new Selector(\n      [],\n      null,\n      null,\n      this.index,\n      this.currentFileInfo\n    ).createEmptySelectors()\n\n    this.features = new Value(features)\n    this.rules = [new Ruleset(selectors, value)]\n    this.rules[0].allowImports = true\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.features) {\n      this.features = visitor.visit(this.features)\n    }\n    if (this.rules) {\n      this.rules = visitor.visitArray(this.rules)\n    }\n  }\n\n  genCSS(context, output) {\n    output.add('@media ', this.currentFileInfo, this.index)\n    this.features.genCSS(context, output)\n    this.outputRuleset(context, output, this.rules)\n  }\n\n  eval(context) {\n    if (!context.mediaBlocks) {\n      context.mediaBlocks = []\n      context.mediaPath = []\n    }\n\n    const media = new Media(\n      null,\n      [],\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n    if (this.debugInfo) {\n      this.rules[0].debugInfo = this.debugInfo\n      media.debugInfo = this.debugInfo\n    }\n    let strictMathBypass = false\n    if (!context.strictMath) {\n      strictMathBypass = true\n      context.strictMath = true\n    }\n    try {\n      media.features = this.features.eval(context)\n    } finally {\n      if (strictMathBypass) {\n        context.strictMath = false\n      }\n    }\n\n    context.mediaPath.push(media)\n    context.mediaBlocks.push(media)\n\n    this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit()\n    context.frames.unshift(this.rules[0])\n    media.rules = [this.rules[0].eval(context)]\n    context.frames.shift()\n\n    context.mediaPath.pop()\n\n    return context.mediaPath.length === 0\n      ? media.evalTop(context)\n      : media.evalNested(context)\n  }\n\n  evalTop(context) {\n    let result = this\n\n    // Render all dependent Media blocks.\n    if (context.mediaBlocks.length > 1) {\n      const selectors = new Selector(\n        [],\n        null,\n        null,\n        this.index,\n        this.currentFileInfo\n      ).createEmptySelectors()\n      result = new Ruleset(selectors, context.mediaBlocks)\n      result.multiMedia = true\n      result.copyVisibilityInfo(this.visibilityInfo())\n    }\n\n    delete context.mediaBlocks\n    delete context.mediaPath\n\n    return result\n  }\n\n  evalNested(context) {\n    let i\n    let value\n    const path = context.mediaPath.concat([this])\n\n    // Extract the media-query conditions separated with `,` (OR).\n    for (i = 0; i < path.length; i++) {\n      value =\n        path[i].features instanceof Value\n          ? path[i].features.value\n          : path[i].features\n      path[i] = Array.isArray(value) ? value : [value]\n    }\n\n    // Trace all permutations to generate the resulting media-query.\n    //\n    // (a, b and c) with nested (d, e) ->\n    //    a and d\n    //    a and e\n    //    b and c and d\n    //    b and c and e\n    this.features = new Value(\n      this.permute(path).map(path => {\n        path = path.map(\n          fragment => (fragment.toCSS ? fragment : new Anonymous(fragment))\n        )\n\n        for (i = path.length - 1; i > 0; i--) {\n          path.splice(i, 0, new Anonymous('and'))\n        }\n\n        return new Expression(path)\n      })\n    )\n\n    // Fake a tree-node that doesn't output anything.\n    return new Ruleset([], [])\n  }\n\n  permute(arr) {\n    if (arr.length === 0) {\n      return []\n    } else if (arr.length === 1) {\n      return arr[0]\n    } else {\n      const result = []\n      const rest = this.permute(arr.slice(1))\n      for (let i = 0; i < rest.length; i++) {\n        for (let j = 0; j < arr[0].length; j++) {\n          result.push([arr[0][j]].concat(rest[i]))\n        }\n      }\n      return result\n    }\n  }\n\n  bubbleSelectors(selectors) {\n    if (!selectors) {\n      return\n    }\n    this.rules = [new Ruleset(selectors.slice(0), [this.rules[0]])]\n  }\n}\n\nMedia.prototype.type = 'Media'\nMedia.prototype.isRulesetLike = true\nmodule.exports = Media\n","const Node = require('./node')\nconst Media = require('./media')\nconst URL = require('./url')\nconst Quoted = require('./quoted')\nconst Ruleset = require('./ruleset')\nconst Anonymous = require('./anonymous')\n\n//\n// CSS @import node\n//\n// The general strategy here is that we don't want to wait\n// for the parsing to be completed, before we start importing\n// the file. That's because in the context of a browser,\n// most of the time will be spent waiting for the server to respond.\n//\n// On creation, we push the import path to our import queue, though\n// `import,push`, we also pass it a callback, which it'll call once\n// the file has been fetched, and parsed.\n//\nclass Import extends Node {\n  constructor(path, features, options, index, currentFileInfo, visibilityInfo) {\n    super()\n    this.options = options\n    this.index = index\n    this.path = path\n    this.features = features\n    this.currentFileInfo = currentFileInfo\n    this.allowRoot = true\n\n    if (this.options.less !== undefined || this.options.inline) {\n      this.css = !this.options.less || this.options.inline\n    } else {\n      const pathValue = this.getPath()\n      if (pathValue && /[#\\.\\&\\?\\/]css([\\?;].*)?$/.test(pathValue)) {\n        this.css = true\n      }\n    }\n    this.copyVisibilityInfo(visibilityInfo)\n  }\n\n  accept(visitor) {\n    if (this.features) {\n      this.features = visitor.visit(this.features)\n    }\n    this.path = visitor.visit(this.path)\n    if (!this.options.plugin && !this.options.inline && this.root) {\n      this.root = visitor.visit(this.root)\n    }\n  }\n\n  genCSS(context, output) {\n    if (this.css && this.path.currentFileInfo.reference === undefined) {\n      output.add('@import ', this.currentFileInfo, this.index)\n      this.path.genCSS(context, output)\n      if (this.features) {\n        output.add(' ')\n        this.features.genCSS(context, output)\n      }\n      output.add(';')\n    }\n  }\n\n  getPath() {\n    return this.path instanceof URL ? this.path.value.value : this.path.value\n  }\n\n  isVariableImport() {\n    let path = this.path\n    if (path instanceof URL) {\n      path = path.value\n    }\n    if (path instanceof Quoted) {\n      return path.containsVariables()\n    }\n\n    return true\n  }\n\n  evalForImport(context) {\n    let path = this.path\n\n    if (path instanceof URL) {\n      path = path.value\n    }\n\n    return new Import(\n      path.eval(context),\n      this.features,\n      this.options,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  evalPath(context) {\n    const path = this.path.eval(context)\n    const rootpath = this.currentFileInfo && this.currentFileInfo.rootpath\n\n    if (!(path instanceof URL)) {\n      if (rootpath) {\n        const pathValue = path.value\n        // Add the base path if the import is relative\n        if (pathValue && context.isPathRelative(pathValue)) {\n          path.value = rootpath + pathValue\n        }\n      }\n      path.value = context.normalizePath(path.value)\n    }\n\n    return path\n  }\n\n  eval(context) {\n    const result = this.doEval(context)\n    if (this.options.reference || this.blocksVisibility()) {\n      if (result.length || result.length === 0) {\n        result.forEach(node => {\n          node.addVisibilityBlock()\n        })\n      } else {\n        result.addVisibilityBlock()\n      }\n    }\n    return result\n  }\n\n  doEval(context) {\n    let ruleset\n    let registry\n    const features = this.features && this.features.eval(context)\n\n    if (this.options.plugin) {\n      registry = context.frames[0] && context.frames[0].functionRegistry\n      if (registry && this.root && this.root.functions) {\n        registry.addMultiple(this.root.functions)\n      }\n      return []\n    }\n\n    if (this.skip) {\n      if (typeof this.skip === 'function') {\n        this.skip = this.skip()\n      }\n      if (this.skip) {\n        return []\n      }\n    }\n    if (this.options.inline) {\n      const contents = new Anonymous(\n        this.root,\n        0,\n        {\n          filename: this.importedFilename,\n          reference:\n            this.path.currentFileInfo && this.path.currentFileInfo.reference,\n        },\n        true,\n        true\n      )\n\n      return this.features\n        ? new Media([contents], this.features.value)\n        : [contents]\n    } else if (this.css) {\n      const newImport = new Import(\n        this.evalPath(context),\n        features,\n        this.options,\n        this.index\n      )\n      if (!newImport.css && this.error) {\n        throw this.error\n      }\n      return newImport\n    } else {\n      ruleset = new Ruleset(null, this.root.rules.slice(0))\n      ruleset.evalImports(context)\n\n      return this.features\n        ? new Media(ruleset.rules, this.features.value)\n        : ruleset.rules\n    }\n  }\n}\n\nImport.prototype.type = 'Import'\nmodule.exports = Import\n","const Selector = require('./selector')\nconst Element = require('./element')\nconst Ruleset = require('./ruleset')\nconst Rule = require('./rule')\nconst Expression = require('./expression')\nconst contexts = require('../contexts')\n\nclass Definition extends Ruleset {\n  constructor(\n    name,\n    params,\n    rules,\n    condition,\n    variadic,\n    frames,\n    visibilityInfo\n  ) {\n    super()\n    this.name = name\n    this.selectors = [\n      new Selector([new Element(null, name, this.index, this.currentFileInfo)]),\n    ]\n    this.params = params\n    this.condition = condition\n    this.variadic = variadic\n    this.arity = params.length\n    this.rules = rules\n    this._lookups = {}\n    const optionalParameters = []\n    this.required = params.reduce((count, p) => {\n      if (!p.name || (p.name && !p.value)) {\n        return count + 1\n      } else {\n        optionalParameters.push(p.name)\n        return count\n      }\n    }, 0)\n    this.optionalParameters = optionalParameters\n    this.frames = frames\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.params && this.params.length) {\n      this.params = visitor.visitArray(this.params)\n    }\n    this.rules = visitor.visitArray(this.rules)\n    if (this.condition) {\n      this.condition = visitor.visit(this.condition)\n    }\n  }\n\n  evalParams(context, mixinEnv, args, evaldArguments) {\n    /*jshint boss:true */\n    const frame = new Ruleset(null, null)\n\n    let varargs\n    let arg\n    const params = this.params.slice(0)\n    let i\n    let j\n    let val\n    let name\n    let isNamedFound\n    let argIndex\n    let argsLength = 0\n\n    if (\n      mixinEnv.frames &&\n      mixinEnv.frames[0] &&\n      mixinEnv.frames[0].functionRegistry\n    ) {\n      frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit()\n    }\n    mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames))\n\n    if (args) {\n      args = args.slice(0)\n      argsLength = args.length\n\n      for (i = 0; i < argsLength; i++) {\n        arg = args[i]\n        if ((name = arg && arg.name)) {\n          isNamedFound = false\n          for (j = 0; j < params.length; j++) {\n            if (!evaldArguments[j] && name === params[j].name) {\n              evaldArguments[j] = arg.value.eval(context)\n              frame.prependRule(new Rule(name, arg.value.eval(context)))\n              isNamedFound = true\n              break\n            }\n          }\n          if (isNamedFound) {\n            args.splice(i, 1)\n            i--\n            continue\n          } else {\n            throw {\n              type: 'Runtime',\n              message: `Named argument for ${this.name} ${args[i]\n                .name} not found`,\n            }\n          }\n        }\n      }\n    }\n    argIndex = 0\n    for (i = 0; i < params.length; i++) {\n      if (evaldArguments[i]) {\n        continue\n      }\n\n      arg = args && args[argIndex]\n\n      if ((name = params[i].name)) {\n        if (params[i].variadic) {\n          varargs = []\n          for (j = argIndex; j < argsLength; j++) {\n            varargs.push(args[j].value.eval(context))\n          }\n          frame.prependRule(\n            new Rule(name, new Expression(varargs).eval(context))\n          )\n        } else {\n          val = arg && arg.value\n          if (val) {\n            val = val.eval(context)\n          } else if (params[i].value) {\n            val = params[i].value.eval(mixinEnv)\n            frame.resetCache()\n          } else {\n            throw {\n              type: 'Runtime',\n              message: `wrong number of arguments for ${this\n                .name} (${argsLength} for ${this.arity})`,\n            }\n          }\n\n          frame.prependRule(new Rule(name, val))\n          evaldArguments[i] = val\n        }\n      }\n\n      if (params[i].variadic && args) {\n        for (j = argIndex; j < argsLength; j++) {\n          evaldArguments[j] = args[j].value.eval(context)\n        }\n      }\n      argIndex++\n    }\n\n    return frame\n  }\n\n  makeImportant() {\n    const rules = !this.rules\n      ? this.rules\n      : this.rules.map(r => {\n          if (r.makeImportant) {\n            return r.makeImportant(true)\n          } else {\n            return r\n          }\n        })\n    const result = new Definition(\n      this.name,\n      this.params,\n      rules,\n      this.condition,\n      this.variadic,\n      this.frames\n    )\n    return result\n  }\n\n  eval(context) {\n    return new Definition(\n      this.name,\n      this.params,\n      this.rules,\n      this.condition,\n      this.variadic,\n      this.frames || context.frames.slice(0)\n    )\n  }\n\n  evalCall(context, args, important) {\n    const _arguments = []\n    const mixinFrames = this.frames\n      ? this.frames.concat(context.frames)\n      : context.frames\n    const frame = this.evalParams(\n      context,\n      new contexts.Eval(context, mixinFrames),\n      args,\n      _arguments\n    )\n    let rules\n    let ruleset\n\n    frame.prependRule(\n      new Rule('@arguments', new Expression(_arguments).eval(context))\n    )\n\n    rules = this.rules.slice(0)\n\n    ruleset = new Ruleset(null, rules)\n    ruleset.originalRuleset = this\n    ruleset = ruleset.eval(\n      new contexts.Eval(context, [this, frame].concat(mixinFrames))\n    )\n    if (important) {\n      ruleset = ruleset.makeImportant()\n    }\n    return ruleset\n  }\n\n  matchCondition(args, context) {\n    if (\n      this.condition &&\n      !this.condition.eval(\n        new contexts.Eval(\n          context,\n          [\n            this.evalParams(\n              context /* the parameter variables*/,\n              new contexts.Eval(\n                context,\n                this.frames\n                  ? this.frames.concat(context.frames)\n                  : context.frames\n              ),\n              args,\n              []\n            ),\n          ]\n            .concat(this.frames || []) // the parent namespace/mixin frames\n            .concat(context.frames)\n        )\n      )\n    ) {\n      // the current environment frames\n      return false\n    }\n    return true\n  }\n\n  matchArgs(args, context) {\n    const allArgsCnt = (args && args.length) || 0\n    let len\n    const optionalParameters = this.optionalParameters\n    const requiredArgsCnt = !args\n      ? 0\n      : args.reduce((count, p) => {\n          if (optionalParameters.indexOf(p.name) < 0) {\n            return count + 1\n          } else {\n            return count\n          }\n        }, 0)\n\n    if (!this.variadic) {\n      if (requiredArgsCnt < this.required) {\n        return false\n      }\n      if (allArgsCnt > this.params.length) {\n        return false\n      }\n    } else {\n      if (requiredArgsCnt < this.required - 1) {\n        return false\n      }\n    }\n\n    // check patterns\n    len = Math.min(requiredArgsCnt, this.arity)\n\n    for (let i = 0; i < len; i++) {\n      if (!this.params[i].name && !this.params[i].variadic) {\n        if (\n          args[i].value.eval(context).toCSS() !=\n          this.params[i].value.eval(context).toCSS()\n        ) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n}\n\nDefinition.prototype.type = 'MixinDefinition'\nDefinition.prototype.evalFirst = true\nmodule.exports = Definition\n","const Node = require('./node')\nconst Selector = require('./selector')\nconst MixinDefinition = require('./mixin-definition')\nconst defaultFunc = require('../functions/default')\n\nclass MixinCall extends Node {\n  constructor(elements, args, index, currentFileInfo, important) {\n    super()\n    this.selector = new Selector(elements)\n    this.arguments = args || []\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n    this.important = important\n    this.allowRoot = true\n  }\n\n  accept(visitor) {\n    if (this.selector) {\n      this.selector = visitor.visit(this.selector)\n    }\n    if (this.arguments.length) {\n      this.arguments = visitor.visitArray(this.arguments)\n    }\n  }\n\n  eval(context) {\n    let mixins\n    let mixin\n    let mixinPath\n    const args = []\n    let arg\n    let argValue\n    const rules = []\n    let match = false\n    let i\n    let m\n    let f\n    let isRecursive\n    let isOneFound\n    const candidates = []\n    let candidate\n    const conditionResult = []\n    let defaultResult\n    const defFalseEitherCase = -1\n    const defNone = 0\n    const defTrue = 1\n    const defFalse = 2\n    let count\n    let originalRuleset\n    let noArgumentsFilter\n\n    function calcDefGroup(mixin, mixinPath) {\n      let f\n      let p\n      let namespace\n\n      for (f = 0; f < 2; f++) {\n        conditionResult[f] = true\n        defaultFunc.value(f)\n        for (p = 0; p < mixinPath.length && conditionResult[f]; p++) {\n          namespace = mixinPath[p]\n          if (namespace.matchCondition) {\n            conditionResult[f] =\n              conditionResult[f] && namespace.matchCondition(null, context)\n          }\n        }\n        if (mixin.matchCondition) {\n          conditionResult[f] =\n            conditionResult[f] && mixin.matchCondition(args, context)\n        }\n      }\n      if (conditionResult[0] || conditionResult[1]) {\n        if (conditionResult[0] != conditionResult[1]) {\n          return conditionResult[1] ? defTrue : defFalse\n        }\n\n        return defNone\n      }\n      return defFalseEitherCase\n    }\n\n    for (i = 0; i < this.arguments.length; i++) {\n      arg = this.arguments[i]\n      argValue = arg.value.eval(context)\n      if (arg.expand && Array.isArray(argValue.value)) {\n        argValue = argValue.value\n        for (m = 0; m < argValue.length; m++) {\n          args.push({ value: argValue[m] })\n        }\n      } else {\n        args.push({ name: arg.name, value: argValue })\n      }\n    }\n\n    noArgumentsFilter = rule => rule.matchArgs(null, context)\n\n    for (i = 0; i < context.frames.length; i++) {\n      if (\n        (mixins = context.frames[i].find(\n          this.selector,\n          null,\n          noArgumentsFilter\n        )).length > 0\n      ) {\n        isOneFound = true\n\n        // To make `default()` function independent of definition order we have two \"subpasses\" here.\n        // At first we evaluate each guard *twice* (with `default() == true` and `default() == false`),\n        // and build candidate list with corresponding flags. Then, when we know all possible matches,\n        // we make a final decision.\n\n        for (m = 0; m < mixins.length; m++) {\n          mixin = mixins[m].rule\n          mixinPath = mixins[m].path\n          isRecursive = false\n          for (f = 0; f < context.frames.length; f++) {\n            if (\n              !(mixin instanceof MixinDefinition) &&\n              mixin === (context.frames[f].originalRuleset || context.frames[f])\n            ) {\n              isRecursive = true\n              break\n            }\n          }\n          if (isRecursive) {\n            continue\n          }\n\n          if (mixin.matchArgs(args, context)) {\n            candidate = { mixin, group: calcDefGroup(mixin, mixinPath) }\n\n            if (candidate.group !== defFalseEitherCase) {\n              candidates.push(candidate)\n            }\n\n            match = true\n          }\n        }\n\n        defaultFunc.reset()\n\n        count = [0, 0, 0]\n        for (m = 0; m < candidates.length; m++) {\n          count[candidates[m].group]++\n        }\n\n        if (count[defNone] > 0) {\n          defaultResult = defFalse\n        } else {\n          defaultResult = defTrue\n          if (count[defTrue] + count[defFalse] > 1) {\n            throw {\n              type: 'Runtime',\n              message: `Ambiguous use of \\`default()\\` found when matching for \\`${this.format(\n                args\n              )}\\``,\n              index: this.index,\n              filename: this.currentFileInfo.filename,\n            }\n          }\n        }\n\n        for (m = 0; m < candidates.length; m++) {\n          candidate = candidates[m].group\n          if (candidate === defNone || candidate === defaultResult) {\n            try {\n              mixin = candidates[m].mixin\n              if (!(mixin instanceof MixinDefinition)) {\n                originalRuleset = mixin.originalRuleset || mixin\n                mixin = new MixinDefinition(\n                  '',\n                  [],\n                  mixin.rules,\n                  null,\n                  false,\n                  null,\n                  originalRuleset.visibilityInfo()\n                )\n                mixin.originalRuleset = originalRuleset\n              }\n              const newRules = mixin.evalCall(context, args, this.important)\n                .rules\n              this._setVisibilityToReplacement(newRules)\n              Array.prototype.push.apply(rules, newRules)\n            } catch (e) {\n              throw {\n                message: e.message,\n                index: this.index,\n                filename: this.currentFileInfo.filename,\n                stack: e.stack,\n              }\n            }\n          }\n        }\n\n        if (match) {\n          return rules\n        }\n      }\n    }\n    if (isOneFound) {\n      throw {\n        type: 'Runtime',\n        message: `No matching definition was found for \\`${this.format(\n          args\n        )}\\``,\n        index: this.index,\n        filename: this.currentFileInfo.filename,\n      }\n    } else {\n      throw {\n        type: 'Name',\n        message: `${this.selector.toCSS().trim()} is undefined`,\n        index: this.index,\n        filename: this.currentFileInfo.filename,\n      }\n    }\n  }\n\n  _setVisibilityToReplacement(replacement) {\n    let i\n    let rule\n    if (this.blocksVisibility()) {\n      for (i = 0; i < replacement.length; i++) {\n        rule = replacement[i]\n        rule.addVisibilityBlock()\n      }\n    }\n  }\n\n  format(args) {\n    return `${this.selector.toCSS().trim()}(${args\n      ? args\n          .map(a => {\n            let argValue = ''\n            if (a.name) {\n              argValue += a.name + ':'\n            }\n            if (a.value.toCSS) {\n              argValue += a.value.toCSS()\n            } else {\n              argValue += '???'\n            }\n            return argValue\n          })\n          .join(', ')\n      : ''})`\n  }\n}\n\nMixinCall.prototype.type = 'MixinCall'\nmodule.exports = MixinCall\n","const JsEvalNode = require('./js-eval-node')\nconst Dimension = require('./dimension')\nconst Quoted = require('./quoted')\nconst Anonymous = require('./anonymous')\n\nclass JavaScript extends JsEvalNode {\n  constructor(string, escaped, index, currentFileInfo) {\n    super()\n    this.escaped = escaped\n    this.expression = string\n    this.index = index\n    this.currentFileInfo = currentFileInfo\n  }\n\n  eval(context) {\n    const result = this.evaluateJavaScript(this.expression, context)\n\n    if (typeof result === 'number') {\n      return new Dimension(result)\n    } else if (typeof result === 'string') {\n      return new Quoted(`\"${result}\"`, result, this.escaped, this.index)\n    } else if (Array.isArray(result)) {\n      return new Anonymous(result.join(', '))\n    } else {\n      return new Anonymous(result)\n    }\n  }\n}\n\nJavaScript.prototype.type = 'JavaScript'\n\nmodule.exports = JavaScript\n","const Node = require('./node')\n\nclass Assignment extends Node {\n  constructor(key, val) {\n    super()\n    this.key = key\n    this.value = val\n  }\n\n  accept(visitor) {\n    this.value = visitor.visit(this.value)\n  }\n\n  eval(context) {\n    if (this.value.eval) {\n      return new Assignment(this.key, this.value.eval(context))\n    }\n    return this\n  }\n\n  genCSS(context, output) {\n    output.add(`${this.key}=`)\n    if (this.value.genCSS) {\n      this.value.genCSS(context, output)\n    } else {\n      output.add(this.value)\n    }\n  }\n}\n\nAssignment.prototype.type = 'Assignment'\nmodule.exports = Assignment\n","const Node = require('./node')\n\nclass Condition extends Node {\n  constructor(op, l, r, i, negate) {\n    super()\n    this.op = op.trim()\n    this.lvalue = l\n    this.rvalue = r\n    this.index = i\n    this.negate = negate\n  }\n\n  accept(visitor) {\n    this.lvalue = visitor.visit(this.lvalue)\n    this.rvalue = visitor.visit(this.rvalue)\n  }\n\n  eval(context) {\n    const result = ((op, a, b) => {\n      switch (op) {\n        case 'and':\n          return a && b\n        case 'or':\n          return a || b\n        default:\n          switch (Node.compare(a, b)) {\n            case -1:\n              return op === '<' || op === '=<' || op === '<='\n            case 0:\n              return op === '=' || op === '>=' || op === '=<' || op === '<='\n            case 1:\n              return op === '>' || op === '>='\n            default:\n              return false\n          }\n      }\n    })(this.op, this.lvalue.eval(context), this.rvalue.eval(context))\n\n    return this.negate ? !result : result\n  }\n}\n\nCondition.prototype.type = 'Condition'\nmodule.exports = Condition\n","const Node = require('./node')\n\nclass UnicodeDescriptor extends Node {\n  constructor(value) {\n    super()\n    this.value = value\n  }\n}\n\nUnicodeDescriptor.prototype.type = 'UnicodeDescriptor'\n\nmodule.exports = UnicodeDescriptor\n","const Node = require('./node')\nconst Operation = require('./operation')\nconst Dimension = require('./dimension')\n\nclass Negative extends Node {\n  constructor(node) {\n    super()\n    this.value = node\n  }\n\n  genCSS(context, output) {\n    output.add('-')\n    this.value.genCSS(context, output)\n  }\n\n  eval(context) {\n    if (context.isMathOn()) {\n      return new Operation('*', [new Dimension(-1), this.value]).eval(context)\n    }\n    return new Negative(this.value.eval(context))\n  }\n}\n\nNegative.prototype.type = 'Negative'\nmodule.exports = Negative\n","const Node = require('./node')\nconst Selector = require('./selector')\n\nclass Extend extends Node {\n  constructor(selector, option, index, currentFileInfo, visibilityInfo) {\n    super()\n    this.selector = selector\n    this.option = option\n    this.index = index\n    this.object_id = Extend.next_id++\n    this.parent_ids = [this.object_id]\n    this.currentFileInfo = currentFileInfo || {}\n    this.copyVisibilityInfo(visibilityInfo)\n    this.allowRoot = true\n\n    switch (option) {\n      case 'all':\n        this.allowBefore = true\n        this.allowAfter = true\n        break\n      default:\n        this.allowBefore = false\n        this.allowAfter = false\n        break\n    }\n  }\n\n  accept(visitor) {\n    this.selector = visitor.visit(this.selector)\n  }\n\n  eval(context) {\n    return new Extend(\n      this.selector.eval(context),\n      this.option,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  clone(context) {\n    return new Extend(\n      this.selector,\n      this.option,\n      this.index,\n      this.currentFileInfo,\n      this.visibilityInfo()\n    )\n  }\n\n  //it concatenates (joins) all selectors in selector array\n  findSelfSelectors(selectors) {\n    let selfElements = []\n    let i\n    let selectorElements\n\n    for (i = 0; i < selectors.length; i++) {\n      selectorElements = selectors[i].elements\n      // duplicate the logic in genCSS function inside the selector node.\n      // future TODO - move both logics into the selector joiner visitor\n      if (\n        i > 0 &&\n        selectorElements.length &&\n        selectorElements[0].combinator.value === ''\n      ) {\n        selectorElements[0].combinator.value = ' '\n      }\n      selfElements = selfElements.concat(selectors[i].elements)\n    }\n\n    this.selfSelectors = [new Selector(selfElements)]\n    this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo())\n  }\n}\n\nExtend.next_id = 0\n\nExtend.prototype.type = 'Extend'\nmodule.exports = Extend\n","const Node = require('./node')\nconst Variable = require('./variable')\n\nclass RulesetCall extends Node {\n  constructor(variable) {\n    super()\n    this.variable = variable\n    this.allowRoot = true\n  }\n\n  eval(context) {\n    const detachedRuleset = new Variable(this.variable).eval(context)\n    return detachedRuleset.callEval(context)\n  }\n}\n\nRulesetCall.prototype.type = 'RulesetCall'\nmodule.exports = RulesetCall\n","const tree = {}\n\ntree.Node = require('./node')\ntree.Alpha = require('./alpha')\ntree.Color = require('./color')\ntree.Directive = require('./directive')\ntree.DetachedRuleset = require('./detached-ruleset')\ntree.Operation = require('./operation')\ntree.Dimension = require('./dimension')\ntree.Unit = require('./unit')\ntree.Keyword = require('./keyword')\ntree.Variable = require('./variable')\ntree.Ruleset = require('./ruleset')\ntree.Element = require('./element')\ntree.Attribute = require('./attribute')\ntree.Combinator = require('./combinator')\ntree.Selector = require('./selector')\ntree.Quoted = require('./quoted')\ntree.Expression = require('./expression')\ntree.Rule = require('./rule')\ntree.Call = require('./call')\ntree.URL = require('./url')\ntree.Import = require('./import')\ntree.mixin = {\n  Call: require('./mixin-call'),\n  Definition: require('./mixin-definition'),\n}\ntree.Comment = require('./comment')\ntree.Anonymous = require('./anonymous')\ntree.Value = require('./value')\ntree.JavaScript = require('./javascript')\ntree.Assignment = require('./assignment')\ntree.Condition = require('./condition')\ntree.Paren = require('./paren')\ntree.Media = require('./media')\ntree.UnicodeDescriptor = require('./unicode-descriptor')\ntree.Negative = require('./negative')\ntree.Extend = require('./extend')\ntree.RulesetCall = require('./ruleset-call')\n\nmodule.exports = tree\n","class ImportSequencer {\n  constructor(onSequencerEmpty) {\n    this.imports = []\n    this.variableImports = []\n    this._onSequencerEmpty = onSequencerEmpty\n    this._currentDepth = 0\n  }\n\n  addImport(callback) {\n    const importSequencer = this\n\n    const importItem = {\n      callback,\n      args: null,\n      isReady: false,\n    }\n\n    this.imports.push(importItem)\n    return function(...args) {\n      importItem.args = Array.prototype.slice.call(args, 0)\n      importItem.isReady = true\n      importSequencer.tryRun()\n    }\n  }\n\n  addVariableImport(callback) {\n    this.variableImports.push(callback)\n  }\n\n  tryRun() {\n    this._currentDepth++\n    try {\n      while (true) {\n        while (this.imports.length > 0) {\n          const importItem = this.imports[0]\n          if (!importItem.isReady) {\n            return\n          }\n          this.imports = this.imports.slice(1)\n          importItem.callback.apply(null, importItem.args)\n        }\n        if (this.variableImports.length === 0) {\n          break\n        }\n        const variableImport = this.variableImports[0]\n        this.variableImports = this.variableImports.slice(1)\n        variableImport()\n      }\n    } finally {\n      this._currentDepth--\n    }\n    if (this._currentDepth === 0 && this._onSequencerEmpty) {\n      this._onSequencerEmpty()\n    }\n  }\n}\n\nmodule.exports = ImportSequencer\n","const contexts = require('../contexts')\nconst Visitor = require('./visitor')\nconst ImportSequencer = require('./import-sequencer')\n\nconst ImportVisitor = function(importer, finish) {\n  this._visitor = new Visitor(this)\n  this._importer = importer\n  this._finish = finish\n  this.context = new contexts.Eval()\n  this.importCount = 0\n  this.onceFileDetectionMap = {}\n  this.recursionDetector = {}\n  this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this))\n}\n\nImportVisitor.prototype = {\n  isReplacing: false,\n  run(root) {\n    try {\n      // process the contents\n      this._visitor.visit(root)\n    } catch (e) {\n      this.error = e\n    }\n\n    this.isFinished = true\n    this._sequencer.tryRun()\n  },\n  _onSequencerEmpty() {\n    if (!this.isFinished) {\n      return\n    }\n    this._finish(this.error)\n  },\n  visitImport(importNode, visitArgs) {\n    const inlineCSS = importNode.options.inline\n\n    if (!importNode.css || inlineCSS) {\n      const context = new contexts.Eval(\n        this.context,\n        this.context.frames.slice(0)\n      )\n      const importParent = context.frames[0]\n\n      this.importCount++\n      if (importNode.isVariableImport()) {\n        this._sequencer.addVariableImport(\n          this.processImportNode.bind(this, importNode, context, importParent)\n        )\n      } else {\n        this.processImportNode(importNode, context, importParent)\n      }\n    }\n    visitArgs.visitDeeper = false\n  },\n  processImportNode(importNode, context, importParent) {\n    let evaldImportNode\n    const inlineCSS = importNode.options.inline\n\n    try {\n      evaldImportNode = importNode.evalForImport(context)\n    } catch (e) {\n      if (!e.filename) {\n        e.index = importNode.index\n        e.filename = importNode.currentFileInfo.filename\n      }\n      // attempt to eval properly and treat as css\n      importNode.css = true\n      // if that fails, this error will be thrown\n      importNode.error = e\n    }\n\n    if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {\n      if (evaldImportNode.options.multiple) {\n        context.importMultiple = true\n      }\n\n      // try appending if we haven't determined if it is css or not\n      const tryAppendLessExtension = evaldImportNode.css === undefined\n\n      for (let i = 0; i < importParent.rules.length; i++) {\n        if (importParent.rules[i] === importNode) {\n          importParent.rules[i] = evaldImportNode\n          break\n        }\n      }\n\n      const onImported = this.onImported.bind(this, evaldImportNode, context)\n      const sequencedOnImported = this._sequencer.addImport(onImported)\n\n      this._importer.push(\n        evaldImportNode.getPath(),\n        tryAppendLessExtension,\n        evaldImportNode.currentFileInfo,\n        evaldImportNode.options,\n        sequencedOnImported\n      )\n    } else {\n      this.importCount--\n      if (this.isFinished) {\n        this._sequencer.tryRun()\n      }\n    }\n  },\n  onImported(importNode, context, e, root, importedAtRoot, fullPath) {\n    if (e) {\n      if (!e.filename) {\n        e.index = importNode.index\n        e.filename = importNode.currentFileInfo.filename\n      }\n      this.error = e\n    }\n\n    const importVisitor = this\n    const inlineCSS = importNode.options.inline\n    const isPlugin = importNode.options.plugin\n    const isOptional = importNode.options.optional\n    const duplicateImport =\n      importedAtRoot || fullPath in importVisitor.recursionDetector\n\n    if (!context.importMultiple) {\n      if (duplicateImport) {\n        importNode.skip = true\n      } else {\n        importNode.skip = () => {\n          if (fullPath in importVisitor.onceFileDetectionMap) {\n            return true\n          }\n          importVisitor.onceFileDetectionMap[fullPath] = true\n          return false\n        }\n      }\n    }\n\n    if (!fullPath && isOptional) {\n      importNode.skip = true\n    }\n\n    if (root) {\n      importNode.root = root\n      importNode.importedFilename = fullPath\n\n      if (\n        !inlineCSS &&\n        !isPlugin &&\n        (context.importMultiple || !duplicateImport)\n      ) {\n        importVisitor.recursionDetector[fullPath] = true\n\n        const oldContext = this.context\n        this.context = context\n        try {\n          this._visitor.visit(root)\n        } catch (e) {\n          this.error = e\n        }\n        this.context = oldContext\n      }\n    }\n\n    importVisitor.importCount--\n\n    if (importVisitor.isFinished) {\n      importVisitor._sequencer.tryRun()\n    }\n  },\n  visitRule(ruleNode, visitArgs) {\n    if (ruleNode.value.type === 'DetachedRuleset') {\n      this.context.frames.unshift(ruleNode)\n    } else {\n      visitArgs.visitDeeper = false\n    }\n  },\n  visitRuleOut(ruleNode) {\n    if (ruleNode.value.type === 'DetachedRuleset') {\n      this.context.frames.shift()\n    }\n  },\n  visitDirective(directiveNode, visitArgs) {\n    this.context.frames.unshift(directiveNode)\n  },\n  visitDirectiveOut(directiveNode) {\n    this.context.frames.shift()\n  },\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    this.context.frames.unshift(mixinDefinitionNode)\n  },\n  visitMixinDefinitionOut(mixinDefinitionNode) {\n    this.context.frames.shift()\n  },\n  visitRuleset(rulesetNode, visitArgs) {\n    this.context.frames.unshift(rulesetNode)\n  },\n  visitRulesetOut(rulesetNode) {\n    this.context.frames.shift()\n  },\n  visitMedia(mediaNode, visitArgs) {\n    this.context.frames.unshift(mediaNode.rules[0])\n  },\n  visitMediaOut(mediaNode) {\n    this.context.frames.shift()\n  },\n}\nmodule.exports = ImportVisitor\n","class SetTreeVisibilityVisitor {\n  constructor(visible) {\n    this.visible = visible\n  }\n\n  run(root) {\n    this.visit(root)\n  }\n\n  visitArray(nodes) {\n    if (!nodes) {\n      return nodes\n    }\n\n    const cnt = nodes.length\n    let i\n    for (i = 0; i < cnt; i++) {\n      this.visit(nodes[i])\n    }\n    return nodes\n  }\n\n  visit(node) {\n    if (!node) {\n      return node\n    }\n    if (node.constructor === Array) {\n      return this.visitArray(node)\n    }\n\n    if (!node.blocksVisibility || node.blocksVisibility()) {\n      return node\n    }\n    if (this.visible) {\n      node.ensureVisibility()\n    } else {\n      node.ensureInvisibility()\n    }\n\n    node.accept(this)\n    return node\n  }\n}\n\nmodule.exports = SetTreeVisibilityVisitor\n","const tree = require('../tree')\nconst Visitor = require('./visitor')\nconst logger = require('../logger')\n\n/*jshint loopfunc:true */\n\nclass ExtendFinderVisitor {\n  constructor() {\n    this._visitor = new Visitor(this)\n    this.contexts = []\n    this.allExtendsStack = [[]]\n  }\n\n  run(root) {\n    root = this._visitor.visit(root)\n    root.allExtends = this.allExtendsStack[0]\n    return root\n  }\n\n  visitRule(ruleNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitRuleset(rulesetNode, visitArgs) {\n    if (rulesetNode.root) {\n      return\n    }\n\n    let i\n    let j\n    let extend\n    const allSelectorsExtendList = []\n    let extendList\n\n    // get &:extend(.a); rules which apply to all selectors in this ruleset\n    const rules = rulesetNode.rules\n\n    const ruleCnt = rules ? rules.length : 0\n    for (i = 0; i < ruleCnt; i++) {\n      if (rulesetNode.rules[i] instanceof tree.Extend) {\n        allSelectorsExtendList.push(rules[i])\n        rulesetNode.extendOnEveryPath = true\n      }\n    }\n\n    // now find every selector and apply the extends that apply to all extends\n    // and the ones which apply to an individual extend\n    const paths = rulesetNode.paths\n    for (i = 0; i < paths.length; i++) {\n      const selectorPath = paths[i]\n      const selector = selectorPath[selectorPath.length - 1]\n      const selExtendList = selector.extendList\n\n      extendList = selExtendList\n        ? selExtendList.slice(0).concat(allSelectorsExtendList)\n        : allSelectorsExtendList\n\n      if (extendList) {\n        extendList = extendList.map(allSelectorsExtend =>\n          allSelectorsExtend.clone()\n        )\n      }\n\n      for (j = 0; j < extendList.length; j++) {\n        this.foundExtends = true\n        extend = extendList[j]\n        extend.findSelfSelectors(selectorPath)\n        extend.ruleset = rulesetNode\n        if (j === 0) {\n          extend.firstExtendOnThisSelectorPath = true\n        }\n        this.allExtendsStack[this.allExtendsStack.length - 1].push(extend)\n      }\n    }\n\n    this.contexts.push(rulesetNode.selectors)\n  }\n\n  visitRulesetOut(rulesetNode) {\n    if (!rulesetNode.root) {\n      this.contexts.length = this.contexts.length - 1\n    }\n  }\n\n  visitMedia(mediaNode, visitArgs) {\n    mediaNode.allExtends = []\n    this.allExtendsStack.push(mediaNode.allExtends)\n  }\n\n  visitMediaOut(mediaNode) {\n    this.allExtendsStack.length = this.allExtendsStack.length - 1\n  }\n\n  visitDirective(directiveNode, visitArgs) {\n    directiveNode.allExtends = []\n    this.allExtendsStack.push(directiveNode.allExtends)\n  }\n\n  visitDirectiveOut(directiveNode) {\n    this.allExtendsStack.length = this.allExtendsStack.length - 1\n  }\n}\n\nclass ProcessExtendsVisitor {\n  constructor() {\n    this._visitor = new Visitor(this)\n  }\n\n  run(root) {\n    const extendFinder = new ExtendFinderVisitor()\n    this.extendIndices = {}\n    extendFinder.run(root)\n    if (!extendFinder.foundExtends) {\n      return root\n    }\n    root.allExtends = root.allExtends.concat(\n      this.doExtendChaining(root.allExtends, root.allExtends)\n    )\n    this.allExtendsStack = [root.allExtends]\n    const newRoot = this._visitor.visit(root)\n    this.checkExtendsForNonMatched(root.allExtends)\n    return newRoot\n  }\n\n  checkExtendsForNonMatched(extendList) {\n    const indices = this.extendIndices\n    extendList\n      .filter(\n        extend => !extend.hasFoundMatches && extend.parent_ids.length == 1\n      )\n      .forEach(extend => {\n        let selector = '_unknown_'\n        try {\n          selector = extend.selector.toCSS({})\n        } catch (_) {}\n\n        if (!indices[`${extend.index} ${selector}`]) {\n          indices[`${extend.index} ${selector}`] = true\n          logger.warn(`extend '${selector}' has no matches`)\n        }\n      })\n  }\n\n  doExtendChaining(extendsList, extendsListTarget, iterationCount) {\n    //\n    // chaining is different from normal extension.. if we extend an extend then we are not just copying, altering\n    // and pasting the selector we would do normally, but we are also adding an extend with the same target selector\n    // this means this new extend can then go and alter other extends\n    //\n    // this method deals with all the chaining work - without it, extend is flat and doesn't work on other extend selectors\n    // this is also the most expensive.. and a match on one selector can cause an extension of a selector we had already\n    // processed if we look at each selector at a time, as is done in visitRuleset\n\n    let extendIndex\n\n    let targetExtendIndex\n    let matches\n    const extendsToAdd = []\n    let newSelector\n    const extendVisitor = this\n    let selectorPath\n    let extend\n    let targetExtend\n    let newExtend\n\n    iterationCount = iterationCount || 0\n\n    //loop through comparing every extend with every target extend.\n    // a target extend is the one on the ruleset we are looking at copy/edit/pasting in place\n    // e.g.  .a:extend(.b) {}  and .b:extend(.c) {} then the first extend extends the second one\n    // and the second is the target.\n    // the separation into two lists allows us to process a subset of chains with a bigger set, as is the\n    // case when processing media queries\n    for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {\n      for (\n        targetExtendIndex = 0;\n        targetExtendIndex < extendsListTarget.length;\n        targetExtendIndex++\n      ) {\n        extend = extendsList[extendIndex]\n        targetExtend = extendsListTarget[targetExtendIndex]\n\n        // look for circular references\n        if (extend.parent_ids.indexOf(targetExtend.object_id) >= 0) {\n          continue\n        }\n\n        // find a match in the target extends self selector (the bit before :extend)\n        selectorPath = [targetExtend.selfSelectors[0]]\n        matches = extendVisitor.findMatch(extend, selectorPath)\n\n        if (matches.length) {\n          extend.hasFoundMatches = true\n\n          // we found a match, so for each self selector..\n          extend.selfSelectors.forEach(selfSelector => {\n            const info = targetExtend.visibilityInfo()\n\n            // process the extend as usual\n            newSelector = extendVisitor.extendSelector(\n              matches,\n              selectorPath,\n              selfSelector,\n              extend.isVisible()\n            )\n\n            // but now we create a new extend from it\n            newExtend = new tree.Extend(\n              targetExtend.selector,\n              targetExtend.option,\n              0,\n              targetExtend.currentFileInfo,\n              info\n            )\n            newExtend.selfSelectors = newSelector\n\n            // add the extend onto the list of extends for that selector\n            newSelector[newSelector.length - 1].extendList = [newExtend]\n\n            // record that we need to add it.\n            extendsToAdd.push(newExtend)\n            newExtend.ruleset = targetExtend.ruleset\n\n            //remember its parents for circular references\n            newExtend.parent_ids = newExtend.parent_ids.concat(\n              targetExtend.parent_ids,\n              extend.parent_ids\n            )\n\n            // only process the selector once.. if we have :extend(.a,.b) then multiple\n            // extends will look at the same selector path, so when extending\n            // we know that any others will be duplicates in terms of what is added to the css\n            if (targetExtend.firstExtendOnThisSelectorPath) {\n              newExtend.firstExtendOnThisSelectorPath = true\n              targetExtend.ruleset.paths.push(newSelector)\n            }\n          })\n        }\n      }\n    }\n\n    if (extendsToAdd.length) {\n      // try to detect circular references to stop a stack overflow.\n      // may no longer be needed.\n      this.extendChainCount++\n      if (iterationCount > 100) {\n        let selectorOne = '{unable to calculate}'\n        let selectorTwo = '{unable to calculate}'\n        try {\n          selectorOne = extendsToAdd[0].selfSelectors[0].toCSS()\n          selectorTwo = extendsToAdd[0].selector.toCSS()\n        } catch (e) {}\n        throw {\n          message: `extend circular reference detected. One of the circular extends is currently:${selectorOne}:extend(${selectorTwo})`,\n        }\n      }\n\n      // now process the new extends on the existing rules so that we can handle a extending b extending c extending\n      // d extending e...\n      return extendsToAdd.concat(\n        extendVisitor.doExtendChaining(\n          extendsToAdd,\n          extendsListTarget,\n          iterationCount + 1\n        )\n      )\n    } else {\n      return extendsToAdd\n    }\n  }\n\n  visitRule(ruleNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitSelector(selectorNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitRuleset(rulesetNode, visitArgs) {\n    if (rulesetNode.root) {\n      return\n    }\n    let matches\n    let pathIndex\n    let extendIndex\n    const allExtends = this.allExtendsStack[this.allExtendsStack.length - 1]\n    const selectorsToAdd = []\n    const extendVisitor = this\n    let selectorPath\n\n    // look at each selector path in the ruleset, find any extend matches and then copy, find and replace\n\n    for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {\n      for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {\n        selectorPath = rulesetNode.paths[pathIndex]\n\n        // extending extends happens initially, before the main pass\n        if (rulesetNode.extendOnEveryPath) {\n          continue\n        }\n        const extendList = selectorPath[selectorPath.length - 1].extendList\n        if (extendList && extendList.length) {\n          continue\n        }\n\n        matches = this.findMatch(allExtends[extendIndex], selectorPath)\n\n        if (matches.length) {\n          allExtends[extendIndex].hasFoundMatches = true\n\n          allExtends[extendIndex].selfSelectors.forEach(selfSelector => {\n            let extendedSelectors\n            extendedSelectors = extendVisitor.extendSelector(\n              matches,\n              selectorPath,\n              selfSelector,\n              allExtends[extendIndex].isVisible()\n            )\n            selectorsToAdd.push(extendedSelectors)\n          })\n        }\n      }\n    }\n    rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd)\n  }\n\n  findMatch(extend, haystackSelectorPath) {\n    //\n    // look through the haystack selector path to try and find the needle - extend.selector\n    // returns an array of selector matches that can then be replaced\n    //\n    let haystackSelectorIndex\n\n    let hackstackSelector\n    let hackstackElementIndex\n    let haystackElement\n    let targetCombinator\n    let i\n    const extendVisitor = this\n    const needleElements = extend.selector.elements\n    const potentialMatches = []\n    let potentialMatch\n    const matches = []\n\n    // loop through the haystack elements\n    for (\n      haystackSelectorIndex = 0;\n      haystackSelectorIndex < haystackSelectorPath.length;\n      haystackSelectorIndex++\n    ) {\n      hackstackSelector = haystackSelectorPath[haystackSelectorIndex]\n\n      for (\n        hackstackElementIndex = 0;\n        hackstackElementIndex < hackstackSelector.elements.length;\n        hackstackElementIndex++\n      ) {\n        haystackElement = hackstackSelector.elements[hackstackElementIndex]\n\n        // if we allow elements before our match we can add a potential match every time. otherwise only at the first element.\n        if (\n          extend.allowBefore ||\n          (haystackSelectorIndex === 0 && hackstackElementIndex === 0)\n        ) {\n          potentialMatches.push({\n            pathIndex: haystackSelectorIndex,\n            index: hackstackElementIndex,\n            matched: 0,\n            initialCombinator: haystackElement.combinator,\n          })\n        }\n\n        for (i = 0; i < potentialMatches.length; i++) {\n          potentialMatch = potentialMatches[i]\n\n          // selectors add \" \" onto the first element. When we use & it joins the selectors together, but if we don't\n          // then each selector in haystackSelectorPath has a space before it added in the toCSS phase. so we need to\n          // work out what the resulting combinator will be\n          targetCombinator = haystackElement.combinator.value\n          if (targetCombinator === '' && hackstackElementIndex === 0) {\n            targetCombinator = ' '\n          }\n\n          // if we don't match, null our match to indicate failure\n          if (\n            !extendVisitor.isElementValuesEqual(\n              needleElements[potentialMatch.matched].value,\n              haystackElement.value\n            ) ||\n            (potentialMatch.matched > 0 &&\n              needleElements[potentialMatch.matched].combinator.value !==\n                targetCombinator)\n          ) {\n            potentialMatch = null\n          } else {\n            potentialMatch.matched++\n          }\n\n          // if we are still valid and have finished, test whether we have elements after and whether these are allowed\n          if (potentialMatch) {\n            potentialMatch.finished =\n              potentialMatch.matched === needleElements.length\n            if (\n              potentialMatch.finished &&\n              (!extend.allowAfter &&\n                (hackstackElementIndex + 1 <\n                  hackstackSelector.elements.length ||\n                  haystackSelectorIndex + 1 < haystackSelectorPath.length))\n            ) {\n              potentialMatch = null\n            }\n          }\n          // if null we remove, if not, we are still valid, so either push as a valid match or continue\n          if (potentialMatch) {\n            if (potentialMatch.finished) {\n              potentialMatch.length = needleElements.length\n              potentialMatch.endPathIndex = haystackSelectorIndex\n              potentialMatch.endPathElementIndex = hackstackElementIndex + 1 // index after end of match\n              potentialMatches.length = 0 // we don't allow matches to overlap, so start matching again\n              matches.push(potentialMatch)\n            }\n          } else {\n            potentialMatches.splice(i, 1)\n            i--\n          }\n        }\n      }\n    }\n    return matches\n  }\n\n  isElementValuesEqual(elementValue1, elementValue2) {\n    if (\n      typeof elementValue1 === 'string' ||\n      typeof elementValue2 === 'string'\n    ) {\n      return elementValue1 === elementValue2\n    }\n    if (elementValue1 instanceof tree.Attribute) {\n      if (\n        elementValue1.op !== elementValue2.op ||\n        elementValue1.key !== elementValue2.key\n      ) {\n        return false\n      }\n      if (!elementValue1.value || !elementValue2.value) {\n        if (elementValue1.value || elementValue2.value) {\n          return false\n        }\n        return true\n      }\n      elementValue1 = elementValue1.value.value || elementValue1.value\n      elementValue2 = elementValue2.value.value || elementValue2.value\n      return elementValue1 === elementValue2\n    }\n    elementValue1 = elementValue1.value\n    elementValue2 = elementValue2.value\n    if (elementValue1 instanceof tree.Selector) {\n      if (\n        !(elementValue2 instanceof tree.Selector) ||\n        elementValue1.elements.length !== elementValue2.elements.length\n      ) {\n        return false\n      }\n      for (let i = 0; i < elementValue1.elements.length; i++) {\n        if (\n          elementValue1.elements[i].combinator.value !==\n          elementValue2.elements[i].combinator.value\n        ) {\n          if (\n            i !== 0 ||\n            (elementValue1.elements[i].combinator.value || ' ') !==\n              (elementValue2.elements[i].combinator.value || ' ')\n          ) {\n            return false\n          }\n        }\n        if (\n          !this.isElementValuesEqual(\n            elementValue1.elements[i].value,\n            elementValue2.elements[i].value\n          )\n        ) {\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n\n  extendSelector(matches, selectorPath, replacementSelector, isVisible) {\n    //for a set of matches, replace each match with the replacement selector\n\n    let currentSelectorPathIndex = 0\n\n    let currentSelectorPathElementIndex = 0\n    let path = []\n    let matchIndex\n    let selector\n    let firstElement\n    let match\n    let newElements\n\n    for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {\n      match = matches[matchIndex]\n      selector = selectorPath[match.pathIndex]\n      firstElement = new tree.Element(\n        match.initialCombinator,\n        replacementSelector.elements[0].value,\n        replacementSelector.elements[0].index,\n        replacementSelector.elements[0].currentFileInfo\n      )\n\n      if (\n        match.pathIndex > currentSelectorPathIndex &&\n        currentSelectorPathElementIndex > 0\n      ) {\n        path[path.length - 1].elements = path[path.length - 1].elements.concat(\n          selectorPath[currentSelectorPathIndex].elements.slice(\n            currentSelectorPathElementIndex\n          )\n        )\n        currentSelectorPathElementIndex = 0\n        currentSelectorPathIndex++\n      }\n\n      newElements = selector.elements\n        .slice(currentSelectorPathElementIndex, match.index)\n        .concat([firstElement])\n        .concat(replacementSelector.elements.slice(1))\n\n      if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {\n        path[path.length - 1].elements = path[path.length - 1].elements.concat(\n          newElements\n        )\n      } else {\n        path = path.concat(\n          selectorPath.slice(currentSelectorPathIndex, match.pathIndex)\n        )\n\n        path.push(new tree.Selector(newElements))\n      }\n      currentSelectorPathIndex = match.endPathIndex\n      currentSelectorPathElementIndex = match.endPathElementIndex\n      if (\n        currentSelectorPathElementIndex >=\n        selectorPath[currentSelectorPathIndex].elements.length\n      ) {\n        currentSelectorPathElementIndex = 0\n        currentSelectorPathIndex++\n      }\n    }\n\n    if (\n      currentSelectorPathIndex < selectorPath.length &&\n      currentSelectorPathElementIndex > 0\n    ) {\n      path[path.length - 1].elements = path[path.length - 1].elements.concat(\n        selectorPath[currentSelectorPathIndex].elements.slice(\n          currentSelectorPathElementIndex\n        )\n      )\n      currentSelectorPathIndex++\n    }\n\n    path = path.concat(\n      selectorPath.slice(currentSelectorPathIndex, selectorPath.length)\n    )\n    path = path.map(currentValue => {\n      // we can re-use elements here, because the visibility property matters only for selectors\n      const derived = currentValue.createDerived(currentValue.elements)\n      if (isVisible) {\n        derived.ensureVisibility()\n      } else {\n        derived.ensureInvisibility()\n      }\n      return derived\n    })\n    return path\n  }\n\n  visitMedia(mediaNode, visitArgs) {\n    let newAllExtends = mediaNode.allExtends.concat(\n      this.allExtendsStack[this.allExtendsStack.length - 1]\n    )\n    newAllExtends = newAllExtends.concat(\n      this.doExtendChaining(newAllExtends, mediaNode.allExtends)\n    )\n    this.allExtendsStack.push(newAllExtends)\n  }\n\n  visitMediaOut(mediaNode) {\n    const lastIndex = this.allExtendsStack.length - 1\n    this.allExtendsStack.length = lastIndex\n  }\n\n  visitDirective(directiveNode, visitArgs) {\n    let newAllExtends = directiveNode.allExtends.concat(\n      this.allExtendsStack[this.allExtendsStack.length - 1]\n    )\n    newAllExtends = newAllExtends.concat(\n      this.doExtendChaining(newAllExtends, directiveNode.allExtends)\n    )\n    this.allExtendsStack.push(newAllExtends)\n  }\n\n  visitDirectiveOut(directiveNode) {\n    const lastIndex = this.allExtendsStack.length - 1\n    this.allExtendsStack.length = lastIndex\n  }\n}\n\nmodule.exports = ProcessExtendsVisitor\n","const Visitor = require('./visitor')\n\nclass JoinSelectorVisitor {\n  constructor() {\n    this.contexts = [[]]\n    this._visitor = new Visitor(this)\n  }\n\n  run(root) {\n    return this._visitor.visit(root)\n  }\n\n  visitRule(ruleNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitMixinDefinition(mixinDefinitionNode, visitArgs) {\n    visitArgs.visitDeeper = false\n  }\n\n  visitRuleset(rulesetNode, visitArgs) {\n    const context = this.contexts[this.contexts.length - 1]\n    const paths = []\n    let selectors\n\n    this.contexts.push(paths)\n\n    if (!rulesetNode.root) {\n      selectors = rulesetNode.selectors\n      if (selectors) {\n        selectors = selectors.filter(selector => selector.getIsOutput())\n        rulesetNode.selectors = selectors.length\n          ? selectors\n          : (selectors = null)\n        if (selectors) {\n          rulesetNode.joinSelectors(paths, context, selectors)\n        }\n      }\n      if (!selectors) {\n        rulesetNode.rules = null\n      }\n      rulesetNode.paths = paths\n    }\n  }\n\n  visitRulesetOut(rulesetNode) {\n    this.contexts.length = this.contexts.length - 1\n  }\n\n  visitMedia(mediaNode, visitArgs) {\n    const context = this.contexts[this.contexts.length - 1]\n    mediaNode.rules[0].root = context.length === 0 || context[0].multiMedia\n  }\n\n  visitDirective(directiveNode, visitArgs) {\n    const context = this.contexts[this.contexts.length - 1]\n    if (directiveNode.rules && directiveNode.rules.length) {\n      directiveNode.rules[0].root =\n        directiveNode.isRooted || context.length === 0 || null\n    }\n  }\n}\n\nmodule.exports = JoinSelectorVisitor\n","const tree = require('../tree')\nconst Visitor = require('./visitor')\n\nclass CSSVisitorUtils {\n  constructor(context) {\n    this._visitor = new Visitor(this)\n    this._context = context\n  }\n\n  containsSilentNonBlockedChild(bodyRules) {\n    let rule\n    if (bodyRules == null) {\n      return false\n    }\n    for (let r = 0; r < bodyRules.length; r++) {\n      rule = bodyRules[r]\n      if (\n        rule.isSilent &&\n        rule.isSilent(this._context) &&\n        !rule.blocksVisibility()\n      ) {\n        //the directive contains something that was referenced (likely by extend)\n        //therefore it needs to be shown in output too\n        return true\n      }\n    }\n    return false\n  }\n\n  keepOnlyVisibleChilds(owner) {\n    if (owner == null || owner.rules == null) {\n      return\n    }\n\n    owner.rules = owner.rules.filter(thing => thing.isVisible())\n  }\n\n  isEmpty(owner) {\n    if (owner == null || owner.rules == null) {\n      return true\n    }\n    return owner.rules.length === 0\n  }\n\n  hasVisibleSelector(rulesetNode) {\n    if (rulesetNode == null || rulesetNode.paths == null) {\n      return false\n    }\n    return rulesetNode.paths.length > 0\n  }\n\n  resolveVisibility(node, originalRules) {\n    if (!node.blocksVisibility()) {\n      if (\n        this.isEmpty(node) &&\n        !this.containsSilentNonBlockedChild(originalRules)\n      ) {\n        return\n      }\n\n      return node\n    }\n\n    const compiledRulesBody = node.rules[0]\n    this.keepOnlyVisibleChilds(compiledRulesBody)\n\n    if (this.isEmpty(compiledRulesBody)) {\n      return\n    }\n\n    node.ensureVisibility()\n    node.removeVisibilityBlock()\n\n    return node\n  }\n\n  isVisibleRuleset(rulesetNode) {\n    if (rulesetNode.firstRoot) {\n      return true\n    }\n\n    if (this.isEmpty(rulesetNode)) {\n      return false\n    }\n\n    if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {\n      return false\n    }\n\n    return true\n  }\n}\n\nconst ToCSSVisitor = function(context) {\n  this._visitor = new Visitor(this)\n  this._context = context\n  this.utils = new CSSVisitorUtils(context)\n  this._level = 0\n}\n\nToCSSVisitor.prototype = {\n  isReplacing: true,\n  run(root) {\n    return this._visitor.visit(root)\n  },\n\n  visitRule(ruleNode, visitArgs) {\n    if (ruleNode.blocksVisibility()) {\n      return\n    }\n    if (ruleNode.variable) {\n      if (!this._context.simplify) return //We don't need any variables\n      if (this._level > this._context.simplifyLevel) return //Variable is too deep\n      if (\n        this._context.simplifyFilter &&\n        !this._context.simplifyFilter.test(ruleNode.name)\n      )\n        return //Variable didnt pass filter\n    }\n    return ruleNode\n  },\n\n  visitMixinDefinition(mixinNode, visitArgs) {\n    // mixin definitions do not get eval'd - this means they keep state\n    // so we have to clear that state here so it isn't used if toCSS is called twice\n    mixinNode.frames = []\n  },\n\n  visitExtend(extendNode, visitArgs) {},\n\n  visitComment(commentNode, visitArgs) {\n    if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {\n      return\n    }\n    return commentNode\n  },\n\n  visitMedia(mediaNode, visitArgs) {\n    const originalRules = mediaNode.rules[0].rules\n    mediaNode.accept(this._visitor)\n    visitArgs.visitDeeper = false\n\n    return this.utils.resolveVisibility(mediaNode, originalRules)\n  },\n\n  visitImport(importNode, visitArgs) {\n    if (importNode.blocksVisibility()) {\n      return\n    }\n    return importNode\n  },\n\n  visitDirective(directiveNode, visitArgs) {\n    if (directiveNode.rules && directiveNode.rules.length) {\n      return this.visitDirectiveWithBody(directiveNode, visitArgs)\n    } else {\n      return this.visitDirectiveWithoutBody(directiveNode, visitArgs)\n    }\n  },\n\n  visitDirectiveWithBody(directiveNode, visitArgs) {\n    //if there is only one nested ruleset and that one has no path, then it is\n    //just fake ruleset\n    function hasFakeRuleset(directiveNode) {\n      const bodyRules = directiveNode.rules\n      return (\n        bodyRules.length === 1 &&\n        (!bodyRules[0].paths || bodyRules[0].paths.length === 0)\n      )\n    }\n    function getBodyRules(directiveNode) {\n      const nodeRules = directiveNode.rules\n      if (hasFakeRuleset(directiveNode)) {\n        return nodeRules[0].rules\n      }\n\n      return nodeRules\n    }\n    //it is still true that it is only one ruleset in array\n    //this is last such moment\n    //process childs\n    const originalRules = getBodyRules(directiveNode)\n    directiveNode.accept(this._visitor)\n    visitArgs.visitDeeper = false\n\n    if (!this.utils.isEmpty(directiveNode)) {\n      this._mergeRules(directiveNode.rules[0].rules)\n    }\n\n    return this.utils.resolveVisibility(directiveNode, originalRules)\n  },\n\n  visitDirectiveWithoutBody(directiveNode, visitArgs) {\n    if (directiveNode.blocksVisibility()) {\n      return\n    }\n\n    if (directiveNode.name === '@charset') {\n      // Only output the debug info together with subsequent @charset definitions\n      // a comment (or @media statement) before the actual @charset directive would\n      // be considered illegal css as it has to be on the first line\n      if (this.charset) {\n        if (directiveNode.debugInfo) {\n          const comment = new tree.Comment(\n            `/* ${directiveNode.toCSS(this._context).replace(/\\n/g, '')} */\\n`\n          )\n          comment.debugInfo = directiveNode.debugInfo\n          return this._visitor.visit(comment)\n        }\n        return\n      }\n      this.charset = true\n    }\n\n    return directiveNode\n  },\n\n  checkValidNodes(rules, isRoot) {\n    if (!rules) {\n      return\n    }\n\n    for (let i = 0; i < rules.length; i++) {\n      const ruleNode = rules[i]\n      if (isRoot && ruleNode instanceof tree.Rule && !ruleNode.variable) {\n        throw {\n          message:\n            'Properties must be inside selector blocks. They cannot be in the root',\n          index: ruleNode.index,\n          filename:\n            ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename,\n        }\n      }\n      if (ruleNode instanceof tree.Call) {\n        throw {\n          message: `Function '${ruleNode.name}' is undefined`,\n          index: ruleNode.index,\n          filename:\n            ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename,\n        }\n      }\n      if (ruleNode.type && !ruleNode.allowRoot) {\n        throw {\n          message: `${ruleNode.type} node returned by a function is not valid here`,\n          index: ruleNode.index,\n          filename:\n            ruleNode.currentFileInfo && ruleNode.currentFileInfo.filename,\n        }\n      }\n    }\n  },\n  visitRulesetOut(rulesetNode) {\n    this._level--\n  },\n  visitRuleset(rulesetNode, visitArgs) {\n    this._level++\n\n    //at this point rulesets are nested into each other\n    let rule\n\n    const rulesets = []\n\n    this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot)\n\n    if (!rulesetNode.root) {\n      //remove invisible paths\n      this._compileRulesetPaths(rulesetNode)\n\n      // remove rulesets from this ruleset body and compile them separately\n      const nodeRules = rulesetNode.rules\n\n      let nodeRuleCnt = nodeRules ? nodeRules.length : 0\n      for (let i = 0; i < nodeRuleCnt; ) {\n        rule = nodeRules[i]\n        if (rule && rule.rules) {\n          // visit because we are moving them out from being a child\n          rulesets.push(this._visitor.visit(rule))\n          nodeRules.splice(i, 1)\n          nodeRuleCnt--\n          continue\n        }\n        i++\n      }\n      // accept the visitor to remove rules and refactor itself\n      // then we can decide nogw whether we want it or not\n      // compile body\n      if (nodeRuleCnt > 0) {\n        rulesetNode.accept(this._visitor)\n      } else {\n        rulesetNode.rules = null\n      }\n      visitArgs.visitDeeper = false\n    } else {\n      //if (! rulesetNode.root) {\n      rulesetNode.accept(this._visitor)\n      visitArgs.visitDeeper = false\n    }\n\n    if (rulesetNode.rules) {\n      this._mergeRules(rulesetNode.rules)\n      this._removeDuplicateRules(rulesetNode.rules)\n    }\n\n    //now decide whether we keep the ruleset\n    if (this.utils.isVisibleRuleset(rulesetNode)) {\n      rulesetNode.ensureVisibility()\n      rulesets.splice(0, 0, rulesetNode)\n    }\n\n    if (rulesets.length === 1) {\n      return rulesets[0]\n    }\n    return rulesets\n  },\n\n  _compileRulesetPaths(rulesetNode) {\n    if (rulesetNode.paths) {\n      rulesetNode.paths = rulesetNode.paths.filter(p => {\n        let i\n        if (p[0].elements[0].combinator.value === ' ') {\n          p[0].elements[0].combinator = new tree.Combinator('')\n        }\n        for (i = 0; i < p.length; i++) {\n          if (p[i].isVisible() && p[i].getIsOutput()) {\n            return true\n          }\n        }\n        return false\n      })\n    }\n  },\n\n  _removeDuplicateRules(rules) {\n    if (!rules) {\n      return\n    }\n\n    // remove duplicates\n    const ruleCache = {}\n\n    let ruleList\n    let rule\n    let i\n\n    for (i = rules.length - 1; i >= 0; i--) {\n      rule = rules[i]\n      if (rule instanceof tree.Rule) {\n        if (!ruleCache[rule.name]) {\n          ruleCache[rule.name] = rule\n        } else {\n          ruleList = ruleCache[rule.name]\n          if (ruleList instanceof tree.Rule) {\n            ruleList = ruleCache[rule.name] = [\n              ruleCache[rule.name].toCSS(this._context),\n            ]\n          }\n          const ruleCSS = rule.toCSS(this._context)\n          if (ruleList.indexOf(ruleCSS) !== -1) {\n            rules.splice(i, 1)\n          } else {\n            ruleList.push(ruleCSS)\n          }\n        }\n      }\n    }\n  },\n\n  _mergeRules(rules) {\n    if (!rules) {\n      return\n    }\n\n    const groups = {}\n    let parts\n    let rule\n    let key\n\n    for (let i = 0; i < rules.length; i++) {\n      rule = rules[i]\n\n      if (rule instanceof tree.Rule && rule.merge) {\n        key = [rule.name, rule.important ? '!' : ''].join(',')\n\n        if (!groups[key]) {\n          groups[key] = []\n        } else {\n          rules.splice(i--, 1)\n        }\n\n        groups[key].push(rule)\n      }\n    }\n\n    Object.keys(groups).map(k => {\n      function toExpression(values) {\n        return new tree.Expression(values.map(p => p.value))\n      }\n\n      function toValue(values) {\n        return new tree.Value(values.map(p => p))\n      }\n\n      parts = groups[k]\n\n      if (parts.length > 1) {\n        rule = parts[0]\n        const spacedGroups = []\n        let lastSpacedGroup = []\n        parts.map(p => {\n          if (p.merge === '+') {\n            if (lastSpacedGroup.length > 0) {\n              spacedGroups.push(toExpression(lastSpacedGroup))\n            }\n            lastSpacedGroup = []\n          }\n          lastSpacedGroup.push(p)\n        })\n        spacedGroups.push(toExpression(lastSpacedGroup))\n        rule.value = toValue(spacedGroups)\n      }\n    })\n  },\n\n  visitAnonymous(anonymousNode, visitArgs) {\n    if (anonymousNode.blocksVisibility()) {\n      return\n    }\n    anonymousNode.accept(this._visitor)\n    return anonymousNode\n  },\n}\n\nmodule.exports = ToCSSVisitor\n","const visitors = {\n  Visitor: require('./visitor'),\n  ImportVisitor: require('./import-visitor'),\n  MarkVisibleSelectorsVisitor: require('./set-tree-visibility-visitor'),\n  ExtendVisitor: require('./extend-visitor'),\n  JoinSelectorVisitor: require('./join-selector-visitor'),\n  ToCSSVisitor: require('./to-css-visitor'),\n}\n\nmodule.exports = visitors\n","const contexts = require('./contexts')\nconst visitor = require('./visitors')\nconst tree = require('./tree')\n\nmodule.exports = (root, options) => {\n  options = options || {}\n  let evaldRoot\n  let variables = options.variables\n  const evalEnv = new contexts.Eval(options)\n\n  //\n  // Allows setting variables with a hash, so:\n  //\n  //   `{ color: new tree.Color('#f01') }` will become:\n  //\n  //   new tree.Rule('@color',\n  //     new tree.Value([\n  //       new tree.Expression([\n  //         new tree.Color('#f01')\n  //       ])\n  //     ])\n  //   )\n  //\n  if (typeof variables === 'object' && !Array.isArray(variables)) {\n    variables = Object.keys(variables).map(k => {\n      let value = variables[k]\n\n      if (!(value instanceof tree.Value)) {\n        if (!(value instanceof tree.Expression)) {\n          value = new tree.Expression([value])\n        }\n        value = new tree.Value([value])\n      }\n      return new tree.Rule(`@${k}`, value, false, null, 0)\n    })\n    evalEnv.frames = [new tree.Ruleset(null, variables)]\n  }\n\n  const preEvalVisitors = []\n\n  const visitors = [\n    new visitor.JoinSelectorVisitor(),\n    new visitor.MarkVisibleSelectorsVisitor(true),\n    new visitor.ExtendVisitor(),\n    new visitor.ToCSSVisitor({\n      compress: Boolean(options.compress),\n      simplify: Boolean(options.simplify),\n      simplifyLevel: Number(options.simplifyLevel || 1),\n      simplifyFilter: options.simplifyFilter,\n    }),\n  ]\n\n  let i\n\n  if (options.pluginManager) {\n    const pluginVisitors = options.pluginManager.getVisitors()\n    for (i = 0; i < pluginVisitors.length; i++) {\n      const pluginVisitor = pluginVisitors[i]\n      if (pluginVisitor.isPreEvalVisitor) {\n        preEvalVisitors.push(pluginVisitor)\n      } else {\n        if (pluginVisitor.isPreVisitor) {\n          visitors.splice(0, 0, pluginVisitor)\n        } else {\n          visitors.push(pluginVisitor)\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < preEvalVisitors.length; i++) {\n    preEvalVisitors[i].run(root)\n  }\n\n  evaldRoot = root.eval(evalEnv)\n\n  for (i = 0; i < visitors.length; i++) {\n    visitors[i].run(evaldRoot)\n  }\n\n  return evaldRoot\n}\n","const LessError = require('./less-error')\nconst transformTree = require('./transform-tree')\nconst logger = require('./logger')\n\nmodule.exports = SourceMapBuilder => {\n  class ParseTree {\n    constructor(root, imports) {\n      this.root = root\n      this.imports = imports\n    }\n\n    toCSS(options) {\n      let evaldRoot\n      const result = {}\n      let sourceMapBuilder\n      try {\n        evaldRoot = transformTree(this.root, options)\n      } catch (e) {\n        throw new LessError(e, this.imports)\n      }\n\n      try {\n        const compress = Boolean(options.compress)\n        if (compress) {\n          logger.warn(\n            'The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.'\n          )\n        }\n\n        const toCSSOptions = {\n          compress,\n          dumpLineNumbers: options.dumpLineNumbers,\n          strictUnits: Boolean(options.strictUnits),\n          numPrecision: 8,\n        }\n\n        if (options.sourceMap) {\n          sourceMapBuilder = new SourceMapBuilder(options.sourceMap)\n          result.css = sourceMapBuilder.toCSS(\n            evaldRoot,\n            toCSSOptions,\n            this.imports\n          )\n        } else {\n          result.css = evaldRoot.toCSS(toCSSOptions)\n        }\n      } catch (e) {\n        throw new LessError(e, this.imports)\n      }\n\n      if (options.pluginManager) {\n        const postProcessors = options.pluginManager.getPostProcessors()\n        for (let i = 0; i < postProcessors.length; i++) {\n          result.css = postProcessors[i].process(result.css, {\n            sourceMap: sourceMapBuilder,\n            options,\n            imports: this.imports,\n          })\n        }\n      }\n      if (options.sourceMap) {\n        result.map = sourceMapBuilder.getExternalSourceMap()\n      }\n\n      result.imports = []\n      for (const file in this.imports.files) {\n        if (\n          this.imports.files.hasOwnProperty(file) &&\n          file !== this.imports.rootFilename\n        ) {\n          result.imports.push(file)\n        }\n      }\n      return result\n    }\n  }\n\n  return ParseTree\n}\n","// Split the input into chunks.\nmodule.exports = (input, fail) => {\n  const len = input.length\n  let level = 0\n  let parenLevel = 0\n  let lastOpening\n  let lastOpeningParen\n  let lastMultiComment\n  let lastMultiCommentEndBrace\n  const chunks = []\n  let emitFrom = 0\n  let chunkerCurrentIndex\n  let currentChunkStartIndex\n  let cc\n  let cc2\n  let matched\n\n  function emitChunk(force) {\n    const len = chunkerCurrentIndex - emitFrom\n    if ((len < 512 && !force) || !len) {\n      return\n    }\n    chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1))\n    emitFrom = chunkerCurrentIndex + 1\n  }\n\n  for (\n    chunkerCurrentIndex = 0;\n    chunkerCurrentIndex < len;\n    chunkerCurrentIndex++\n  ) {\n    cc = input.charCodeAt(chunkerCurrentIndex)\n    if ((cc >= 97 && cc <= 122) || cc < 34) {\n      // a-z or whitespace\n      continue\n    }\n\n    switch (cc) {\n      case 40: // (\n        parenLevel++\n        lastOpeningParen = chunkerCurrentIndex\n        continue\n      case 41: // )\n        if (--parenLevel < 0) {\n          return fail('missing opening `(`', chunkerCurrentIndex)\n        }\n        continue\n      case 59: // ;\n        if (!parenLevel) {\n          emitChunk()\n        }\n        continue\n      case 123: // {\n        level++\n        lastOpening = chunkerCurrentIndex\n        continue\n      case 125: // }\n        if (--level < 0) {\n          return fail('missing opening `{`', chunkerCurrentIndex)\n        }\n        if (!level && !parenLevel) {\n          emitChunk()\n        }\n        continue\n      case 92: // \\\n        if (chunkerCurrentIndex < len - 1) {\n          chunkerCurrentIndex++\n          continue\n        }\n        return fail('unescaped `\\\\`', chunkerCurrentIndex)\n      case 34:\n      case 39:\n      case 96: // \", ' and `\n        matched = 0\n        currentChunkStartIndex = chunkerCurrentIndex\n        for (\n          chunkerCurrentIndex = chunkerCurrentIndex + 1;\n          chunkerCurrentIndex < len;\n          chunkerCurrentIndex++\n        ) {\n          cc2 = input.charCodeAt(chunkerCurrentIndex)\n          if (cc2 > 96) {\n            continue\n          }\n          if (cc2 == cc) {\n            matched = 1\n            break\n          }\n          if (cc2 == 92) {\n            // \\\n            if (chunkerCurrentIndex == len - 1) {\n              return fail('unescaped `\\\\`', chunkerCurrentIndex)\n            }\n            chunkerCurrentIndex++\n          }\n        }\n        if (matched) {\n          continue\n        }\n        return fail(\n          `unmatched \\`${String.fromCharCode(cc)}\\``,\n          currentChunkStartIndex\n        )\n      case 47: // /, check for comment\n        if (parenLevel || chunkerCurrentIndex == len - 1) {\n          continue\n        }\n        cc2 = input.charCodeAt(chunkerCurrentIndex + 1)\n        if (cc2 == 47) {\n          // //, find lnfeed\n          for (\n            chunkerCurrentIndex = chunkerCurrentIndex + 2;\n            chunkerCurrentIndex < len;\n            chunkerCurrentIndex++\n          ) {\n            cc2 = input.charCodeAt(chunkerCurrentIndex)\n            if (cc2 <= 13 && (cc2 == 10 || cc2 == 13)) {\n              break\n            }\n          }\n        } else if (cc2 == 42) {\n          // /*, find */\n          lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex\n          for (\n            chunkerCurrentIndex = chunkerCurrentIndex + 2;\n            chunkerCurrentIndex < len - 1;\n            chunkerCurrentIndex++\n          ) {\n            cc2 = input.charCodeAt(chunkerCurrentIndex)\n            if (cc2 == 125) {\n              lastMultiCommentEndBrace = chunkerCurrentIndex\n            }\n            if (cc2 != 42) {\n              continue\n            }\n            if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {\n              break\n            }\n          }\n          if (chunkerCurrentIndex == len - 1) {\n            return fail('missing closing `*/`', currentChunkStartIndex)\n          }\n          chunkerCurrentIndex++\n        }\n        continue\n      case 42: // *, check for unmatched */\n        if (\n          chunkerCurrentIndex < len - 1 &&\n          input.charCodeAt(chunkerCurrentIndex + 1) == 47\n        ) {\n          return fail('unmatched `/*`', chunkerCurrentIndex)\n        }\n        continue\n    }\n  }\n\n  if (level !== 0) {\n    if (\n      lastMultiComment > lastOpening &&\n      lastMultiCommentEndBrace > lastMultiComment\n    ) {\n      return fail('missing closing `}` or `*/`', lastOpening)\n    } else {\n      return fail('missing closing `}`', lastOpening)\n    }\n  } else if (parenLevel !== 0) {\n    return fail('missing closing `)`', lastOpeningParen)\n  }\n\n  emitChunk(true)\n  return chunks\n}\n","const chunker = require('./chunker')\n\nmodule.exports = () => {\n  let // LeSS input string\n  input\n\n  let // current chunk\n  j\n\n  const // holds state for backtracking\n  saveStack = []\n\n  let // furthest index the parser has gone to\n  furthest\n\n  let // if this is furthest we got to, this is the probably cause\n  furthestPossibleErrorMessage\n\n  let // chunkified input\n  chunks\n\n  let // current chunk\n  current\n\n  let // index of current chunk, in `input`\n  currentPos\n\n  const parserInput = {}\n  const CHARCODE_SPACE = 32\n  const CHARCODE_TAB = 9\n  const CHARCODE_LF = 10\n  const CHARCODE_CR = 13\n  const CHARCODE_PLUS = 43\n  const CHARCODE_COMMA = 44\n  const CHARCODE_FORWARD_SLASH = 47\n  const CHARCODE_9 = 57\n\n  function skipWhitespace(length) {\n    const oldi = parserInput.i\n    const oldj = j\n    const curr = parserInput.i - currentPos\n    const endIndex = parserInput.i + current.length - curr\n    const mem = (parserInput.i += length)\n    const inp = input\n    let c\n    let nextChar\n    let comment\n\n    for (; parserInput.i < endIndex; parserInput.i++) {\n      c = inp.charCodeAt(parserInput.i)\n\n      if (parserInput.autoCommentAbsorb && c === CHARCODE_FORWARD_SLASH) {\n        nextChar = inp.charAt(parserInput.i + 1)\n        if (nextChar === '/') {\n          comment = { index: parserInput.i, isLineComment: true }\n          let nextNewLine = inp.indexOf('\\n', parserInput.i + 2)\n          if (nextNewLine < 0) {\n            nextNewLine = endIndex\n          }\n          parserInput.i = nextNewLine\n          comment.text = inp.substr(\n            comment.index,\n            parserInput.i - comment.index\n          )\n          parserInput.commentStore.push(comment)\n          continue\n        } else if (nextChar === '*') {\n          const nextStarSlash = inp.indexOf('*/', parserInput.i + 2)\n          if (nextStarSlash >= 0) {\n            comment = {\n              index: parserInput.i,\n              text: inp.substr(\n                parserInput.i,\n                nextStarSlash + 2 - parserInput.i\n              ),\n              isLineComment: false,\n            }\n            parserInput.i += comment.text.length - 1\n            parserInput.commentStore.push(comment)\n            continue\n          }\n        }\n        break\n      }\n\n      if (\n        c !== CHARCODE_SPACE &&\n        c !== CHARCODE_LF &&\n        c !== CHARCODE_TAB &&\n        c !== CHARCODE_CR\n      ) {\n        break\n      }\n    }\n\n    current = current.slice(length + parserInput.i - mem + curr)\n    currentPos = parserInput.i\n\n    if (!current.length) {\n      if (j < chunks.length - 1) {\n        current = chunks[++j]\n        skipWhitespace(0) // skip space at the beginning of a chunk\n        return true // things changed\n      }\n      parserInput.finished = true\n    }\n\n    return oldi !== parserInput.i || oldj !== j\n  }\n\n  parserInput.save = () => {\n    currentPos = parserInput.i\n    saveStack.push({ current, i: parserInput.i, j })\n  }\n  parserInput.restore = possibleErrorMessage => {\n    if (\n      parserInput.i > furthest ||\n      (parserInput.i === furthest &&\n        possibleErrorMessage &&\n        !furthestPossibleErrorMessage)\n    ) {\n      furthest = parserInput.i\n      furthestPossibleErrorMessage = possibleErrorMessage\n    }\n    const state = saveStack.pop()\n    current = state.current\n    currentPos = parserInput.i = state.i\n    j = state.j\n  }\n  parserInput.forget = () => {\n    saveStack.pop()\n  }\n  parserInput.isWhitespace = offset => {\n    const pos = parserInput.i + (offset || 0)\n    const code = input.charCodeAt(pos)\n    return (\n      code === CHARCODE_SPACE ||\n      code === CHARCODE_CR ||\n      code === CHARCODE_TAB ||\n      code === CHARCODE_LF\n    )\n  }\n\n  // Specialization of $(tok)\n  parserInput.$re = tok => {\n    if (parserInput.i > currentPos) {\n      current = current.slice(parserInput.i - currentPos)\n      currentPos = parserInput.i\n    }\n\n    const m = tok.exec(current)\n    if (!m) {\n      return null\n    }\n\n    skipWhitespace(m[0].length)\n    if (typeof m === 'string') {\n      return m\n    }\n\n    return m.length === 1 ? m[0] : m\n  }\n\n  parserInput.$char = tok => {\n    if (input.charAt(parserInput.i) !== tok) {\n      return null\n    }\n    skipWhitespace(1)\n    return tok\n  }\n\n  parserInput.$str = tok => {\n    const tokLength = tok.length\n\n    // https://jsperf.com/string-startswith/21\n    for (let i = 0; i < tokLength; i++) {\n      if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n        return null\n      }\n    }\n\n    skipWhitespace(tokLength)\n    return tok\n  }\n\n  parserInput.$quoted = () => {\n    const startChar = input.charAt(parserInput.i)\n    if (startChar !== \"'\" && startChar !== '\"') {\n      return\n    }\n    const length = input.length\n    const currentPosition = parserInput.i\n\n    for (let i = 1; i + currentPosition < length; i++) {\n      const nextChar = input.charAt(i + currentPosition)\n      switch (nextChar) {\n        case '\\\\':\n          i++\n          continue\n        case '\\r':\n        case '\\n':\n          break\n        case startChar:\n          const str = input.substr(currentPosition, i + 1)\n          skipWhitespace(i + 1)\n          return str\n        default:\n      }\n    }\n    return null\n  }\n\n  parserInput.autoCommentAbsorb = true\n  parserInput.commentStore = []\n  parserInput.finished = false\n\n  // Same as $(), but don't change the state of the parser,\n  // just return the match.\n  parserInput.peek = tok => {\n    if (typeof tok === 'string') {\n      // https://jsperf.com/string-startswith/21\n      for (let i = 0; i < tok.length; i++) {\n        if (input.charAt(parserInput.i + i) !== tok.charAt(i)) {\n          return false\n        }\n      }\n      return true\n    } else {\n      return tok.test(current)\n    }\n  }\n\n  // Specialization of peek()\n  // TODO remove or change some currentChar calls to peekChar\n  parserInput.peekChar = tok => input.charAt(parserInput.i) === tok\n\n  parserInput.currentChar = () => input.charAt(parserInput.i)\n\n  parserInput.getInput = () => input\n\n  parserInput.peekNotNumeric = () => {\n    const c = input.charCodeAt(parserInput.i)\n    //Is the first char of the dimension 0-9, '.', '+' or '-'\n    return (\n      c > CHARCODE_9 ||\n      c < CHARCODE_PLUS ||\n      c === CHARCODE_FORWARD_SLASH ||\n      c === CHARCODE_COMMA\n    )\n  }\n\n  parserInput.start = (str, chunkInput, failFunction) => {\n    input = str\n    parserInput.i = j = currentPos = furthest = 0\n\n    // chunking apparently makes things quicker (but my tests indicate\n    // it might actually make things slower in node at least)\n    // and it is a non-perfect parse - it can't recognise\n    // unquoted urls, meaning it can't distinguish comments\n    // meaning comments with quotes or {}() in them get 'counted'\n    // and then lead to parse errors.\n    // In addition if the chunking chunks in the wrong place we might\n    // not be able to parse a parser statement in one go\n    // this is officially deprecated but can be switched on via an option\n    // in the case it causes too much performance issues.\n    if (chunkInput) {\n      chunks = chunker(str, failFunction)\n    } else {\n      chunks = [str]\n    }\n\n    current = chunks[0]\n\n    skipWhitespace(0)\n  }\n\n  parserInput.end = () => {\n    let message\n    const isFinished = parserInput.i >= input.length\n\n    if (parserInput.i < furthest) {\n      message = furthestPossibleErrorMessage\n      parserInput.i = furthest\n    }\n    return {\n      isFinished,\n      furthest: parserInput.i,\n      furthestPossibleErrorMessage: message,\n      furthestReachedEnd: parserInput.i >= input.length - 1,\n      furthestChar: input[parserInput.i],\n    }\n  }\n\n  return parserInput\n}\n","const LessError = require('../less-error')\nconst tree = require('../tree')\nconst visitors = require('../visitors')\nconst getParserInput = require('./parser-input')\nconst utils = require('../utils')\n\n//\n// less.js - parser\n//\n//    A relatively straight-forward predictive parser.\n//    There is no tokenization/lexing stage, the input is parsed\n//    in one sweep.\n//\n//    To make the parser fast enough to run in the browser, several\n//    optimization had to be made:\n//\n//    - Matching and slicing on a huge input is often cause of slowdowns.\n//      The solution is to chunkify the input into smaller strings.\n//      The chunks are stored in the `chunks` var,\n//      `j` holds the current chunk index, and `currentPos` holds\n//      the index of the current chunk in relation to `input`.\n//      This gives us an almost 4x speed-up.\n//\n//    - In many cases, we don't need to match individual tokens;\n//      for example, if a value doesn't hold any variables, operations\n//      or dynamic references, the parser can effectively 'skip' it,\n//      treating it as a literal.\n//      An example would be '1px solid #000' - which evaluates to itself,\n//      we don't need to know what the individual components are.\n//      The drawback, of course is that you don't get the benefits of\n//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,\n//      and a smaller speed-up in the code-gen.\n//\n//\n//    Token matching is done with the `$` function, which either takes\n//    a terminal string or regexp, or a non-terminal function to call.\n//    It also takes care of moving all the indices forwards.\n//`\n//\nconst Parser = function Parser(context, imports, fileInfo) {\n  let parsers\n  const parserInput = getParserInput()\n\n  function error(msg, type) {\n    throw new LessError(\n      {\n        index: parserInput.i,\n        filename: fileInfo.filename,\n        type: type || 'Syntax',\n        message: msg,\n      },\n      imports\n    )\n  }\n\n  function expect(arg, msg, index) {\n    // some older browsers return typeof 'function' for RegExp\n    const result =\n      arg instanceof Function ? arg.call(parsers) : parserInput.$re(arg)\n    if (result) {\n      return result\n    }\n    error(\n      msg ||\n        (typeof arg === 'string'\n          ? `expected '${arg}' got '${parserInput.currentChar()}'`\n          : 'unexpected token')\n    )\n  }\n\n  // Specialization of expect()\n  function expectChar(arg, msg) {\n    if (parserInput.$char(arg)) {\n      return arg\n    }\n    error(msg || `expected '${arg}' got '${parserInput.currentChar()}'`)\n  }\n\n  function getDebugInfo(index) {\n    const filename = fileInfo.filename\n\n    return {\n      lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,\n      fileName: filename,\n    }\n  }\n\n  //\n  // The Parser\n  //\n  return {\n    //\n    // Parse an input string into an abstract syntax tree,\n    // @param str A string containing 'less' markup\n    // @param callback call `callback` when done.\n    // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply\n    //\n    parse(str, callback, additionalData) {\n      let root\n      let error = null\n      let globalVars\n      let modifyVars\n      let ignored\n      let preText = ''\n\n      globalVars =\n        additionalData && additionalData.globalVars\n          ? `${Parser.serializeVars(additionalData.globalVars)}\\n`\n          : ''\n      modifyVars =\n        additionalData && additionalData.modifyVars\n          ? `\\n${Parser.serializeVars(additionalData.modifyVars)}`\n          : ''\n\n      if (context.pluginManager) {\n        const preProcessors = context.pluginManager.getPreProcessors()\n        for (let i = 0; i < preProcessors.length; i++) {\n          str = preProcessors[i].process(str, { context, imports, fileInfo })\n        }\n      }\n\n      if (globalVars || (additionalData && additionalData.banner)) {\n        preText =\n          (additionalData && additionalData.banner\n            ? additionalData.banner\n            : '') + globalVars\n        ignored = imports.contentsIgnoredChars\n        ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0\n        ignored[fileInfo.filename] += preText.length\n      }\n\n      str = str.replace(/\\r\\n?/g, '\\n')\n      // Remove potential UTF Byte Order Mark\n      str = preText + str.replace(/^\\uFEFF/, '') + modifyVars\n      imports.contents[fileInfo.filename] = str\n\n      // Start with the primary rule.\n      // The whole syntax tree is held under a Ruleset node,\n      // with the `root` property set to true, so no `{}` are\n      // output. The callback is called when the input is parsed.\n      try {\n        parserInput.start(str, context.chunkInput, function fail(msg, index) {\n          throw new LessError(\n            {\n              index,\n              type: 'Parse',\n              message: msg,\n              filename: fileInfo.filename,\n            },\n            imports\n          )\n        })\n\n        root = new tree.Ruleset(null, this.parsers.primary())\n        root.root = true\n        root.firstRoot = true\n      } catch (e) {\n        return callback(new LessError(e, imports, fileInfo.filename))\n      }\n\n      // If `i` is smaller than the `input.length - 1`,\n      // it means the parser wasn't able to parse the whole\n      // string, so we've got a parsing error.\n      //\n      // We try to extract a \\n delimited string,\n      // showing the line where the parse error occurred.\n      // We split it up into two parts (the part which parsed,\n      // and the part which didn't), so we can color them differently.\n      const endInfo = parserInput.end()\n      if (!endInfo.isFinished) {\n        let message = endInfo.furthestPossibleErrorMessage\n\n        if (!message) {\n          message = 'Unrecognised input'\n          if (endInfo.furthestChar === '}') {\n            message += \". Possibly missing opening '{'\"\n          } else if (endInfo.furthestChar === ')') {\n            message += \". Possibly missing opening '('\"\n          } else if (endInfo.furthestReachedEnd) {\n            message += '. Possibly missing something'\n          }\n        }\n\n        error = new LessError(\n          {\n            type: 'Parse',\n            message,\n            index: endInfo.furthest,\n            filename: fileInfo.filename,\n          },\n          imports\n        )\n      }\n\n      const finish = e => {\n        e = error || e || imports.error\n\n        if (e) {\n          if (!(e instanceof LessError)) {\n            e = new LessError(e, imports, fileInfo.filename)\n          }\n\n          return callback(e)\n        } else {\n          return callback(null, root)\n        }\n      }\n\n      if (context.processImports !== false) {\n        new visitors.ImportVisitor(imports, finish).run(root)\n      } else {\n        return finish()\n      }\n    },\n\n    //\n    // Here in, the parsing rules/functions\n    //\n    // The basic structure of the syntax tree generated is as follows:\n    //\n    //   Ruleset ->  Rule -> Value -> Expression -> Entity\n    //\n    // Here's some Less code:\n    //\n    //    .class {\n    //      color: #fff;\n    //      border: 1px solid #000;\n    //      width: @w + 4px;\n    //      > .child {...}\n    //    }\n    //\n    // And here's what the parse tree might look like:\n    //\n    //     Ruleset (Selector '.class', [\n    //         Rule (\"color\",  Value ([Expression [Color #fff]]))\n    //         Rule (\"border\", Value ([Expression [Dimension 1px][Keyword \"solid\"][Color #000]]))\n    //         Rule (\"width\",  Value ([Expression [Operation \" + \" [Variable \"@w\"][Dimension 4px]]]))\n    //         Ruleset (Selector [Element '>', '.child'], [...])\n    //     ])\n    //\n    //  In general, most rules will try to parse a token with the `$re()` function, and if the return\n    //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check\n    //  first, before parsing, that's when we use `peek()`.\n    //\n    parsers: (parsers = {\n      //\n      // The `primary` rule is the *entry* and *exit* point of the parser.\n      // The rules here can appear at any level of the parse tree.\n      //\n      // The recursive nature of the grammar is an interplay between the `block`\n      // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,\n      // as represented by this simplified grammar:\n      //\n      //     primary    (ruleset | rule)+\n      //     ruleset    selector+ block\n      //     block      '{' primary '}'\n      //\n      // Only at one point is the primary rule not called from the\n      // block rule: at the root level.\n      //\n      primary() {\n        const mixin = this.mixin\n        let root = []\n        let node\n\n        while (true) {\n          while (true) {\n            node = this.comment()\n            if (!node) {\n              break\n            }\n            root.push(node)\n          }\n          // always process comments before deciding if finished\n          if (parserInput.finished) {\n            break\n          }\n          if (parserInput.peek('}')) {\n            break\n          }\n\n          node = this.extendRule()\n          if (node) {\n            root = root.concat(node)\n            continue\n          }\n\n          node =\n            mixin.definition() ||\n            this.rule() ||\n            this.ruleset() ||\n            mixin.call() ||\n            this.rulesetCall() ||\n            this.entities.call() ||\n            this.directive()\n          if (node) {\n            root.push(node)\n          } else {\n            let foundSemiColon = false\n            while (parserInput.$char(';')) {\n              foundSemiColon = true\n            }\n            if (!foundSemiColon) {\n              break\n            }\n          }\n        }\n\n        return root\n      },\n\n      // comments are collected by the main parsing mechanism and then assigned to nodes\n      // where the current structure allows it\n      comment() {\n        if (parserInput.commentStore.length) {\n          const comment = parserInput.commentStore.shift()\n          return new tree.Comment(\n            comment.text,\n            comment.isLineComment,\n            comment.index,\n            fileInfo\n          )\n        }\n      },\n\n      //\n      // Entities are tokens which can be found inside an Expression\n      //\n      entities: {\n        //\n        // A string, which supports escaping \" and '\n        //\n        //     \"milky way\" 'he\\'s the one!'\n        //\n        quoted() {\n          let str\n          const index = parserInput.i\n          let isEscaped = false\n\n          parserInput.save()\n          if (parserInput.$char('~')) {\n            isEscaped = true\n          }\n          str = parserInput.$quoted()\n          if (!str) {\n            parserInput.restore()\n            return\n          }\n          parserInput.forget()\n\n          return new tree.Quoted(\n            str.charAt(0),\n            str.substr(1, str.length - 2),\n            isEscaped,\n            index,\n            fileInfo\n          )\n        },\n\n        //\n        // A catch-all word, such as:\n        //\n        //     black border-collapse\n        //\n        keyword() {\n          const k =\n            parserInput.$char('%') ||\n            parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]*/)\n          if (k) {\n            return tree.Color.fromKeyword(k) || new tree.Keyword(k)\n          }\n        },\n\n        //\n        // A function call\n        //\n        //     rgb(255, 0, 255)\n        //\n        // We also try to catch IE's `alpha()`, but let the `alpha` parser\n        // deal with the details.\n        //\n        // The arguments are parsed with the `entities.arguments` parser.\n        //\n        call() {\n          let name\n          let nameLC\n          let args\n          let alpha\n          const index = parserInput.i\n\n          // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n          if (parserInput.peek(/^url\\(/i)) {\n            return\n          }\n\n          parserInput.save()\n\n          name = parserInput.$re(/^([\\w-]+|%|progid:[\\w\\.]+)\\(/)\n          if (!name) {\n            parserInput.forget()\n            return\n          }\n\n          name = name[1]\n          nameLC = name.toLowerCase()\n\n          if (nameLC === 'alpha') {\n            alpha = parsers.alpha()\n            if (alpha) {\n              parserInput.forget()\n              return alpha\n            }\n          }\n\n          args = this.arguments()\n\n          if (!parserInput.$char(')')) {\n            parserInput.restore(\"Could not parse call arguments or missing ')'\")\n            return\n          }\n\n          parserInput.forget()\n          return new tree.Call(name, args, index, fileInfo)\n        },\n        arguments() {\n          const argsSemiColon = []\n          const argsComma = []\n          let expressions = []\n          let isSemiColonSeparated\n          let value\n          let arg\n\n          parserInput.save()\n\n          while (true) {\n            arg =\n              parsers.detachedRuleset() ||\n              this.assignment() ||\n              parsers.expression()\n\n            if (!arg) {\n              break\n            }\n\n            value = arg\n\n            if (arg.value && arg.value.length == 1) {\n              value = arg.value[0]\n            }\n\n            if (value) {\n              expressions.push(value)\n            }\n\n            argsComma.push(value)\n\n            if (parserInput.$char(',')) {\n              continue\n            }\n\n            if (parserInput.$char(';') || isSemiColonSeparated) {\n              isSemiColonSeparated = true\n\n              if (expressions.length > 1) {\n                value = new tree.Value(expressions)\n              }\n              argsSemiColon.push(value)\n\n              expressions = []\n            }\n          }\n\n          parserInput.forget()\n          return isSemiColonSeparated ? argsSemiColon : argsComma\n        },\n        literal() {\n          return (\n            this.dimension() ||\n            this.color() ||\n            this.quoted() ||\n            this.unicodeDescriptor()\n          )\n        },\n\n        // Assignments are argument entities for calls.\n        // They are present in ie filter properties as shown below.\n        //\n        //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )\n        //\n\n        assignment() {\n          let key\n          let value\n          parserInput.save()\n          key = parserInput.$re(/^\\w+(?=\\s?=)/i)\n          if (!key) {\n            parserInput.restore()\n            return\n          }\n          if (!parserInput.$char('=')) {\n            parserInput.restore()\n            return\n          }\n          value = parsers.entity()\n          if (value) {\n            parserInput.forget()\n            return new tree.Assignment(key, value)\n          } else {\n            parserInput.restore()\n          }\n        },\n\n        //\n        // Parse url() tokens\n        //\n        // We use a specific rule for urls, because they don't really behave like\n        // standard function calls. The difference is that the argument doesn't have\n        // to be enclosed within a string, so it can't be parsed as an Expression.\n        //\n        url() {\n          let value\n          const index = parserInput.i\n\n          parserInput.autoCommentAbsorb = false\n\n          if (!parserInput.$str('url(')) {\n            parserInput.autoCommentAbsorb = true\n            return\n          }\n\n          value =\n            this.quoted() ||\n            this.variable() ||\n            parserInput.$re(/^(?:(?:\\\\[\\(\\)'\"])|[^\\(\\)'\"])+/) ||\n            ''\n\n          parserInput.autoCommentAbsorb = true\n\n          expectChar(')')\n\n          return new tree.URL(\n            value.value != null || value instanceof tree.Variable\n              ? value\n              : new tree.Anonymous(value),\n            index,\n            fileInfo\n          )\n        },\n\n        //\n        // A Variable entity, such as `@fink`, in\n        //\n        //     width: @fink + 2px\n        //\n        // We use a different parser for variable definitions,\n        // see `parsers.variable`.\n        //\n        variable() {\n          let name\n          const index = parserInput.i\n\n          if (\n            parserInput.currentChar() === '@' &&\n            (name = parserInput.$re(/^@@?[\\w-]+/))\n          ) {\n            return new tree.Variable(name, index, fileInfo)\n          }\n        },\n\n        // A variable entity using the protective {} e.g. @{var}\n        variableCurly() {\n          let curly\n          const index = parserInput.i\n\n          if (\n            parserInput.currentChar() === '@' &&\n            (curly = parserInput.$re(/^@\\{([\\w-]+)\\}/))\n          ) {\n            return new tree.Variable(`@${curly[1]}`, index, fileInfo)\n          }\n        },\n\n        //\n        // A Hexadecimal color\n        //\n        //     #4F3C2F\n        //\n        // `rgb` and `hsl` colors are parsed through the `entities.call` parser.\n        //\n        color() {\n          let rgb\n\n          if (\n            parserInput.currentChar() === '#' &&\n            (rgb = parserInput.$re(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})/))\n          ) {\n            // strip colons, brackets, whitespaces and other characters that should not\n            // definitely be part of color string\n            let colorCandidateString = rgb.input.match(/^#([\\w]+).*/)\n            colorCandidateString = colorCandidateString[1]\n            if (!colorCandidateString.match(/^[A-Fa-f0-9]+$/)) {\n              // verify if candidate consists only of allowed HEX characters\n              error('Invalid HEX color code')\n            }\n            return new tree.Color(rgb[1], undefined, `#${colorCandidateString}`)\n          }\n        },\n\n        colorKeyword() {\n          parserInput.save()\n          const autoCommentAbsorb = parserInput.autoCommentAbsorb\n          parserInput.autoCommentAbsorb = false\n          const k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/)\n          parserInput.autoCommentAbsorb = autoCommentAbsorb\n          if (!k) {\n            parserInput.forget()\n            return\n          }\n          parserInput.restore()\n          const color = tree.Color.fromKeyword(k)\n          if (color) {\n            parserInput.$str(k)\n            return color\n          }\n        },\n\n        //\n        // A Dimension, that is, a number and a unit\n        //\n        //     0.5em 95%\n        //\n        dimension() {\n          if (parserInput.peekNotNumeric()) {\n            return\n          }\n\n          const value = parserInput.$re(/^([+-]?\\d*\\.?\\d+)(%|[a-z_]+)?/i)\n          if (value) {\n            return new tree.Dimension(value[1], value[2])\n          }\n        },\n\n        //\n        // A unicode descriptor, as is used in unicode-range\n        //\n        // U+0??  or U+00A1-00A9\n        //\n        unicodeDescriptor() {\n          let ud\n\n          ud = parserInput.$re(/^U\\+[0-9a-fA-F?]+(\\-[0-9a-fA-F?]+)?/)\n          if (ud) {\n            return new tree.UnicodeDescriptor(ud[0])\n          }\n        },\n\n        //\n        // JavaScript code to be evaluated\n        //\n        //     `window.location.href`\n        //\n        javascript() {\n          let js\n          const index = parserInput.i\n\n          parserInput.save()\n\n          const escape = parserInput.$char('~')\n          const jsQuote = parserInput.$char('`')\n\n          if (!jsQuote) {\n            parserInput.restore()\n            return\n          }\n\n          js = parserInput.$re(/^[^`]*`/)\n          if (js) {\n            parserInput.forget()\n            return new tree.JavaScript(\n              js.substr(0, js.length - 1),\n              Boolean(escape),\n              index,\n              fileInfo\n            )\n          }\n          parserInput.restore('invalid javascript definition')\n        },\n      },\n\n      //\n      // The variable part of a variable definition. Used in the `rule` parser\n      //\n      //     @fink:\n      //\n      variable() {\n        let name\n\n        if (\n          parserInput.currentChar() === '@' &&\n          (name = parserInput.$re(/^(@[\\w-]+)\\s*:/))\n        ) {\n          return name[1]\n        }\n      },\n\n      //\n      // The variable part of a variable definition. Used in the `rule` parser\n      //\n      //     @fink();\n      //\n      rulesetCall() {\n        let name\n\n        if (\n          parserInput.currentChar() === '@' &&\n          (name = parserInput.$re(/^(@[\\w-]+)\\(\\s*\\)\\s*;/))\n        ) {\n          return new tree.RulesetCall(name[1])\n        }\n      },\n\n      //\n      // extend syntax - used to extend selectors\n      //\n      extend(isRule) {\n        let elements\n        let e\n        const index = parserInput.i\n        let option\n        let extendList\n        let extend\n\n        if (!parserInput.$str(isRule ? '&:extend(' : ':extend(')) {\n          return\n        }\n\n        do {\n          option = null\n          elements = null\n          while (!(option = parserInput.$re(/^(all)(?=\\s*(\\)|,))/))) {\n            e = this.element()\n            if (!e) {\n              break\n            }\n            if (elements) {\n              elements.push(e)\n            } else {\n              elements = [e]\n            }\n          }\n\n          option = option && option[1]\n          if (!elements) {\n            error('Missing target selector for :extend().')\n          }\n          extend = new tree.Extend(\n            new tree.Selector(elements),\n            option,\n            index,\n            fileInfo\n          )\n          if (extendList) {\n            extendList.push(extend)\n          } else {\n            extendList = [extend]\n          }\n        } while (parserInput.$char(','))\n\n        expect(/^\\)/)\n\n        if (isRule) {\n          expect(/^;/)\n        }\n\n        return extendList\n      },\n\n      //\n      // extendRule - used in a rule to extend all the parent selectors\n      //\n      extendRule() {\n        return this.extend(true)\n      },\n\n      //\n      // Mixins\n      //\n      mixin: {\n        //\n        // A Mixin call, with an optional argument list\n        //\n        //     #mixins > .square(#fff);\n        //     .rounded(4px, black);\n        //     .button;\n        //\n        // The `while` loop is there because mixins can be\n        // namespaced, but we only support the child and descendant\n        // selector for now.\n        //\n        call() {\n          const s = parserInput.currentChar()\n          let important = false\n          const index = parserInput.i\n          let elemIndex\n          let elements\n          let elem\n          let e\n          let c\n          let args\n\n          if (s !== '.' && s !== '#') {\n            return\n          }\n\n          parserInput.save() // stop us absorbing part of an invalid selector\n\n          while (true) {\n            elemIndex = parserInput.i\n            e = parserInput.$re(\n              /^[#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/\n            )\n            if (!e) {\n              break\n            }\n            elem = new tree.Element(c, e, elemIndex, fileInfo)\n            if (elements) {\n              elements.push(elem)\n            } else {\n              elements = [elem]\n            }\n            c = parserInput.$char('>')\n          }\n\n          if (elements) {\n            if (parserInput.$char('(')) {\n              args = this.args(true).args\n              expectChar(')')\n            }\n\n            if (parsers.important()) {\n              important = true\n            }\n\n            if (parsers.end()) {\n              parserInput.forget()\n              return new tree.mixin.Call(\n                elements,\n                args,\n                index,\n                fileInfo,\n                important\n              )\n            }\n          }\n\n          parserInput.restore()\n        },\n        args(isCall) {\n          const entities = parsers.entities\n          const returner = { args: null, variadic: false }\n          let expressions = []\n          const argsSemiColon = []\n          const argsComma = []\n          let isSemiColonSeparated\n          let expressionContainsNamed\n          let name\n          let nameLoop\n          let value\n          let arg\n          let expand\n\n          parserInput.save()\n\n          while (true) {\n            if (isCall) {\n              arg = parsers.detachedRuleset() || parsers.expression()\n            } else {\n              parserInput.commentStore.length = 0\n              if (parserInput.$str('...')) {\n                returner.variadic = true\n                if (parserInput.$char(';') && !isSemiColonSeparated) {\n                  isSemiColonSeparated = true\n                }\n                ;(isSemiColonSeparated ? argsSemiColon : argsComma).push({\n                  variadic: true,\n                })\n                break\n              }\n              arg =\n                entities.variable() || entities.literal() || entities.keyword()\n            }\n\n            if (!arg) {\n              break\n            }\n\n            nameLoop = null\n            if (arg.throwAwayComments) {\n              arg.throwAwayComments()\n            }\n            value = arg\n            let val = null\n\n            if (isCall) {\n              // Variable\n              if (arg.value && arg.value.length == 1) {\n                val = arg.value[0]\n              }\n            } else {\n              val = arg\n            }\n\n            if (val && val instanceof tree.Variable) {\n              if (parserInput.$char(':')) {\n                if (expressions.length > 0) {\n                  if (isSemiColonSeparated) {\n                    error('Cannot mix ; and , as delimiter types')\n                  }\n                  expressionContainsNamed = true\n                }\n\n                value = parsers.detachedRuleset() || parsers.expression()\n\n                if (!value) {\n                  if (isCall) {\n                    error('could not understand value for named argument')\n                  } else {\n                    parserInput.restore()\n                    returner.args = []\n                    return returner\n                  }\n                }\n                nameLoop = name = val.name\n              } else if (parserInput.$str('...')) {\n                if (!isCall) {\n                  returner.variadic = true\n                  if (parserInput.$char(';') && !isSemiColonSeparated) {\n                    isSemiColonSeparated = true\n                  }\n                  ;(isSemiColonSeparated ? argsSemiColon : argsComma).push({\n                    name: arg.name,\n                    variadic: true,\n                  })\n                  break\n                } else {\n                  expand = true\n                }\n              } else if (!isCall) {\n                name = nameLoop = val.name\n                value = null\n              }\n            }\n\n            if (value) {\n              expressions.push(value)\n            }\n\n            argsComma.push({ name: nameLoop, value, expand })\n\n            if (parserInput.$char(',')) {\n              continue\n            }\n\n            if (parserInput.$char(';') || isSemiColonSeparated) {\n              if (expressionContainsNamed) {\n                error('Cannot mix ; and , as delimiter types')\n              }\n\n              isSemiColonSeparated = true\n\n              if (expressions.length > 1) {\n                value = new tree.Value(expressions)\n              }\n              argsSemiColon.push({ name, value, expand })\n\n              name = null\n              expressions = []\n              expressionContainsNamed = false\n            }\n          }\n\n          parserInput.forget()\n          returner.args = isSemiColonSeparated ? argsSemiColon : argsComma\n          return returner\n        },\n        //\n        // A Mixin definition, with a list of parameters\n        //\n        //     .rounded (@radius: 2px, @color) {\n        //        ...\n        //     }\n        //\n        // Until we have a finer grained state-machine, we have to\n        // do a look-ahead, to make sure we don't have a mixin call.\n        // See the `rule` function for more information.\n        //\n        // We start by matching `.rounded (`, and then proceed on to\n        // the argument list, which has optional default values.\n        // We store the parameters in `params`, with a `value` key,\n        // if there is a value, such as in the case of `@radius`.\n        //\n        // Once we've got our params list, and a closing `)`, we parse\n        // the `{...}` block.\n        //\n        definition() {\n          let name\n          let params = []\n          let match\n          let ruleset\n          let cond\n          let variadic = false\n          if (\n            (parserInput.currentChar() !== '.' &&\n              parserInput.currentChar() !== '#') ||\n            parserInput.peek(/^[^{]*\\}/)\n          ) {\n            return\n          }\n\n          parserInput.save()\n\n          match = parserInput.$re(\n            /^([#.](?:[\\w-]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\\s*\\(/\n          )\n          if (match) {\n            name = match[1]\n\n            const argInfo = this.args(false)\n            params = argInfo.args\n            variadic = argInfo.variadic\n\n            // .mixincall(\"@{a}\");\n            // looks a bit like a mixin definition..\n            // also\n            // .mixincall(@a: {rule: set;});\n            // so we have to be nice and restore\n            if (!parserInput.$char(')')) {\n              parserInput.restore(\"Missing closing ')'\")\n              return\n            }\n\n            parserInput.commentStore.length = 0\n\n            if (parserInput.$str('when')) {\n              // Guard\n              cond = expect(parsers.conditions, 'expected condition')\n            }\n\n            ruleset = parsers.block()\n\n            if (ruleset) {\n              parserInput.forget()\n              return new tree.mixin.Definition(\n                name,\n                params,\n                ruleset,\n                cond,\n                variadic\n              )\n            } else {\n              parserInput.restore()\n            }\n          } else {\n            parserInput.forget()\n          }\n        },\n      },\n\n      //\n      // Entities are the smallest recognized token,\n      // and can be found inside a rule's value.\n      //\n      entity() {\n        const entities = this.entities\n\n        return (\n          this.comment() ||\n          entities.literal() ||\n          entities.variable() ||\n          entities.url() ||\n          entities.call() ||\n          entities.keyword() ||\n          entities.javascript()\n        )\n      },\n\n      //\n      // A Rule terminator. Note that we use `peek()` to check for '}',\n      // because the `block` rule will be expecting it, but we still need to make sure\n      // it's there, if ';' was omitted.\n      //\n      end() {\n        return parserInput.$char(';') || parserInput.peek('}')\n      },\n\n      //\n      // IE's alpha function\n      //\n      //     alpha(opacity=88)\n      //\n      alpha() {\n        let value\n\n        // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18\n        if (!parserInput.$re(/^opacity=/i)) {\n          return\n        }\n        value = parserInput.$re(/^\\d+/)\n        if (!value) {\n          value = expect(this.entities.variable, 'Could not parse alpha')\n        }\n        expectChar(')')\n        return new tree.Alpha(value)\n      },\n\n      //\n      // A Selector Element\n      //\n      //     div\n      //     + h1\n      //     #socks\n      //     input[type=\"text\"]\n      //\n      // Elements are the building blocks for Selectors,\n      // they are made out of a `Combinator` (see combinator rule),\n      // and an element name, such as a tag a class, or `*`.\n      //\n      element() {\n        let e\n        let c\n        let v\n        const index = parserInput.i\n\n        c = this.combinator()\n\n        e =\n          parserInput.$re(/^(?:\\d+\\.\\d+|\\d+)%/) ||\n          parserInput.$re(\n            /^(?:[.#]?|:*)(?:[\\w-]|[^\\x00-\\x9f]|\\\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/\n          ) ||\n          parserInput.$char('*') ||\n          parserInput.$char('&') ||\n          this.attribute() ||\n          parserInput.$re(/^\\([^&()@]+\\)/) ||\n          parserInput.$re(/^[\\.#:](?=@)/) ||\n          this.entities.variableCurly()\n\n        if (!e) {\n          parserInput.save()\n          if (parserInput.$char('(')) {\n            if ((v = this.selector()) && parserInput.$char(')')) {\n              e = new tree.Paren(v)\n              parserInput.forget()\n            } else {\n              parserInput.restore(\"Missing closing ')'\")\n            }\n          } else {\n            parserInput.forget()\n          }\n        }\n\n        if (e) {\n          return new tree.Element(c, e, index, fileInfo)\n        }\n      },\n\n      //\n      // Combinators combine elements together, in a Selector.\n      //\n      // Because our parser isn't white-space sensitive, special care\n      // has to be taken, when parsing the descendant combinator, ` `,\n      // as it's an empty space. We have to check the previous character\n      // in the input, to see if it's a ` ` character. More info on how\n      // we deal with this in *combinator.js*.\n      //\n      combinator() {\n        let c = parserInput.currentChar()\n\n        if (c === '/') {\n          parserInput.save()\n          const slashedCombinator = parserInput.$re(/^\\/[a-z]+\\//i)\n          if (slashedCombinator) {\n            parserInput.forget()\n            return new tree.Combinator(slashedCombinator)\n          }\n          parserInput.restore()\n        }\n\n        if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {\n          parserInput.i++\n          if (c === '^' && parserInput.currentChar() === '^') {\n            c = '^^'\n            parserInput.i++\n          }\n          while (parserInput.isWhitespace()) {\n            parserInput.i++\n          }\n          return new tree.Combinator(c)\n        } else if (parserInput.isWhitespace(-1)) {\n          return new tree.Combinator(' ')\n        } else {\n          return new tree.Combinator(null)\n        }\n      },\n      //\n      // A CSS selector (see selector below)\n      // with less extensions e.g. the ability to extend and guard\n      //\n      lessSelector() {\n        return this.selector(true)\n      },\n      //\n      // A CSS Selector\n      //\n      //     .class > div + h1\n      //     li a:hover\n      //\n      // Selectors are made out of one or more Elements, see above.\n      //\n      selector(isLess) {\n        const index = parserInput.i\n        let elements\n        let extendList\n        let c\n        let e\n        let allExtends\n        let when\n        let condition\n\n        while (\n          (isLess && (extendList = this.extend())) ||\n          (isLess && (when = parserInput.$str('when'))) ||\n          (e = this.element())\n        ) {\n          if (when) {\n            condition = expect(this.conditions, 'expected condition')\n          } else if (condition) {\n            error('CSS guard can only be used at the end of selector')\n          } else if (extendList) {\n            if (allExtends) {\n              allExtends = allExtends.concat(extendList)\n            } else {\n              allExtends = extendList\n            }\n          } else {\n            if (allExtends) {\n              error('Extend can only be used at the end of selector')\n            }\n            c = parserInput.currentChar()\n            if (elements) {\n              elements.push(e)\n            } else {\n              elements = [e]\n            }\n            e = null\n          }\n          if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {\n            break\n          }\n        }\n\n        if (elements) {\n          return new tree.Selector(\n            elements,\n            allExtends,\n            condition,\n            index,\n            fileInfo\n          )\n        }\n        if (allExtends) {\n          error(\n            'Extend must be used to extend a selector, it cannot be used on its own'\n          )\n        }\n      },\n      attribute() {\n        if (!parserInput.$char('[')) {\n          return\n        }\n\n        const entities = this.entities\n        let key\n        let val\n        let op\n\n        if (!(key = entities.variableCurly())) {\n          key = expect(/^(?:[_A-Za-z0-9-\\*]*\\|)?(?:[_A-Za-z0-9-]|\\\\.)+/)\n        }\n\n        op = parserInput.$re(/^[|~*$^]?=/)\n        if (op) {\n          val =\n            entities.quoted() ||\n            parserInput.$re(/^[0-9]+%/) ||\n            parserInput.$re(/^[\\w-]+/) ||\n            entities.variableCurly()\n        }\n\n        expectChar(']')\n\n        return new tree.Attribute(key, op, val)\n      },\n\n      //\n      // The `block` rule is used by `ruleset` and `mixin.definition`.\n      // It's a wrapper around the `primary` rule, with added `{}`.\n      //\n      block() {\n        let content\n        if (\n          parserInput.$char('{') &&\n          (content = this.primary()) &&\n          parserInput.$char('}')\n        ) {\n          return content\n        }\n      },\n\n      blockRuleset() {\n        let block = this.block()\n\n        if (block) {\n          block = new tree.Ruleset(null, block)\n        }\n        return block\n      },\n\n      detachedRuleset() {\n        const blockRuleset = this.blockRuleset()\n        if (blockRuleset) {\n          return new tree.DetachedRuleset(blockRuleset)\n        }\n      },\n\n      //\n      // div, .class, body > p {...}\n      //\n      ruleset() {\n        let selectors\n        let s\n        let rules\n        let debugInfo\n\n        parserInput.save()\n\n        if (context.dumpLineNumbers) {\n          debugInfo = getDebugInfo(parserInput.i)\n        }\n\n        while (true) {\n          s = this.lessSelector()\n          if (!s) {\n            break\n          }\n          if (selectors) {\n            selectors.push(s)\n          } else {\n            selectors = [s]\n          }\n          parserInput.commentStore.length = 0\n          if (s.condition && selectors.length > 1) {\n            error('Guards are only currently allowed on a single selector.')\n          }\n          if (!parserInput.$char(',')) {\n            break\n          }\n          if (s.condition) {\n            error('Guards are only currently allowed on a single selector.')\n          }\n          parserInput.commentStore.length = 0\n        }\n\n        if (selectors && (rules = this.block())) {\n          parserInput.forget()\n          const ruleset = new tree.Ruleset(\n            selectors,\n            rules,\n            context.strictImports\n          )\n          if (context.dumpLineNumbers) {\n            ruleset.debugInfo = debugInfo\n          }\n          return ruleset\n        } else {\n          parserInput.restore()\n        }\n      },\n      rule(tryAnonymous) {\n        let name\n        let value\n        const startOfRule = parserInput.i\n        const c = parserInput.currentChar()\n        let important\n        let merge\n        let isVariable\n\n        if (c === '.' || c === '#' || c === '&' || c === ':') {\n          return\n        }\n\n        parserInput.save()\n\n        name = this.variable() || this.ruleProperty()\n        if (name) {\n          isVariable = typeof name === 'string'\n\n          if (isVariable) {\n            value = this.detachedRuleset()\n          }\n\n          parserInput.commentStore.length = 0\n          if (!value) {\n            // a name returned by this.ruleProperty() is always an array of the form:\n            // [string-1, ..., string-n, \"\"] or [string-1, ..., string-n, \"+\"]\n            // where each item is a tree.Keyword or tree.Variable\n            merge = !isVariable && name.length > 1 && name.pop().value\n\n            // prefer to try to parse first if its a variable or we are compressing\n            // but always fallback on the other one\n            const tryValueFirst =\n              !tryAnonymous && (context.compress || isVariable)\n\n            if (tryValueFirst) {\n              value = this.value()\n            }\n            if (!value) {\n              value = this.anonymousValue()\n              if (value) {\n                parserInput.forget()\n                // anonymous values absorb the end ';' which is required for them to work\n                return new tree.Rule(\n                  name,\n                  value,\n                  false,\n                  merge,\n                  startOfRule,\n                  fileInfo\n                )\n              }\n            }\n            if (!tryValueFirst && !value) {\n              value = this.value()\n            }\n\n            important = this.important()\n          }\n\n          if (value && this.end()) {\n            parserInput.forget()\n            return new tree.Rule(\n              name,\n              value,\n              important,\n              merge,\n              startOfRule,\n              fileInfo\n            )\n          } else {\n            parserInput.restore()\n            if (value && !tryAnonymous) {\n              return this.rule(true)\n            }\n          }\n        } else {\n          parserInput.forget()\n        }\n      },\n      anonymousValue() {\n        const match = parserInput.$re(/^([^@+\\/'\"*`(;{}-]*);/)\n        if (match) {\n          return new tree.Anonymous(match[1])\n        }\n      },\n\n      //\n      // An @import directive\n      //\n      //     @import \"lib\";\n      //\n      // Depending on our environment, importing is done differently:\n      // In the browser, it's an XHR request, in Node, it would be a\n      // file-system operation. The function used for importing is\n      // stored in `import`, which we pass to the Import constructor.\n      //\n      import: function() {\n        let path\n        let features\n        const index = parserInput.i\n\n        const dir = parserInput.$re(/^@import?\\s+/)\n\n        if (dir) {\n          const options = (dir ? this.importOptions() : null) || {}\n\n          if ((path = this.entities.quoted() || this.entities.url())) {\n            features = this.mediaFeatures()\n\n            if (!parserInput.$char(';')) {\n              parserInput.i = index\n              error(\n                'missing semi-colon or unrecognised media features on import'\n              )\n            }\n            features = features && new tree.Value(features)\n            return new tree.Import(path, features, options, index, fileInfo)\n          } else {\n            parserInput.i = index\n            error('malformed import statement')\n          }\n        }\n      },\n\n      importOptions() {\n        let o\n        const options = {}\n        let optionName\n        let value\n\n        // list of options, surrounded by parens\n        if (!parserInput.$char('(')) {\n          return null\n        }\n        do {\n          o = this.importOption()\n          if (o) {\n            optionName = o\n            value = true\n            switch (optionName) {\n              case 'css':\n                optionName = 'less'\n                value = false\n                break\n              case 'once':\n                optionName = 'multiple'\n                value = false\n                break\n            }\n            options[optionName] = value\n            if (!parserInput.$char(',')) {\n              break\n            }\n          }\n        } while (o)\n        expectChar(')')\n        return options\n      },\n\n      importOption() {\n        const opt = parserInput.$re(\n          /^(less|css|multiple|once|inline|reference|optional)/\n        )\n        if (opt) {\n          return opt[1]\n        }\n      },\n\n      mediaFeature() {\n        const entities = this.entities\n        const nodes = []\n        let e\n        let p\n        parserInput.save()\n        do {\n          e = entities.keyword() || entities.variable()\n          if (e) {\n            nodes.push(e)\n          } else if (parserInput.$char('(')) {\n            p = this.property()\n            e = this.value()\n            if (parserInput.$char(')')) {\n              if (p && e) {\n                nodes.push(\n                  new tree.Paren(\n                    new tree.Rule(\n                      p,\n                      e,\n                      null,\n                      null,\n                      parserInput.i,\n                      fileInfo,\n                      true\n                    )\n                  )\n                )\n              } else if (e) {\n                nodes.push(new tree.Paren(e))\n              } else {\n                error('badly formed media feature definition')\n              }\n            } else {\n              error(\"Missing closing ')'\", 'Parse')\n            }\n          }\n        } while (e)\n\n        parserInput.forget()\n        if (nodes.length > 0) {\n          return new tree.Expression(nodes)\n        }\n      },\n\n      mediaFeatures() {\n        const entities = this.entities\n        const features = []\n        let e\n        do {\n          e = this.mediaFeature()\n          if (e) {\n            features.push(e)\n            if (!parserInput.$char(',')) {\n              break\n            }\n          } else {\n            e = entities.variable()\n            if (e) {\n              features.push(e)\n              if (!parserInput.$char(',')) {\n                break\n              }\n            }\n          }\n        } while (e)\n\n        return features.length > 0 ? features : null\n      },\n\n      media() {\n        let features\n        let rules\n        let media\n        let debugInfo\n        const index = parserInput.i\n\n        if (context.dumpLineNumbers) {\n          debugInfo = getDebugInfo(index)\n        }\n\n        parserInput.save()\n\n        if (parserInput.$str('@media')) {\n          features = this.mediaFeatures()\n\n          rules = this.block()\n\n          if (!rules) {\n            error(\n              'media definitions require block statements after any features'\n            )\n          }\n\n          parserInput.forget()\n\n          media = new tree.Media(rules, features, index, fileInfo)\n          if (context.dumpLineNumbers) {\n            media.debugInfo = debugInfo\n          }\n\n          return media\n        }\n\n        parserInput.restore()\n      },\n\n      //\n      // A @plugin directive, used to import compiler extensions dynamically.\n      //\n      //     @plugin \"lib\";\n      //\n      // Depending on our environment, importing is done differently:\n      // In the browser, it's an XHR request, in Node, it would be a\n      // file-system operation. The function used for importing is\n      // stored in `import`, which we pass to the Import constructor.\n      //\n      plugin() {\n        let path\n        const index = parserInput.i\n        const dir = parserInput.$re(/^@plugin?\\s+/)\n\n        if (dir) {\n          const options = { plugin: true }\n\n          if ((path = this.entities.quoted() || this.entities.url())) {\n            if (!parserInput.$char(';')) {\n              parserInput.i = index\n              error('missing semi-colon on plugin')\n            }\n\n            return new tree.Import(path, null, options, index, fileInfo)\n          } else {\n            parserInput.i = index\n            error('malformed plugin statement')\n          }\n        }\n      },\n\n      //\n      // A CSS Directive\n      //\n      //     @charset \"utf-8\";\n      //\n      directive() {\n        const index = parserInput.i\n        let name\n        let value\n        let rules\n        let nonVendorSpecificName\n        let hasIdentifier\n        let hasExpression\n        let hasUnknown\n        let hasBlock = true\n        let isRooted = true\n\n        if (parserInput.currentChar() !== '@') {\n          return\n        }\n\n        value = this['import']() || this.plugin() || this.media()\n        if (value) {\n          return value\n        }\n\n        parserInput.save()\n\n        name = parserInput.$re(/^@[a-z-]+/)\n\n        if (!name) {\n          return\n        }\n\n        nonVendorSpecificName = name\n        if (name.charAt(1) == '-' && name.indexOf('-', 2) > 0) {\n          nonVendorSpecificName = `@${name.slice(name.indexOf('-', 2) + 1)}`\n        }\n\n        switch (nonVendorSpecificName) {\n          case '@charset':\n            hasIdentifier = true\n            hasBlock = false\n            break\n          case '@namespace':\n            hasExpression = true\n            hasBlock = false\n            break\n          case '@keyframes':\n          case '@counter-style':\n            hasIdentifier = true\n            break\n          case '@document':\n          case '@supports':\n            hasUnknown = true\n            isRooted = false\n            break\n          default:\n            hasUnknown = true\n            break\n        }\n\n        parserInput.commentStore.length = 0\n\n        if (hasIdentifier) {\n          value = this.entity()\n          if (!value) {\n            error(`expected ${name} identifier`)\n          }\n        } else if (hasExpression) {\n          value = this.expression()\n          if (!value) {\n            error(`expected ${name} expression`)\n          }\n        } else if (hasUnknown) {\n          value = (parserInput.$re(/^[^{;]+/) || '').trim()\n          hasBlock = parserInput.currentChar() == '{'\n          if (value) {\n            value = new tree.Anonymous(value)\n          }\n        }\n\n        if (hasBlock) {\n          rules = this.blockRuleset()\n        }\n\n        if (rules || (!hasBlock && value && parserInput.$char(';'))) {\n          parserInput.forget()\n          return new tree.Directive(\n            name,\n            value,\n            rules,\n            index,\n            fileInfo,\n            context.dumpLineNumbers ? getDebugInfo(index) : null,\n            isRooted\n          )\n        }\n\n        parserInput.restore('directive options not recognised')\n      },\n\n      //\n      // A Value is a comma-delimited list of Expressions\n      //\n      //     font-family: Baskerville, Georgia, serif;\n      //\n      // In a Rule, a Value represents everything after the `:`,\n      // and before the `;`.\n      //\n      value() {\n        let e\n        const expressions = []\n\n        do {\n          e = this.expression()\n          if (e) {\n            expressions.push(e)\n            if (!parserInput.$char(',')) {\n              break\n            }\n          }\n        } while (e)\n\n        if (expressions.length > 0) {\n          return new tree.Value(expressions)\n        }\n      },\n      important() {\n        if (parserInput.currentChar() === '!') {\n          return parserInput.$re(/^! *important/)\n        }\n      },\n      sub() {\n        let a\n        let e\n\n        parserInput.save()\n        if (parserInput.$char('(')) {\n          a = this.addition()\n          if (a && parserInput.$char(')')) {\n            parserInput.forget()\n            e = new tree.Expression([a])\n            e.parens = true\n            return e\n          }\n          parserInput.restore(\"Expected ')'\")\n          return\n        }\n        parserInput.restore()\n      },\n      multiplication() {\n        let m\n        let a\n        let op\n        let operation\n        let isSpaced\n        m = this.operand()\n        if (m) {\n          isSpaced = parserInput.isWhitespace(-1)\n          while (true) {\n            if (parserInput.peek(/^\\/[*\\/]/)) {\n              break\n            }\n\n            parserInput.save()\n\n            op = parserInput.$char('/') || parserInput.$char('*')\n\n            if (!op) {\n              parserInput.forget()\n              break\n            }\n\n            a = this.operand()\n\n            if (!a) {\n              parserInput.restore()\n              break\n            }\n            parserInput.forget()\n\n            m.parensInOp = true\n            a.parensInOp = true\n            operation = new tree.Operation(op, [operation || m, a], isSpaced)\n            isSpaced = parserInput.isWhitespace(-1)\n          }\n          return operation || m\n        }\n      },\n      addition() {\n        let m\n        let a\n        let op\n        let operation\n        let isSpaced\n        m = this.multiplication()\n        if (m) {\n          isSpaced = parserInput.isWhitespace(-1)\n          while (true) {\n            op =\n              parserInput.$re(/^[-+]\\s+/) ||\n              (!isSpaced && (parserInput.$char('+') || parserInput.$char('-')))\n            if (!op) {\n              break\n            }\n            a = this.multiplication()\n            if (!a) {\n              break\n            }\n\n            m.parensInOp = true\n            a.parensInOp = true\n            operation = new tree.Operation(op, [operation || m, a], isSpaced)\n            isSpaced = parserInput.isWhitespace(-1)\n          }\n          return operation || m\n        }\n      },\n      conditions() {\n        let a\n        let b\n        const index = parserInput.i\n        let condition\n\n        a = this.condition()\n        if (a) {\n          while (true) {\n            if (\n              !parserInput.peek(/^,\\s*(not\\s*)?\\(/) ||\n              !parserInput.$char(',')\n            ) {\n              break\n            }\n            b = this.condition()\n            if (!b) {\n              break\n            }\n            condition = new tree.Condition('or', condition || a, b, index)\n          }\n          return condition || a\n        }\n      },\n      condition() {\n        let result\n        let logical\n        let next\n        function or() {\n          return parserInput.$str('or')\n        }\n\n        result = this.conditionAnd(this)\n        if (!result) {\n          return\n        }\n        logical = or()\n        if (logical) {\n          next = this.condition()\n          if (next) {\n            result = new tree.Condition(logical, result, next)\n          } else {\n            return\n          }\n        }\n        return result\n      },\n      conditionAnd() {\n        let result\n        let logical\n        let next\n        function insideCondition(me) {\n          return me.negatedCondition() || me.parenthesisCondition()\n        }\n        function and() {\n          return parserInput.$str('and')\n        }\n\n        result = insideCondition(this)\n        if (!result) {\n          return\n        }\n        logical = and()\n        if (logical) {\n          next = this.conditionAnd()\n          if (next) {\n            result = new tree.Condition(logical, result, next)\n          } else {\n            return\n          }\n        }\n        return result\n      },\n      negatedCondition() {\n        if (parserInput.$str('not')) {\n          const result = this.parenthesisCondition()\n          if (result) {\n            result.negate = !result.negate\n          }\n          return result\n        }\n      },\n      parenthesisCondition() {\n        function tryConditionFollowedByParenthesis(me) {\n          let body\n          parserInput.save()\n          body = me.condition()\n          if (!body) {\n            parserInput.restore()\n            return\n          }\n          if (!parserInput.$char(')')) {\n            parserInput.restore()\n            return\n          }\n          parserInput.forget()\n          return body\n        }\n\n        let body\n        parserInput.save()\n        if (!parserInput.$str('(')) {\n          parserInput.restore()\n          return\n        }\n        body = tryConditionFollowedByParenthesis(this)\n        if (body) {\n          parserInput.forget()\n          return body\n        }\n\n        body = this.atomicCondition()\n        if (!body) {\n          parserInput.restore()\n          return\n        }\n        if (!parserInput.$char(')')) {\n          parserInput.restore(`expected ')' got '${parserInput.currentChar()}'`)\n          return\n        }\n        parserInput.forget()\n        return body\n      },\n      atomicCondition() {\n        const entities = this.entities\n        const index = parserInput.i\n        let a\n        let b\n        let c\n        let op\n\n        a = this.addition() || entities.keyword() || entities.quoted()\n        if (a) {\n          if (parserInput.$char('>')) {\n            if (parserInput.$char('=')) {\n              op = '>='\n            } else {\n              op = '>'\n            }\n          } else if (parserInput.$char('<')) {\n            if (parserInput.$char('=')) {\n              op = '<='\n            } else {\n              op = '<'\n            }\n          } else if (parserInput.$char('=')) {\n            if (parserInput.$char('>')) {\n              op = '=>'\n            } else if (parserInput.$char('<')) {\n              op = '=<'\n            } else {\n              op = '='\n            }\n          }\n          if (op) {\n            b = this.addition() || entities.keyword() || entities.quoted()\n            if (b) {\n              c = new tree.Condition(op, a, b, index, false)\n            } else {\n              error('expected expression')\n            }\n          } else {\n            c = new tree.Condition(\n              '=',\n              a,\n              new tree.Keyword('true'),\n              index,\n              false\n            )\n          }\n          return c\n        }\n      },\n\n      //\n      // An operand is anything that can be part of an operation,\n      // such as a Color, or a Variable\n      //\n      operand() {\n        const entities = this.entities\n        let negate\n\n        if (parserInput.peek(/^-[@\\(]/)) {\n          negate = parserInput.$char('-')\n        }\n\n        let o =\n          this.sub() ||\n          entities.dimension() ||\n          entities.color() ||\n          entities.variable() ||\n          entities.call() ||\n          entities.colorKeyword()\n\n        if (negate) {\n          o.parensInOp = true\n          o = new tree.Negative(o)\n        }\n\n        return o\n      },\n\n      //\n      // Expressions either represent mathematical operations,\n      // or white-space delimited Entities.\n      //\n      //     1px solid black\n      //     @var * 2\n      //\n      expression() {\n        const entities = []\n        let e\n        let delim\n\n        do {\n          e = this.comment()\n          if (e) {\n            entities.push(e)\n            continue\n          }\n          e = this.addition() || this.entity()\n          if (e) {\n            entities.push(e)\n            // operations do not allow keyword \"/\" dimension (e.g. small/20px) so we support that here\n            if (!parserInput.peek(/^\\/[\\/*]/)) {\n              delim = parserInput.$char('/')\n              if (delim) {\n                entities.push(new tree.Anonymous(delim))\n              }\n            }\n          }\n        } while (e)\n        if (entities.length > 0) {\n          return new tree.Expression(entities)\n        }\n      },\n      property() {\n        const name = parserInput.$re(/^(\\*?-?[_a-zA-Z0-9-]+)\\s*:/)\n        if (name) {\n          return name[1]\n        }\n      },\n      ruleProperty() {\n        let name = []\n        const index = []\n        let s\n        let k\n\n        parserInput.save()\n\n        const simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\\s*:/)\n        if (simpleProperty) {\n          name = [new tree.Keyword(simpleProperty[1])]\n          parserInput.forget()\n          return name\n        }\n\n        function match(re) {\n          const i = parserInput.i\n          const chunk = parserInput.$re(re)\n          if (chunk) {\n            index.push(i)\n            return name.push(chunk[1])\n          }\n        }\n\n        match(/^(\\*?)/)\n        while (true) {\n          if (!match(/^((?:[\\w-]+)|(?:@\\{[\\w-]+\\}))/)) {\n            break\n          }\n        }\n\n        if (name.length > 1 && match(/^((?:\\+_|\\+)?)\\s*:/)) {\n          parserInput.forget()\n\n          // at last, we have the complete match now. move forward,\n          // convert name particles to tree objects and return:\n          if (name[0] === '') {\n            name.shift()\n            index.shift()\n          }\n          for (k = 0; k < name.length; k++) {\n            s = name[k]\n            name[k] =\n              s.charAt(0) !== '@'\n                ? new tree.Keyword(s)\n                : new tree.Variable(`@${s.slice(2, -1)}`, index[k], fileInfo)\n          }\n          return name\n        }\n        parserInput.restore()\n      },\n    }),\n  }\n}\nParser.serializeVars = vars => {\n  let s = ''\n\n  for (const name in vars) {\n    if (Object.hasOwnProperty.call(vars, name)) {\n      const value = vars[name]\n      s += `${(name[0] === '@' ? '' : '@') + name}: ${value}${String(\n        value\n      ).slice(-1) === ';'\n        ? ''\n        : ';'}`\n    }\n  }\n\n  return s\n}\n\nmodule.exports = Parser\n","const LessError = require('../less-error')\nconst tree = require('../tree')\n\nconst FunctionImporter = (module.exports = function FunctionImporter(\n  context,\n  fileInfo\n) {\n  this.fileInfo = fileInfo\n})\n\nFunctionImporter.prototype.eval = function(contents, callback) {\n  const loaded = {}\n  let loader\n  let registry\n\n  registry = {\n    add(name, func) {\n      loaded[name] = func\n    },\n    addMultiple(functions) {\n      Object.keys(functions).forEach(name => {\n        loaded[name] = functions[name]\n      })\n    },\n  }\n\n  try {\n    loader = new Function('functions', 'tree', 'fileInfo', contents)\n    loader(registry, tree, this.fileInfo)\n  } catch (e) {\n    callback(\n      new LessError({\n        message: `Plugin evaluation error: '${e.name}: ${e.message.replace(\n          /[\"]/g,\n          \"'\"\n        )}'`,\n        filename: this.fileInfo.filename,\n      }),\n      null\n    )\n  }\n\n  callback(null, { functions: loaded })\n}\n","const contexts = require('./contexts')\nconst Parser = require('./parser/parser')\nconst FunctionImporter = require('./plugins/function-importer')\n\nmodule.exports = environment => {\n  // FileInfo = {\n  //  'relativeUrls' - option - whether to adjust URL's to be relative\n  //  'filename' - full resolved filename of current file\n  //  'rootpath' - path to append to normal URLs for this node\n  //  'currentDirectory' - path to the current file, absolute\n  //  'rootFilename' - filename of the base file\n  //  'entryPath' - absolute path to the entry file\n  //  'reference' - whether the file should not be output and only output parts that are referenced\n\n  class ImportManager {\n    constructor(context, rootFileInfo) {\n      this.rootFilename = rootFileInfo.filename\n      this.paths = context.paths || [] // Search paths, when importing\n      this.contents = {} // map - filename to contents of all the files\n      this.contentsIgnoredChars = {} // map - filename to lines at the beginning of each file to ignore\n      this.mime = context.mime\n      this.error = null\n      this.context = context\n      // Deprecated? Unused outside of here, could be useful.\n      this.queue = [] // Files which haven't been imported yet\n      this.files = {} // Holds the imported parse trees.\n    }\n\n    /**\n         * Add an import to be imported\n         * @param path - the raw path\n         * @param tryAppendLessExtension - whether to try appending the less extension (if the path has no extension)\n         * @param currentFileInfo - the current file info (used for instance to work out relative paths)\n         * @param importOptions - import options\n         * @param callback - callback for when it is imported\n         */\n    push(\n      path,\n      tryAppendLessExtension,\n      currentFileInfo,\n      importOptions,\n      callback\n    ) {\n      const importManager = this\n      this.queue.push(path)\n\n      const fileParsedFunc = (e, root, fullPath) => {\n        importManager.queue.splice(importManager.queue.indexOf(path), 1) // Remove the path from the queue\n\n        const importedEqualsRoot = fullPath === importManager.rootFilename\n        if (importOptions.optional && e) {\n          callback(null, { rules: [] }, false, null)\n        } else {\n          importManager.files[fullPath] = root\n          if (e && !importManager.error) {\n            importManager.error = e\n          }\n          callback(e, root, importedEqualsRoot, fullPath)\n        }\n      }\n\n      const newFileInfo = {\n        relativeUrls: this.context.relativeUrls,\n        entryPath: currentFileInfo.entryPath,\n        rootpath: currentFileInfo.rootpath,\n        rootFilename: currentFileInfo.rootFilename,\n      }\n\n      const fileManager = environment.getFileManager(\n        path,\n        currentFileInfo.currentDirectory,\n        this.context,\n        environment\n      )\n\n      if (!fileManager) {\n        fileParsedFunc({ message: `Could not find a file-manager for ${path}` })\n        return\n      }\n\n      if (tryAppendLessExtension) {\n        path = fileManager.tryAppendExtension(\n          path,\n          importOptions.plugin ? '.js' : '.less'\n        )\n      }\n\n      const loadFileCallback = loadedFile => {\n        const resolvedFilename = loadedFile.filename\n        const contents = loadedFile.contents.replace(/^\\uFEFF/, '')\n\n        // Pass on an updated rootpath if path of imported file is relative and file\n        // is in a (sub|sup) directory\n        //\n        // Examples:\n        // - If path of imported file is 'module/nav/nav.less' and rootpath is 'less/',\n        //   then rootpath should become 'less/module/nav/'\n        // - If path of imported file is '../mixins.less' and rootpath is 'less/',\n        //   then rootpath should become 'less/../'\n        newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename)\n        if (newFileInfo.relativeUrls) {\n          newFileInfo.rootpath = fileManager.join(\n            importManager.context.rootpath || '',\n            fileManager.pathDiff(\n              newFileInfo.currentDirectory,\n              newFileInfo.entryPath\n            )\n          )\n\n          if (\n            !fileManager.isPathAbsolute(newFileInfo.rootpath) &&\n            fileManager.alwaysMakePathsAbsolute()\n          ) {\n            newFileInfo.rootpath = fileManager.join(\n              newFileInfo.entryPath,\n              newFileInfo.rootpath\n            )\n          }\n        }\n        newFileInfo.filename = resolvedFilename\n\n        const newEnv = new contexts.Parse(importManager.context)\n\n        newEnv.processImports = false\n        importManager.contents[resolvedFilename] = contents\n\n        if (currentFileInfo.reference || importOptions.reference) {\n          newFileInfo.reference = true\n        }\n\n        if (importOptions.plugin) {\n          new FunctionImporter(\n            newEnv,\n            newFileInfo\n          ).eval(contents, (e, root) => {\n            fileParsedFunc(e, root, resolvedFilename)\n          })\n        } else if (importOptions.inline) {\n          fileParsedFunc(null, contents, resolvedFilename)\n        } else {\n          new Parser(\n            newEnv,\n            importManager,\n            newFileInfo\n          ).parse(contents, (e, root) => {\n            fileParsedFunc(e, root, resolvedFilename)\n          })\n        }\n      }\n\n      const promise = fileManager.loadFile(\n        path,\n        currentFileInfo.currentDirectory,\n        this.context,\n        environment,\n        (err, loadedFile) => {\n          if (err) {\n            fileParsedFunc(err)\n          } else {\n            loadFileCallback(loadedFile)\n          }\n        }\n      )\n      if (promise) {\n        promise.then(loadFileCallback, fileParsedFunc)\n      }\n    }\n  }\n\n  return ImportManager\n}\n","module.exports = {\n  colors: require('./colors'),\n  unitConversions: require('./unit-conversions'),\n}\n","class abstractFileManager {\n  getPath(filename) {\n    let j = filename.lastIndexOf('?')\n    if (j > 0) {\n      filename = filename.slice(0, j)\n    }\n    j = filename.lastIndexOf('/')\n    if (j < 0) {\n      j = filename.lastIndexOf('\\\\')\n    }\n    if (j < 0) {\n      return ''\n    }\n    return filename.slice(0, j + 1)\n  }\n\n  tryAppendExtension(path, ext) {\n    return /(\\.[a-z]*$)|([\\?;].*)$/.test(path) ? path : path + ext\n  }\n\n  tryAppendLessExtension(path) {\n    return this.tryAppendExtension(path, '.less')\n  }\n\n  supportsSync() {\n    return false\n  }\n\n  alwaysMakePathsAbsolute() {\n    return false\n  }\n\n  isPathAbsolute(filename) {\n    return /^(?:[a-z-]+:|\\/|\\\\|#)/i.test(filename)\n  }\n\n  join(basePath, laterPath) {\n    if (!basePath) {\n      return laterPath\n    }\n    return basePath + laterPath\n  }\n\n  pathDiff(url, baseUrl) {\n    // diff between two paths to create a relative path\n\n    const urlParts = this.extractUrlParts(url)\n\n    const baseUrlParts = this.extractUrlParts(baseUrl)\n    let i\n    let max\n    let urlDirectories\n    let baseUrlDirectories\n    let diff = ''\n    if (urlParts.hostPart !== baseUrlParts.hostPart) {\n      return ''\n    }\n    max = Math.max(baseUrlParts.directories.length, urlParts.directories.length)\n    for (i = 0; i < max; i++) {\n      if (baseUrlParts.directories[i] !== urlParts.directories[i]) {\n        break\n      }\n    }\n    baseUrlDirectories = baseUrlParts.directories.slice(i)\n    urlDirectories = urlParts.directories.slice(i)\n    for (i = 0; i < baseUrlDirectories.length - 1; i++) {\n      diff += '../'\n    }\n    for (i = 0; i < urlDirectories.length - 1; i++) {\n      diff += `${urlDirectories[i]}/`\n    }\n    return diff\n  }\n\n  // helper function, not part of API\n  extractUrlParts(url, baseUrl) {\n    // urlParts[1] = protocol://hostname/ OR /\n    // urlParts[2] = / if path relative to host base\n    // urlParts[3] = directories\n    // urlParts[4] = filename\n    // urlParts[5] = parameters\n\n    const urlPartsRegex = /^((?:[a-z-]+:)?\\/{2}(?:[^\\/\\?#]*\\/)|([\\/\\\\]))?((?:[^\\/\\\\\\?#]*[\\/\\\\])*)([^\\/\\\\\\?#]*)([#\\?].*)?$/i\n\n    const urlParts = url.match(urlPartsRegex)\n    const returner = {}\n    let directories = []\n    let i\n    let baseUrlParts\n\n    if (!urlParts) {\n      throw new Error(`Could not parse sheet href - '${url}'`)\n    }\n\n    // Stylesheets in IE don't always return the full path\n    if (baseUrl && (!urlParts[1] || urlParts[2])) {\n      baseUrlParts = baseUrl.match(urlPartsRegex)\n      if (!baseUrlParts) {\n        throw new Error(`Could not parse page url - '${baseUrl}'`)\n      }\n      urlParts[1] = urlParts[1] || baseUrlParts[1] || ''\n      if (!urlParts[2]) {\n        urlParts[3] = baseUrlParts[3] + urlParts[3]\n      }\n    }\n\n    if (urlParts[3]) {\n      directories = urlParts[3].replace(/\\\\/g, '/').split('/')\n\n      // extract out . before .. so .. doesn't absorb a non-directory\n      for (i = 0; i < directories.length; i++) {\n        if (directories[i] === '.') {\n          directories.splice(i, 1)\n          i -= 1\n        }\n      }\n\n      for (i = 0; i < directories.length; i++) {\n        if (directories[i] === '..' && i > 0) {\n          directories.splice(i - 1, 2)\n          i -= 2\n        }\n      }\n    }\n\n    returner.hostPart = urlParts[1]\n    returner.directories = directories\n    returner.path = (urlParts[1] || '') + directories.join('/')\n    returner.fileUrl = returner.path + (urlParts[4] || '')\n    returner.url = returner.fileUrl + (urlParts[5] || '')\n    return returner\n  }\n}\n\nmodule.exports = abstractFileManager\n","module.exports = environment => {\n  const Quoted = require('../tree/quoted')\n  const URL = require('../tree/url')\n  const functionRegistry = require('./function-registry')\n  const fallback = (functionThis, node) =>\n    new URL(node, functionThis.index, functionThis.currentFileInfo).eval(\n      functionThis.context\n    )\n  const logger = require('../logger')\n\n  functionRegistry.add('data-uri', function(mimetypeNode, filePathNode) {\n    if (!filePathNode) {\n      filePathNode = mimetypeNode\n      mimetypeNode = null\n    }\n\n    let mimetype = mimetypeNode && mimetypeNode.value\n    let filePath = filePathNode.value\n    const currentFileInfo = this.currentFileInfo\n    const currentDirectory = currentFileInfo.relativeUrls\n      ? currentFileInfo.currentDirectory\n      : currentFileInfo.entryPath\n\n    const fragmentStart = filePath.indexOf('#')\n    let fragment = ''\n    if (fragmentStart !== -1) {\n      fragment = filePath.slice(fragmentStart)\n      filePath = filePath.slice(0, fragmentStart)\n    }\n\n    const fileManager = environment.getFileManager(\n      filePath,\n      currentDirectory,\n      this.context,\n      environment,\n      true\n    )\n\n    if (!fileManager) {\n      return fallback(this, filePathNode)\n    }\n\n    let useBase64 = false\n\n    // detect the mimetype if not given\n    if (!mimetypeNode) {\n      mimetype = environment.mimeLookup(filePath)\n\n      if (mimetype === 'image/svg+xml') {\n        useBase64 = false\n      } else {\n        // use base 64 unless it's an ASCII or UTF-8 format\n        const charset = environment.charsetLookup(mimetype)\n        useBase64 = ['US-ASCII', 'UTF-8'].indexOf(charset) < 0\n      }\n      if (useBase64) {\n        mimetype += ';base64'\n      }\n    } else {\n      useBase64 = /;base64$/.test(mimetype)\n    }\n\n    const fileSync = fileManager.loadFileSync(\n      filePath,\n      currentDirectory,\n      this.context,\n      environment\n    )\n    if (!fileSync.contents) {\n      logger.warn(\n        `Skipped data-uri embedding of ${filePath} because file not found`\n      )\n      return fallback(this, filePathNode || mimetypeNode)\n    }\n    let buf = fileSync.contents\n    if (useBase64 && !environment.encodeBase64) {\n      return fallback(this, filePathNode)\n    }\n\n    buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf)\n\n    const uri = `data:${mimetype},${buf}${fragment}`\n\n    // IE8 cannot handle a data-uri larger than 32,768 characters. If this is exceeded\n    // and the --ieCompat flag is enabled, return a normal url() instead.\n    const DATA_URI_MAX = 32768\n    if (uri.length >= DATA_URI_MAX) {\n      if (this.context.ieCompat !== false) {\n        logger.warn(\n          `Skipped data-uri embedding of ${filePath} because its size (${uri.length} characters) exceeds IE8-safe ${DATA_URI_MAX} characters!`\n        )\n\n        return fallback(this, filePathNode || mimetypeNode)\n      }\n    }\n\n    return new URL(\n      new Quoted(`\"${uri}\"`, uri, false, this.index, this.currentFileInfo),\n      this.index,\n      this.currentFileInfo\n    )\n  })\n}\n","const Dimension = require('../tree/dimension')\n\nconst MathHelper = () => {}\nMathHelper._math = (fn, unit, n) => {\n  if (!(n instanceof Dimension)) {\n    throw { type: 'Argument', message: 'argument must be a number' }\n  }\n  if (unit == null) {\n    unit = n.unit\n  } else {\n    n = n.unify()\n  }\n  return new Dimension(fn(parseFloat(n.value)), unit)\n}\nmodule.exports = MathHelper\n","const Dimension = require('../tree/dimension')\nconst Anonymous = require('../tree/anonymous')\nconst functionRegistry = require('./function-registry')\nconst mathHelper = require('./math-helper.js')\n\nconst minMax = function(isMin, args) {\n  args = Array.prototype.slice.call(args)\n  switch (args.length) {\n    case 0:\n      throw { type: 'Argument', message: 'one or more arguments required' }\n  }\n  let i // key is the unit.toString() for unified Dimension values,\n  let j\n  let current\n  let currentUnified\n  let referenceUnified\n  let unit\n  let unitStatic\n  let unitClone\n\n  const // elems only contains original argument values.\n  order = []\n\n  const values = {}\n  // value is the index into the order array.\n  for (i = 0; i < args.length; i++) {\n    current = args[i]\n    if (!(current instanceof Dimension)) {\n      if (Array.isArray(args[i].value)) {\n        Array.prototype.push.apply(\n          args,\n          Array.prototype.slice.call(args[i].value)\n        )\n      }\n      continue\n    }\n    currentUnified =\n      current.unit.toString() === '' && unitClone !== undefined\n        ? new Dimension(current.value, unitClone).unify()\n        : current.unify()\n    unit =\n      currentUnified.unit.toString() === '' && unitStatic !== undefined\n        ? unitStatic\n        : currentUnified.unit.toString()\n    unitStatic =\n      (unit !== '' && unitStatic === undefined) ||\n      (unit !== '' && order[0].unify().unit.toString() === '')\n        ? unit\n        : unitStatic\n    unitClone =\n      unit !== '' && unitClone === undefined\n        ? current.unit.toString()\n        : unitClone\n    j =\n      values[''] !== undefined && unit !== '' && unit === unitStatic\n        ? values['']\n        : values[unit]\n    if (j === undefined) {\n      if (unitStatic !== undefined && unit !== unitStatic) {\n        throw { type: 'Argument', message: 'incompatible types' }\n      }\n      values[unit] = order.length\n      order.push(current)\n      continue\n    }\n    referenceUnified =\n      order[j].unit.toString() === '' && unitClone !== undefined\n        ? new Dimension(order[j].value, unitClone).unify()\n        : order[j].unify()\n    if (\n      (isMin && currentUnified.value < referenceUnified.value) ||\n      (!isMin && currentUnified.value > referenceUnified.value)\n    ) {\n      order[j] = current\n    }\n  }\n  if (order.length == 1) {\n    return order[0]\n  }\n  args = order\n    .map(function(a) {\n      return a.toCSS(this.context)\n    })\n    .join(this.context.compress ? ',' : ', ')\n  return new Anonymous(`${isMin ? 'min' : 'max'}(${args})`)\n}\nfunctionRegistry.addMultiple({\n  min(...args) {\n    return minMax(true, args)\n  },\n  max(...args) {\n    return minMax(false, args)\n  },\n  convert(val, unit) {\n    return val.convertTo(unit.value)\n  },\n  pi() {\n    return new Dimension(Math.PI)\n  },\n  mod(a, b) {\n    return new Dimension(a.value % b.value, a.unit)\n  },\n  pow(x, y) {\n    if (typeof x === 'number' && typeof y === 'number') {\n      x = new Dimension(x)\n      y = new Dimension(y)\n    } else if (!(x instanceof Dimension) || !(y instanceof Dimension)) {\n      throw { type: 'Argument', message: 'arguments must be numbers' }\n    }\n\n    return new Dimension(Math.pow(x.value, y.value), x.unit)\n  },\n  percentage(n) {\n    const result = mathHelper._math(num => num * 100, '%', n)\n\n    return result\n  },\n})\n","const functionRegistry = require('./function-registry')\nconst mathHelper = require('./math-helper.js')\n\nconst mathFunctions = {\n  // name,  unit\n  ceil: null,\n  floor: null,\n  sqrt: null,\n  abs: null,\n  tan: '',\n  sin: '',\n  cos: '',\n  atan: 'rad',\n  asin: 'rad',\n  acos: 'rad',\n}\n\nfor (const f in mathFunctions) {\n  if (mathFunctions.hasOwnProperty(f)) {\n    mathFunctions[f] = mathHelper._math.bind(null, Math[f], mathFunctions[f])\n  }\n}\n\nmathFunctions.round = (n, f) => {\n  const fraction = typeof f === 'undefined' ? 0 : f.value\n  return mathHelper._math(num => num.toFixed(fraction), null, n)\n}\n\nfunctionRegistry.addMultiple(mathFunctions)\n","const Quoted = require('../tree/quoted')\nconst Anonymous = require('../tree/anonymous')\nconst JavaScript = require('../tree/javascript')\nconst functionRegistry = require('./function-registry')\n\nfunctionRegistry.addMultiple({\n  e(str) {\n    return new Anonymous(str instanceof JavaScript ? str.evaluated : str.value)\n  },\n  escape(str) {\n    return new Anonymous(\n      encodeURI(str.value)\n        .replace(/=/g, '%3D')\n        .replace(/:/g, '%3A')\n        .replace(/#/g, '%23')\n        .replace(/;/g, '%3B')\n        .replace(/\\(/g, '%28')\n        .replace(/\\)/g, '%29')\n    )\n  },\n  replace(string, pattern, replacement, flags) {\n    let result = string.value\n    replacement =\n      replacement.type === 'Quoted' ? replacement.value : replacement.toCSS()\n    result = result.replace(\n      new RegExp(pattern.value, flags ? flags.value : ''),\n      replacement\n    )\n    return new Quoted(string.quote || '', result, string.escaped)\n  },\n  '%': function(string /* arg, arg, ...*/) {\n    const args = Array.prototype.slice.call(arguments, 1)\n    let result = string.value\n\n    for (let i = 0; i < args.length; i++) {\n      /*jshint loopfunc:true */\n      result = result.replace(/%[sda]/i, token => {\n        const value =\n          args[i].type === 'Quoted' && token.match(/s/i)\n            ? args[i].value\n            : args[i].toCSS()\n        return token.match(/[A-Z]$/) ? encodeURIComponent(value) : value\n      })\n    }\n    result = result.replace(/%%/g, '%')\n    return new Quoted(string.quote || '', result, string.escaped)\n  },\n})\n","module.exports = environment => {\n  const Dimension = require('../tree/dimension')\n  const Color = require('../tree/color')\n  const Expression = require('../tree/expression')\n  const Quoted = require('../tree/quoted')\n  const URL = require('../tree/url')\n  const functionRegistry = require('./function-registry')\n\n  functionRegistry.add('svg-gradient', function(direction) {\n    let stops\n    let gradientDirectionSvg\n    let gradientType = 'linear'\n    let rectangleDimension = 'x=\"0\" y=\"0\" width=\"1\" height=\"1\"'\n    const renderEnv = { compress: false }\n    let returner\n    const directionValue = direction.toCSS(renderEnv)\n    let i\n    let color\n    let position\n    let positionValue\n    let alpha\n\n    function throwArgumentDescriptor() {\n      throw {\n        type: 'Argument',\n        message:\n          'svg-gradient expects direction, start_color [start_position], [color position,]...,' +\n          ' end_color [end_position] or direction, color list',\n      }\n    }\n\n    if (arguments.length == 2) {\n      if (arguments[1].value.length < 2) {\n        throwArgumentDescriptor()\n      }\n      stops = arguments[1].value\n    } else if (arguments.length < 3) {\n      throwArgumentDescriptor()\n    } else {\n      stops = Array.prototype.slice.call(arguments, 1)\n    }\n\n    switch (directionValue) {\n      case 'to bottom':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"'\n        break\n      case 'to right':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"'\n        break\n      case 'to bottom right':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"100%\"'\n        break\n      case 'to top right':\n        gradientDirectionSvg = 'x1=\"0%\" y1=\"100%\" x2=\"100%\" y2=\"0%\"'\n        break\n      case 'ellipse':\n      case 'ellipse at center':\n        gradientType = 'radial'\n        gradientDirectionSvg = 'cx=\"50%\" cy=\"50%\" r=\"75%\"'\n        rectangleDimension = 'x=\"-50\" y=\"-50\" width=\"101\" height=\"101\"'\n        break\n      default:\n        throw {\n          type: 'Argument',\n          message:\n            \"svg-gradient direction must be 'to bottom', 'to right',\" +\n            \" 'to bottom right', 'to top right' or 'ellipse at center'\",\n        }\n    }\n    returner = `<?xml version=\"1.0\" ?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" viewBox=\"0 0 1 1\" preserveAspectRatio=\"none\"><${gradientType}Gradient id=\"gradient\" gradientUnits=\"userSpaceOnUse\" ${gradientDirectionSvg}>`\n\n    for (i = 0; i < stops.length; i += 1) {\n      if (stops[i] instanceof Expression) {\n        color = stops[i].value[0]\n        position = stops[i].value[1]\n      } else {\n        color = stops[i]\n        position = undefined\n      }\n\n      if (\n        !(color instanceof Color) ||\n        (!((i === 0 || i + 1 === stops.length) && position === undefined) &&\n          !(position instanceof Dimension))\n      ) {\n        throwArgumentDescriptor()\n      }\n      positionValue = position\n        ? position.toCSS(renderEnv)\n        : i === 0 ? '0%' : '100%'\n      alpha = color.alpha\n      returner += `<stop offset=\"${positionValue}\" stop-color=\"${color.toRGB()}\"${alpha <\n      1\n        ? ' stop-opacity=\"' + alpha + '\"'\n        : ''}/>`\n    }\n    returner += `</${gradientType}Gradient><rect ${rectangleDimension} fill=\"url(#gradient)\" /></svg>`\n\n    returner = encodeURIComponent(returner)\n\n    returner = `data:image/svg+xml,${returner}`\n    return new URL(\n      new Quoted(\n        `'${returner}'`,\n        returner,\n        false,\n        this.index,\n        this.currentFileInfo\n      ),\n      this.index,\n      this.currentFileInfo\n    )\n  })\n}\n","const Keyword = require('../tree/keyword')\nconst DetachedRuleset = require('../tree/detached-ruleset')\nconst Dimension = require('../tree/dimension')\nconst Color = require('../tree/color')\nconst Quoted = require('../tree/quoted')\nconst Anonymous = require('../tree/anonymous')\nconst URL = require('../tree/url')\nconst Operation = require('../tree/operation')\nconst functionRegistry = require('./function-registry')\nconst isa = (n, Type) => (n instanceof Type ? Keyword.True : Keyword.False)\n\nconst isunit = (n, unit) => {\n  if (unit === undefined) {\n    throw {\n      type: 'Argument',\n      message: 'missing the required second argument to isunit.',\n    }\n  }\n  unit = typeof unit.value === 'string' ? unit.value : unit\n  if (typeof unit !== 'string') {\n    throw {\n      type: 'Argument',\n      message: 'Second argument to isunit should be a unit or a string.',\n    }\n  }\n  return n instanceof Dimension && n.unit.is(unit)\n    ? Keyword.True\n    : Keyword.False\n}\n\nconst getItemsFromNode = node => {\n  // handle non-array values as an array of length 1\n  // return 'undefined' if index is invalid\n  const items = Array.isArray(node.value) ? node.value : Array(node)\n\n  return items\n}\n\nfunctionRegistry.addMultiple({\n  isruleset(n) {\n    return isa(n, DetachedRuleset)\n  },\n  iscolor(n) {\n    return isa(n, Color)\n  },\n  isnumber(n) {\n    return isa(n, Dimension)\n  },\n  isstring(n) {\n    return isa(n, Quoted)\n  },\n  iskeyword(n) {\n    return isa(n, Keyword)\n  },\n  isurl(n) {\n    return isa(n, URL)\n  },\n  ispixel(n) {\n    return isunit(n, 'px')\n  },\n  ispercentage(n) {\n    return isunit(n, '%')\n  },\n  isem(n) {\n    return isunit(n, 'em')\n  },\n  isunit,\n  unit(val, unit) {\n    if (!(val instanceof Dimension)) {\n      throw {\n        type: 'Argument',\n        message: `the first argument to unit must be a number${val instanceof\n        Operation\n          ? '. Have you forgotten parenthesis?'\n          : ''}`,\n      }\n    }\n    if (unit) {\n      if (unit instanceof Keyword) {\n        unit = unit.value\n      } else {\n        unit = unit.toCSS()\n      }\n    } else {\n      unit = ''\n    }\n    return new Dimension(val.value, unit)\n  },\n  'get-unit': function(n) {\n    return new Anonymous(n.unit)\n  },\n  extract(values, index) {\n    index = index.value - 1 // (1-based index)\n\n    return getItemsFromNode(values)[index]\n  },\n  length(values) {\n    return new Dimension(getItemsFromNode(values).length)\n  },\n})\n","module.exports = environment => {\n  const functions = {\n    functionRegistry: require('./function-registry'),\n    functionCaller: require('./function-caller'),\n  }\n\n  //register functions\n  require('./default')\n  require('./color')\n  require('./color-blending')\n  require('./data-uri')(environment)\n  require('./math')\n  require('./number')\n  require('./string')\n  require('./svg')(environment)\n  require('./types')\n\n  return functions\n}\n","module.exports = (environment, ParseTree) => {\n  const render = function(input, options, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    if (!callback) {\n      const self = this\n      return new Promise((resolve, reject) => {\n        render.call(self, input, options, (err, output) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve(output)\n          }\n        })\n      })\n    } else {\n      this.parse(input, options, (err, root, imports, options) => {\n        if (err) {\n          return callback(err)\n        }\n\n        let result\n        try {\n          const parseTree = new ParseTree(root, imports)\n          result = parseTree.toCSS(options)\n        } catch (err) {\n          return callback(err)\n        }\n\n        callback(null, result)\n      })\n    }\n  }\n\n  return render\n}\n","/**\n * Plugin Manager\n */\nclass PluginManager {\n  constructor(less) {\n    this.less = less\n    this.visitors = []\n    this.preProcessors = []\n    this.postProcessors = []\n    this.installedPlugins = []\n    this.fileManagers = []\n  }\n\n  /**\n     * Adds all the plugins in the array\n     * @param {Array} plugins\n     */\n  addPlugins(plugins) {\n    if (plugins) {\n      for (let i = 0; i < plugins.length; i++) {\n        this.addPlugin(plugins[i])\n      }\n    }\n  }\n\n  /**\n     *\n     * @param plugin\n     */\n  addPlugin(plugin) {\n    this.installedPlugins.push(plugin)\n    plugin.install(this.less, this)\n  }\n\n  /**\n     * Adds a visitor. The visitor object has options on itself to determine\n     * when it should run.\n     * @param visitor\n     */\n  addVisitor(visitor) {\n    this.visitors.push(visitor)\n  }\n\n  /**\n     * Adds a pre processor object\n     * @param {object} preProcessor\n     * @param {number} priority - guidelines 1 = before import, 1000 = import, 2000 = after import\n     */\n  addPreProcessor(preProcessor, priority) {\n    let indexToInsertAt\n    for (\n      indexToInsertAt = 0;\n      indexToInsertAt < this.preProcessors.length;\n      indexToInsertAt++\n    ) {\n      if (this.preProcessors[indexToInsertAt].priority >= priority) {\n        break\n      }\n    }\n    this.preProcessors.splice(indexToInsertAt, 0, { preProcessor, priority })\n  }\n\n  /**\n     * Adds a post processor object\n     * @param {object} postProcessor\n     * @param {number} priority - guidelines 1 = before compression, 1000 = compression, 2000 = after compression\n     */\n  addPostProcessor(postProcessor, priority) {\n    let indexToInsertAt\n    for (\n      indexToInsertAt = 0;\n      indexToInsertAt < this.postProcessors.length;\n      indexToInsertAt++\n    ) {\n      if (this.postProcessors[indexToInsertAt].priority >= priority) {\n        break\n      }\n    }\n    this.postProcessors.splice(indexToInsertAt, 0, { postProcessor, priority })\n  }\n\n  /**\n     *\n     * @param manager\n     */\n  addFileManager(manager) {\n    this.fileManagers.push(manager)\n  }\n\n  /**\n     *\n     * @returns {Array}\n     * @private\n     */\n  getPreProcessors() {\n    const preProcessors = []\n    for (let i = 0; i < this.preProcessors.length; i++) {\n      preProcessors.push(this.preProcessors[i].preProcessor)\n    }\n    return preProcessors\n  }\n\n  /**\n     *\n     * @returns {Array}\n     * @private\n     */\n  getPostProcessors() {\n    const postProcessors = []\n    for (let i = 0; i < this.postProcessors.length; i++) {\n      postProcessors.push(this.postProcessors[i].postProcessor)\n    }\n    return postProcessors\n  }\n\n  /**\n     *\n     * @returns {Array}\n     * @private\n     */\n  getVisitors() {\n    return this.visitors\n  }\n\n  /**\n     *\n     * @returns {Array}\n     * @private\n     */\n  getFileManagers() {\n    return this.fileManagers\n  }\n}\n\nmodule.exports = PluginManager\n","let PromiseConstructor\nconst contexts = require('./contexts')\nconst Parser = require('./parser/parser')\nconst PluginManager = require('./plugin-manager')\n\nmodule.exports = (environment, ParseTree, ImportManager) => {\n  const parse = function(input, options = {}, callback) {\n    if (typeof options === 'function') {\n      callback = options\n      options = {}\n    }\n\n    if (!callback) {\n      const self = this\n      return new Promise((resolve, reject) => {\n        parse.call(self, input, options, (err, output) => {\n          if (err) {\n            reject(err)\n          } else {\n            resolve(output)\n          }\n        })\n      })\n    } else {\n      let context\n      let rootFileInfo\n      const pluginManager = new PluginManager(this)\n\n      pluginManager.addPlugins(options.plugins)\n      options.pluginManager = pluginManager\n\n      context = new contexts.Parse(options)\n\n      if (options.rootFileInfo) {\n        rootFileInfo = options.rootFileInfo\n      } else {\n        const filename = options.filename || 'input'\n        const entryPath = filename.replace(/[^\\/\\\\]*$/, '')\n        rootFileInfo = {\n          filename,\n          relativeUrls: context.relativeUrls,\n          rootpath: context.rootpath || '',\n          currentDirectory: entryPath,\n          entryPath,\n          rootFilename: filename,\n        }\n        // add in a missing trailing slash\n        if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== '/') {\n          rootFileInfo.rootpath += '/'\n        }\n      }\n\n      const imports = new ImportManager(context, rootFileInfo)\n\n      new Parser(context, imports, rootFileInfo).parse(\n        input,\n        (e, root) => {\n          if (e) {\n            return callback(e)\n          }\n          callback(null, root, imports, options)\n        },\n        options\n      )\n    }\n  }\n  return parse\n}\n","module.exports = (environment, fileManagers) => {\n  const Environment = require('./environment/environment')\n  environment = new Environment(environment, fileManagers)\n\n  const SourceMapOutput = require('./source-map-output')(environment)\n  const SourceMapBuilder = require('./source-map-builder')(\n    SourceMapOutput,\n    environment\n  )\n  const ParseTree = require('./parse-tree')(SourceMapBuilder)\n  const ImportManager = require('./import-manager')(environment)\n\n  return {\n    version: [2, 7, 2],\n    data: require('./data'),\n    tree: require('./tree'),\n    Environment,\n    environment,\n    AbstractFileManager: require('./environment/abstract-file-manager'),\n    visitors: require('./visitors'),\n    Parser: require('./parser/parser'),\n    functions: require('./functions')(environment),\n    contexts: require('./contexts'),\n    SourceMapOutput,\n    SourceMapBuilder,\n    ParseTree,\n    ImportManager: ImportManager,\n    render: require('./render')(environment, ParseTree, ImportManager),\n    parse: require('./parse')(environment, ParseTree, ImportManager),\n    LessError: require('./less-error'),\n    transformTree: require('./transform-tree'),\n    utils: require('./utils'),\n    PluginManager: require('./plugin-manager'),\n    logger: require('./logger'),\n    writeError(ctx, options) {\n      options = options || {}\n      if (options.silent) {\n        return\n      }\n      console.error(this.formatError(ctx, options))\n    },\n    formatError(ctx) {\n      let message = ''\n      let extract = ctx.extract\n      let error = []\n\n      // only output a stack if it isn't a less error\n      if (ctx.stack && !ctx.type) {\n        return ctx.stack\n      }\n\n      if (!ctx.hasOwnProperty('index') || !extract) {\n        return ctx.stack || ctx.message\n      }\n\n      if (typeof extract[0] === 'string') {\n        error.push(`${ctx.line - 1} ${extract[0]}`)\n      }\n\n      if (typeof extract[1] === 'string') {\n        let errorTxt = `${ctx.line} `\n        if (extract[1]) {\n          errorTxt +=\n            extract[1].slice(0, ctx.column) +\n            extract[1].substr(ctx.column, 1) +\n            extract[1].slice(ctx.column + 1)\n        }\n        error.push(errorTxt)\n      }\n\n      if (typeof extract[2] === 'string') {\n        error.push(`${ctx.line + 1} ${extract[2]}`)\n      }\n      error = `${error.join('\\n')}\\n`\n\n      message += `${ctx.type}Error: ${ctx.message}`\n      if (ctx.filename) {\n        message += ` in ${ctx.filename} on line ${ctx.line}, column ${ctx.column +\n          1}:`\n      }\n\n      message += `\\n${error}`\n\n      if (ctx.callLine) {\n        message += `from ${ctx.filename || ''}/n`\n        message += `${ctx.callLine} ${ctx.callExtract}/n`\n      }\n      return message\n    },\n  }\n}\n","const createFromEnvironment = require('../less')\nconst AbstractFileManager = require('../less/environment/abstract-file-manager.js')\n\nclass NotSupportedFileManager extends AbstractFileManager {\n  supports() {\n    return true\n  }\n\n  supportsSync() {\n    return true\n  }\n\n  loadFile() {\n    return Promise.reject(new Error('loading is not supported'))\n  }\n\n  loadFileSync() {\n    new Error('loading is not supported')\n  }\n}\n\nconst less = createFromEnvironment(\n  {\n    getSourceMapGenerator: function() {\n      return null\n    },\n  },\n  [new NotSupportedFileManager()]\n)\nless.FileManager = NotSupportedFileManager\n\nmodule.exports = less\n"]}